{"expand":"renderedFields,names,schema,transitions,operations,editmeta,changelog","id":"12467577","self":"https://issues.apache.org/jira/rest/api/latest/issue/12467577","key":"CASSANDRA-1216","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12310865","id":"12310865","key":"CASSANDRA","name":"Cassandra","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12310865&avatarId=12034","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12310865&avatarId=12034","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12310865&avatarId=12034","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12310865&avatarId=12034"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/11961","id":"11961","description":"Apache Cassandra related projects","name":"Cassandra"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12315251","id":"12315251","description":"","name":"0.7 beta 2","archived":false,"released":true,"releaseDate":"2010-10-01"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12310220":"2010-07-02 15:16:54.612","customfield_12312322":null,"customfield_12312323":null,"customfield_12310222":"10002_*:*_3_*:*_3721935423_*|*_1_*:*_3_*:*_4714534182_*|*_5_*:*_1_*:*_0","customfield_12310420":"20035","customfield_12312320":null,"customfield_12312321":null,"customfield_12312120":null,"customfield_12312121":null,"resolutiondate":"2010-09-28T05:56:10.038+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312326":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312324":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/CASSANDRA-1216/watchers","watchCount":1,"isWatching":false},"created":"2010-06-22T14:28:20.433+0000","customfield_10022":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gdusbabek","name":"gdusbabek","emailAddress":"gdusbabek at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gdusbabek&avatarId=10070","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gdusbabek&avatarId=10070","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gdusbabek&avatarId=10070","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gdusbabek&avatarId=10070"},"displayName":"Gary Dusbabek","active":true},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12311124":null,"customfield_12312334":null,"customfield_12310310":"3.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"issuelinks":[],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"customfield_12312337":null,"customfield_12312338":null,"updated":"2010-09-28T13:31:34.176+0000","customfield_12312335":null,"customfield_12311720":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/5","description":"A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/resolved.png","name":"Resolved","id":"5","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/12312978","id":"12312978","name":"Core"}],"timeoriginalestimate":null,"description":"this means that if something goes wrong during the re-replication (e.g. a source node is restarted) there is (a) no indication that anything has gone wrong and (b) no way to restart the process (other than the Big Hammer of running repair)","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12312024":null,"attachment":[{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12455298","id":"12455298","filename":"0001-Modify-removeToken-to-be-similar-to-decommission.patch","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-09-22T20:24:11.509+0000","size":31525,"mimeType":"text/plain","content":"https://issues.apache.org/jira/secure/attachment/12455298/0001-Modify-removeToken-to-be-similar-to-decommission.patch"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12455299","id":"12455299","filename":"0002-Additional-tests-for-removeToken.patch","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-09-22T20:24:11.571+0000","size":23159,"mimeType":"text/plain","content":"https://issues.apache.org/jira/secure/attachment/12455299/0002-Additional-tests-for-removeToken.patch"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12455666","id":"12455666","filename":"0003-Fixes-from-review.patch","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-09-27T15:54:58.512+0000","size":2584,"mimeType":"text/plain","content":"https://issues.apache.org/jira/secure/attachment/12455666/0003-Fixes-from-review.patch"}],"customfield_12312340":null,"aggregatetimeestimate":null,"customfield_12312022":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12310921":null,"customfield_12310920":"92031","summary":"removetoken drops node from ring before re-replicating its data is finished","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"subtasks":[],"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"customfield_12310291":null,"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"customfield_12311420":null,"customfield_12311421":null,"environment":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"startAt":0,"maxResults":29,"total":29,"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12884714","id":"12884714","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"body":"A possible solution I see for this is to keep nodes in the justRemovedEndpoints map in Gossiper until we can verify that replication has completed.  I think we could accomplish verification through a callback on the replicate request.  I'm unsure about what data gets persisted so I don't know if a restart would wipe out the justRemovedEndpoints map","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-07-02T15:16:54.612+0000","updated":"2010-07-02T15:16:54.612+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12884736","id":"12884736","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"body":"So clearly that solution would fail in the case of the node that is attempting to retrive the data failing.  Perhaps a better solution is simply not removing the node until replication and done.  Perhaps marking it with a new state?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-07-02T16:12:01.599+0000","updated":"2010-07-02T16:12:01.599+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12885653","id":"12885653","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"body":"It seems like this should follow a pattern similar to decommissioning a node.\r\n\r\n* If nodeA has removeToken called on it, it becomes responsible for nodeB, the node to remove\r\n* nodeA sets the MOVE_STATE of nodeB to STATE_REMOVING\r\n* This is gossipped throughout the ring.\r\n* Nodes see this change and fetch any ranges they are becoming responsible for\r\n** After this is complete they will need to notify nodeA somehow that this is complete\r\n* Once nodeA sees all replications have finished, change state of nodeB to STATE_REMOVED\r\n* All nodes then remove nodeB from their ring.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-07-06T19:41:19.962+0000","updated":"2010-07-06T19:41:19.962+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12885655","id":"12885655","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"body":"agreed","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"created":"2010-07-06T19:42:56.732+0000","updated":"2010-07-06T19:42:56.732+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12885702","id":"12885702","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"body":"A side effect of this approach may be that you would need to call removeToken on a node that had seen the token previously.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-07-06T21:46:59.106+0000","updated":"2010-07-06T21:46:59.106+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12885730","id":"12885730","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"body":"since all tokens will be propagated to all nodes (even ones brought up after the dead node went down), that's not a problem","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"created":"2010-07-06T23:19:05.472+0000","updated":"2010-07-06T23:19:05.472+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12890489","id":"12890489","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"body":"* 0001 - changes to make removeToken behave similarly to decomission\r\n* 0002 - fixes to existing tests since the state for STATE_LEFT changed\r\n\r\nI am still working on some good unit tests for these changes but these are the changes so far.\r\n\r\nThe new process for removeToken is basically the one outlined above. One change is that instead of a STATE_REMOVED state it seemed like tokens that are removed should just go into STATE_LEFT similar to nodes that are decommissioned.\r\n\r\nOne thing I'm not sure of is the timeout values for waiting for replications to stream and for waiting for replication notifications. Currently they are just set arbitrarily in that patch. Need to determine good values for these.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-07-20T22:37:17.306+0000","updated":"2010-07-20T22:37:17.306+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12892922","id":"12892922","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"body":"Some fixes and tests added.\r\n\r\nThere is one thing that still needs to be fixed.\r\n * Currently the call to removeToken blocks either:\r\n ** until all nodes confirm that they have replicated the data for the dead node.\r\n ** or a timeout is reached\r\n * I'm not sure what the timeout for this should be. Additionally when nodes throughout the ring attempt to replicate data there should be a similar timeout before they give up on a source and retry.\r\n * Also clients may timeout before the timeout is even reached or all the data is replicated. I'm not sure how the user will be able to determine if the remove finished correctly or repair should be run.  \r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-07-27T20:53:38.010+0000","updated":"2010-07-27T20:53:38.010+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12892944","id":"12892944","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"body":"Updated 0001 patch. It was missing a class before. Oops.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-07-27T21:39:02.191+0000","updated":"2010-07-27T21:39:02.191+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12898253","id":"12898253","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gdusbabek","name":"gdusbabek","emailAddress":"gdusbabek at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gdusbabek&avatarId=10070","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gdusbabek&avatarId=10070","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gdusbabek&avatarId=10070","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gdusbabek&avatarId=10070"},"displayName":"Gary Dusbabek","active":true},"body":"Nick, can you rebase?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gdusbabek","name":"gdusbabek","emailAddress":"gdusbabek at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gdusbabek&avatarId=10070","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gdusbabek&avatarId=10070","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gdusbabek&avatarId=10070","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gdusbabek&avatarId=10070"},"displayName":"Gary Dusbabek","active":true},"created":"2010-08-13T14:36:12.484+0000","updated":"2010-08-13T14:36:12.484+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12898400","id":"12898400","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"body":"Rebased.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-08-13T20:11:21.503+0000","updated":"2010-08-13T20:11:21.503+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12898442","id":"12898442","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"body":"Re-rebased.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-08-13T22:18:48.875+0000","updated":"2010-08-13T22:18:48.875+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12899499","id":"12899499","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gdusbabek","name":"gdusbabek","emailAddress":"gdusbabek at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gdusbabek&avatarId=10070","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gdusbabek&avatarId=10070","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gdusbabek&avatarId=10070","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gdusbabek&avatarId=10070"},"displayName":"Gary Dusbabek","active":true},"body":"RemoveTest needs some cleanup.\r\n* ReplicationSink doesn't need callCount\r\n* NotificationSink doesn't need hitList\r\n* testRemoveToken and testStartRemoving abuse Gossiper.start().  Consider adding a method to Gossiper that initializes the epstate for a given node.  E.g.: initializeNodeUnsafe(InetAddr addr, int generation).\r\n* (minor nit) I wish there were a way to assert that tmd.getLeavingNodes() actually has nodes in it.\r\n* all the methods throw UnknownHostException, but don't need to (IOException covers it)\r\n* testStartRemoving should assert preconditions before calling ss.onChange (it also makes the same assertion twice).\r\n\r\nStorageService:\r\n* (minor nit) a comment describing the distinction between the leaving and removing constants.\r\n* SS.removeToken() shouldn't throw a RuntimeException, as the client won't know what to make of it.  Declare an exception in the interface and throw it in the impl.  I imagine this will be a fairly common case (e.g.: when a node is down).\r\n* SS.setReplicatingNodes and clearReplicatingNodes can be inlined into removeToken. It saves a few lines and obviates a local var.\r\n* SS.replicateTables should probably be merged into SS.restoreReplicaCount.\r\n\r\nWas the intent that SS.replicateTables block until the files are transferred?  Because it doesn't.  AFAICT it blocks until the first ack comes back from each source node, which is a good indication that streaming has started, but not that it is finished.\r\n\r\nI couldn't verify that the callbacks are ever called.  That happens on the READ_RESPONSE stage and afaict, none of the streaming code path ever puts a task there.  That's a painful interface to follow though, so I might be wrong.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gdusbabek","name":"gdusbabek","emailAddress":"gdusbabek at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gdusbabek&avatarId=10070","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gdusbabek&avatarId=10070","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gdusbabek&avatarId=10070","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gdusbabek&avatarId=10070"},"displayName":"Gary Dusbabek","active":true},"created":"2010-08-17T18:08:08.003+0000","updated":"2010-08-17T18:08:08.003+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12899993","id":"12899993","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"body":"Yeah I wasn't really understanding that streaming/messaging code at all.\r\n\r\nThe current StreamOut implementation has a callback concept however.  I think this should be moved into the StreamContext object and then both StreamOut and StreamIn can perform callbacks on actual stream completion.  ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-08-18T19:51:13.558+0000","updated":"2010-08-18T19:51:13.558+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12900015","id":"12900015","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gdusbabek","name":"gdusbabek","emailAddress":"gdusbabek at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gdusbabek&avatarId=10070","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gdusbabek&avatarId=10070","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gdusbabek&avatarId=10070","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gdusbabek&avatarId=10070"},"displayName":"Gary Dusbabek","active":true},"body":"The StreamOut callback works differently than the MessagingService callback.  Your approach sounds workable.  I don't think it matters where you push the callback to, so long as you make sure it gets executed after the stream is finished.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gdusbabek","name":"gdusbabek","emailAddress":"gdusbabek at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gdusbabek&avatarId=10070","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gdusbabek&avatarId=10070","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gdusbabek&avatarId=10070","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gdusbabek&avatarId=10070"},"displayName":"Gary Dusbabek","active":true},"created":"2010-08-18T20:15:40.888+0000","updated":"2010-08-18T20:15:40.888+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12901589","id":"12901589","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"body":"bq. (minor nit) I wish there were a way to assert that tmd.getLeavingNodes() actually has nodes in it.\r\n\r\nThis is what tmd.isLeaving() does\r\n\r\nbq. testStartRemoving should assert preconditions before calling ss.onChange (it also makes the same assertion twice).\r\n\r\nI'm not sure what preconditions you mean. I added an assertion to make sure there are no endpoints already leaving.\r\n\r\nbq. SS.removeToken() shouldn't throw a RuntimeException,\r\n\r\nDo you think the UnsupportedOperationExceptions should be removed as well? These existed previously.\r\n\r\nI modified the callback support for streaming so that the code should wait for all streams to finish before confirming. I also added a reply to the ReplicationFinishedHandler so the IAsyncResult will be updated.  \r\n\r\nThoughts?\r\n\r\nThe timeout values for waiting on the latches still need to be updated.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-08-23T21:12:02.145+0000","updated":"2010-08-23T21:12:02.145+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12902468","id":"12902468","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gdusbabek","name":"gdusbabek","emailAddress":"gdusbabek at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gdusbabek&avatarId=10070","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gdusbabek&avatarId=10070","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gdusbabek&avatarId=10070","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gdusbabek&avatarId=10070"},"displayName":"Gary Dusbabek","active":true},"body":"> Do you think the UnsupportedOperationExceptions should be removed as well? These existed previously.\r\nMy bad; I didn't notice that.  RTE was probably ok.\r\n\r\n> I modified the callback support for streaming so that the code should wait for all streams to finish before confirming. I also added a reply to the ReplicationFinishedHandler so the IAsyncResult will be updated\r\nFirst glance tells me this will work.  I'll run some tests after I'm done reviewing.\r\n\r\n> The timeout values for waiting on the latches still need to be updated.\r\nIs this coming in another patch?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gdusbabek","name":"gdusbabek","emailAddress":"gdusbabek at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gdusbabek&avatarId=10070","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gdusbabek&avatarId=10070","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gdusbabek&avatarId=10070","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gdusbabek&avatarId=10070"},"displayName":"Gary Dusbabek","active":true},"created":"2010-08-25T14:51:51.804+0000","updated":"2010-08-25T14:51:51.804+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12902503","id":"12902503","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gdusbabek","name":"gdusbabek","emailAddress":"gdusbabek at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gdusbabek&avatarId=10070","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gdusbabek&avatarId=10070","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gdusbabek&avatarId=10070","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gdusbabek&avatarId=10070"},"displayName":"Gary Dusbabek","active":true},"body":"I see this in RemoveTest:\r\n\r\n\r\n [junit] Testsuite: org.apache.cassandra.service.RemoveTest\r\n    [junit] Tests run: 4, Failures: 0, Errors: 0, Time elapsed: 1.97 sec\r\n    [junit] \r\n    [junit] ------------- Standard Error -----------------\r\n    [junit] ERROR 11:27:58,277 Did not find matching ranges on /127.0.0.6\r\n    [junit] ERROR 11:27:58,279 Did not find matching ranges on /127.0.0.6\r\n    [junit] ERROR 11:27:58,280 Did not find matching ranges on /127.0.0.5\r\n    [junit] ERROR 11:27:58,280 Did not find matching ranges on /127.0.0.4\r\n    [junit] ERROR 11:27:58,280 Did not find matching ranges on /127.0.0.2\r\n    [junit] ERROR 11:27:59,264 Did not find matching ranges on /127.0.0.6\r\n    [junit] ERROR 11:27:59,272 Did not find matching ranges on /127.0.0.6\r\n    [junit] ERROR 11:27:59,276 Did not find matching ranges on /127.0.0.5\r\n    [junit] ERROR 11:27:59,279 Did not find matching ranges on /127.0.0.4\r\n    [junit] ERROR 11:27:59,283 Did not find matching ranges on /127.0.0.2\r\n    [junit] ------------- ---------------- ---------------\r\n\r\nIs that ok?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gdusbabek","name":"gdusbabek","emailAddress":"gdusbabek at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gdusbabek&avatarId=10070","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gdusbabek&avatarId=10070","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gdusbabek&avatarId=10070","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gdusbabek&avatarId=10070"},"displayName":"Gary Dusbabek","active":true},"created":"2010-08-25T16:30:39.883+0000","updated":"2010-08-25T16:30:39.883+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12902509","id":"12902509","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"body":"Re: timeouts\r\n\r\nYes I'm just not sure how to approach determining the right values for these.  Depends mostly on the amount of data and network bandwidth.\r\n\r\nRe: RemoveTest\r\n\r\nYeah. The message sink in the test immediately responds to the stream request saying there are no files to stream.  This makes the StreamInManager think the data didn't exist remotely.  Doing it that way seems much easier than trying to make the test actually stream something.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-08-25T16:38:50.971+0000","updated":"2010-08-25T16:38:50.971+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12902511","id":"12902511","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gdusbabek","name":"gdusbabek","emailAddress":"gdusbabek at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gdusbabek&avatarId=10070","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gdusbabek&avatarId=10070","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gdusbabek&avatarId=10070","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gdusbabek&avatarId=10070"},"displayName":"Gary Dusbabek","active":true},"body":"Some questions about the coordinator...  I see that removeToken() is quasi-blocking now, like unbootstrap() (it was fire-and-forget before).  What are the consequences of the coordinator node going down?  Assuming a dead coordinator, would it be Bad for another node to remove-token on the same token while the transfers initiated by the original failed coordinator were in process?  Or assuming the transfers were finished, would a remove-token on a new coordinator generally do little other than get the state to LEFT?\r\n\r\nI think I'm of the opinion that removeToken should either block until the transfer is complete (or failed), or should return instantly, and that we need to make sure that subsequent removeToken calls do not upset existing transfers.  Having it return error after a timeout (which is possible in the case of LOTS of data) makes me think we should be doing differently.\r\n\r\nOr is the only recourse to repair?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gdusbabek","name":"gdusbabek","emailAddress":"gdusbabek at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gdusbabek&avatarId=10070","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gdusbabek&avatarId=10070","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gdusbabek&avatarId=10070","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gdusbabek&avatarId=10070"},"displayName":"Gary Dusbabek","active":true},"created":"2010-08-25T16:42:14.939+0000","updated":"2010-08-25T16:42:14.939+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12902523","id":"12902523","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"body":"I believe the only consequences of calling removeToken on another node when the coordinator goes down would be that the entire operation would be repeated. So any data that was transferred before would be transferred again.  I think this is the right behavior since there is no way of knowing what was transferred before the coordinator went down.  \r\n\r\nIt might be useful to add a 'force' option though.  If the coordinator goes down and the token gets stuck in a REMOVING state you may want to force removal rather than redoing the entire operation. \r\n\r\nIt should be possible to remove the timeout so that removeToken blocks until the transfer is completely finished.  The code for streaming in the remote data blocks until all streams are complete and the code for sending a confirmation to the coordinator will keep retrying until it is received or the coordinator dies.  \r\n\r\nI think this would work if a check was added so that you can only call removeToken a second time if the coordinator is down.  It wouldn't handle two calls that occurred before the state made its way through gossip though.  \r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-08-25T17:06:01.760+0000","updated":"2010-08-25T17:06:01.760+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12903538","id":"12903538","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"body":"After some more thinking I think there are two problems here.\r\n\r\n * The timeout for waiting on a stream to complete - An arbitrary timeout here is not the right way to do this. What we really need is the concept of stream progress. We should be able to verify that a stream is progressing or not and based on that retry it.  CASSANDRA-1438 kind of relates to this problem and could be modified to implement this.  \r\n\r\n * The timeout waiting for nodes to confirm replication - Ideally there could be no timeout here. The problem though is if a node that should be grabbing data goes down permanently, removeToken will wait forever.  I think it's reasonable to have some sort of timeout in this case. A log message/error can indicate which machines were being waited on for replication. An administrator should know if that machine went down or is still streaming. That will determine if repair needs to be run.  The alternative to this I guess would be periodically waking up and checking that the nodes we are waiting on are still alive.  That wouldn't be particularly hard to implement\r\n\r\nI don't think returning immediately from the call is the right approach.  That is part of the reason why this ticket is created. In the case that replication fails somewhere, there is no feedback to the user.  At least timing out eventually provides information about which machines we think failed to replicate data.  \r\n\r\nAs far as multiple remove calls and the coordinator going down.  I think there should be a 'force' option in the case the coordinator goes down and you believe the rest of the nodes completed the operation.  To prevent multiple calls to removeToken there should just be a check to make sure the coordinator is dead before another call can be performed.\r\n\r\nSo besides those few changes above, I think we should either implement this part way with a time out for stream replication or postpone completion here until we add the concept of stream progress.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-08-27T19:06:33.592+0000","updated":"2010-08-27T19:06:33.592+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12913206","id":"12913206","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"body":"Patches:\r\n * 0001\r\n ** Modifies the removeToken operation to follow a pattern of NORMAL->REMOVING->LEFT, rather than the current pattern of a coordinator node setting its own status to a special cased version of NORMAL.\r\n ** Fixes a small bug in StreamHeader serialization\r\n ** Adds the ability to either get the status of a remove operation taking place or force a remove operation to finish immediately\r\n * 0002\r\n ** Tests for removing tokens\r\n ** Move shared code for creating a ring to Util class\r\n\r\n\r\nRemoval Process:\r\n * Normal Case\r\n *# Coordinator sets status of failed node to REMOVING\r\n *# Coordinator blocks on confirmation from other nodes\r\n *# Any newly responsible nodes stream data\r\n *# Newly responsible nodes send confirmation once all data has streamed\r\n *# Coordinator updates status of failed node to LEFT\r\n *# Done\r\n * Failure Cases\r\n ** Coordinator failure\r\n *** If the coordinator fails the remove operation will need to be retried\r\n *** This can be done on any node in the cluster.  \r\n **  Newly responsible node failure\r\n *** If a newly responsible node fails but comes back up, it should see the REMOVING status in gossip and restart the operation\r\n *** If a newly responsible node fails permanently or a streaming operation fails and the node stays up, the coordinator will block forever while waiting for confirmation.  The best solution is to force the remove operation to complete and then run repair on the failed node.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-09-21T19:43:39.167+0000","updated":"2010-09-21T19:43:39.167+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12913634","id":"12913634","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"body":"Bah.  Gossip marks the node alive when it receives an updated application state. Reverting it to modifying the coordinator nodes state.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-09-22T16:01:26.202+0000","updated":"2010-09-22T16:01:26.202+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12913764","id":"12913764","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"body":"Ok this should be ready for review now.  The process is:\r\n\r\n# Coordinator node modifies its own status to NORMAL - REMOVING to indicate which node is being removed\r\n# Coordinator blocks on removal confirmaton from other nodes\r\n# Newly responsible nodes see this status and begin fetching new data\r\n# Newly responsible nodes notify coordinator they have replicated all data\r\n# Coordinator node updates its own status to NORMAL - REMOVED to indicate the removal is complete\r\n# This causes all nodes to remove the node from gossip/tokenmetadata. \r\n# Done\r\n\r\nTested this with a 3 node cluster in the cloud, as well as testing the new getStatus and forceRemoval operations.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-09-22T20:29:38.337+0000","updated":"2010-09-22T20:29:38.337+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12915227","id":"12915227","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gdusbabek","name":"gdusbabek","emailAddress":"gdusbabek at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gdusbabek&avatarId=10070","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gdusbabek&avatarId=10070","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gdusbabek&avatarId=10070","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gdusbabek&avatarId=10070"},"displayName":"Gary Dusbabek","active":true},"body":"This looks good.\r\n\r\n1.  There were a few unused local variables in SS.retoreReplicationCount().  Was this just leftovers from a rebase?\r\n2.  SS.handleStateRemoving removes a null check that previously existed for epThatLeft (renamed removeEndpoint).  Was the original null-check pointless or was something missed in the change?\r\n3.  You made a change to StreamHeader that made me think you were running into cases where SH.pendingFiles == null.  Is that true?  Tracing the codepaths makes me think this is not possible.\r\n\r\nDon't bother with the cleanup in 1.  I'm more curious about 2 and 3.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gdusbabek","name":"gdusbabek","emailAddress":"gdusbabek at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gdusbabek&avatarId=10070","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gdusbabek&avatarId=10070","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gdusbabek&avatarId=10070","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gdusbabek&avatarId=10070"},"displayName":"Gary Dusbabek","active":true},"created":"2010-09-27T07:58:07.885+0000","updated":"2010-09-27T07:58:07.885+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12915340","id":"12915340","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"body":"1 and 2 are just errors on my part. I changed 3 because I was under the impression that a stream request to an endpoint that doesn't contain any of the ranges requested would create a header with null for pendingFiles.  I at first wrote one of the tests to behave like that, and got the NPE.  Looks like it changed or was never like that.\r\n\r\nFixed all that in a quick patch and attached it.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=nickmbailey","name":"nickmbailey","emailAddress":"nick at datastax dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Nick Bailey","active":true},"created":"2010-09-27T15:54:58.611+0000","updated":"2010-09-27T15:54:58.611+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12915629","id":"12915629","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gdusbabek","name":"gdusbabek","emailAddress":"gdusbabek at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gdusbabek&avatarId=10070","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gdusbabek&avatarId=10070","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gdusbabek&avatarId=10070","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gdusbabek&avatarId=10070"},"displayName":"Gary Dusbabek","active":true},"body":"committed.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=gdusbabek","name":"gdusbabek","emailAddress":"gdusbabek at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=gdusbabek&avatarId=10070","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=gdusbabek&avatarId=10070","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=gdusbabek&avatarId=10070","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=gdusbabek&avatarId=10070"},"displayName":"Gary Dusbabek","active":true},"created":"2010-09-28T05:56:09.780+0000","updated":"2010-09-28T05:56:09.780+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12467577/comment/12915742","id":"12915742","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hudson","name":"hudson","emailAddress":"jira at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Hudson","active":true},"body":"Integrated in Cassandra #549 (See [https://hudson.apache.org/hudson/job/Cassandra/549/])\r\n    changes update for CASSANDRA-1216\r\nmodify removetoken so that the coordinator relies on replicating nodes for updates. patch by Nick Bailey, reviewed by Gary Dusbabek. CASSANDRA-1216\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hudson","name":"hudson","emailAddress":"jira at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Hudson","active":true},"created":"2010-09-28T13:31:34.162+0000","updated":"2010-09-28T13:31:34.162+0000"}]},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/CASSANDRA-1216/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i0g3pj:"}}