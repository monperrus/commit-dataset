{"expand":"renderedFields,names,schema,transitions,operations,editmeta,changelog","id":"12404477","self":"https://issues.apache.org/jira/rest/api/latest/issue/12404477","key":"DERBY-3880","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/10594","id":"10594","key":"DERBY","name":"Derby","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=10594&avatarId=10122","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=10594&avatarId=10122","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=10594&avatarId=10122","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=10594&avatarId=10122"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10090","id":"10090","description":"DB related projects","name":"DB"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12313143","id":"12313143","description":"Head of 10.3 branch","name":"10.3.3.1","archived":false,"released":false},{"self":"https://issues.apache.org/jira/rest/api/2/version/12313401","id":"12313401","description":"Head of 10.4 branch","name":"10.4.2.1","archived":false,"released":false},{"self":"https://issues.apache.org/jira/rest/api/2/version/12313771","id":"12313771","description":"build: 764942, 14/Apr/09. Voted release: 28/Apr/09. Announced: 1/May/09","name":"10.5.1.1","archived":false,"released":true,"releaseDate":"2009-04-28"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12310220":"2008-09-17 03:34:52.448","customfield_12312322":null,"customfield_12312323":null,"customfield_12310420":"23896","customfield_12310222":"1_*:*_1_*:*_4380362564_*|*_5_*:*_1_*:*_0","customfield_12312320":null,"customfield_12312321":null,"customfield_12312120":null,"customfield_12312121":null,"resolutiondate":"2008-11-06T17:33:31.355+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312326":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312324":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-3880/watchers","watchCount":1,"isWatching":false},"created":"2008-09-17T00:47:28.791+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/4","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/minor.png","name":"Minor","id":"4"},"labels":[],"customfield_12312333":null,"customfield_12312334":null,"customfield_12310310":"3.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12313345","id":"12313345","description":"","name":"10.4.2.0","archived":false,"released":true,"releaseDate":"2008-09-05"}],"customfield_12311120":null,"customfield_12312330":null,"issuelinks":[{"id":"12323847","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12323847","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"outwardIssue":{"id":"12415041","key":"DERBY-4063","self":"https://issues.apache.org/jira/rest/api/2/issue/12415041","fields":{"summary":"Constraint causes wrong query result when using exists","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}},{"id":"12332483","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12332483","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"outwardIssue":{"id":"12466874","key":"DERBY-4698","self":"https://issues.apache.org/jira/rest/api/2/issue/12466874","fields":{"summary":"Simple query with HAVING clause crashes with NullPointerException","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}},{"id":"12321778","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12321778","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"inwardIssue":{"id":"12325311","key":"DERBY-681","self":"https://issues.apache.org/jira/rest/api/2/issue/12325311","fields":{"summary":"Eliminate the parser's rewriting of the abstract syntax tree for queries with GROUP BY and/or HAVING clauses","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/4","id":"4","description":"An improvement or enhancement to an existing feature or task.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/improvement.png","name":"Improvement","subtask":false}}}}],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"customfield_12312337":null,"customfield_12312338":null,"updated":"2011-01-21T17:52:06.965+0000","customfield_12312335":null,"customfield_12311720":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/11408","id":"11408","name":"SQL"}],"timeoriginalestimate":null,"description":"A simple query involving a join and having clause causes a NPE. Any subsequent executions cause severe errors. It almost looks like the underlying connection was closed out.\r\n\r\n====\r\n\r\nC:\\apps\\derby\\db-derby-10.4.2.0-bin\\db-derby-10.4.2.0-bin\\bin>ij\r\nij version 10.4\r\nij> connect 'jdbc:derby://speed:1527/ClassicModels;user=sa;password=sa\r\n';\r\nij> create table t1(i int, c varchar(20));\r\n0 rows inserted/updated/deleted\r\nij> create table t2(i int, c2 varchar(20), i2 int);\r\n0 rows inserted/updated/deleted\r\nij> insert into t1 values(1, 'abc');\r\n1 row inserted/updated/deleted\r\nij> insert into t1 values(2, 'abc');\r\n1 row inserted/updated/deleted\r\nij> insert into t2 values(1, 'xyz', 10);\r\n1 row inserted/updated/deleted\r\nij> insert into t2 values(1, 'aaa', 20);\r\n1 row inserted/updated/deleted\r\nij> insert into t2 values(2, 'xxx', 30);\r\n1 row inserted/updated/deleted\r\nij> select t1.i, avg(t2.i2) from t1 inner join t2 on (t1.i = t2.i) group by t1.i\r\n having avg(t2.i2) > 0;\r\nERROR XJ001: DERBY SQL error: SQLCODE: -1, SQLSTATE: XJ001, SQLERRMC: java.lang.\r\nNullPointerException¶¶XJ001.U\r\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12310200":[{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10420","value":"Regression","id":"10420"}],"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"aggregatetimeestimate":null,"customfield_12312022":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12310921":null,"customfield_12310920":"37269","summary":"NPE on a query with having clause involving a join","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=viyer","name":"viyer","emailAddress":"viyer at actuate dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Venkateswaran Iyer","active":true},"subtasks":[],"customfield_12310090":[{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10422","value":"High Value Fix","id":"10422"}],"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=viyer","name":"viyer","emailAddress":"viyer at actuate dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Venkateswaran Iyer","active":true},"customfield_12310291":null,"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"environment":"Windows 2003 Server ","customfield_12311020":null,"customfield_12310050":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"startAt":0,"maxResults":21,"total":21,"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12631634","id":"12631634","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Can you please provide the complete stack trace? I ran it on trunk, but since my codeline is compiled with Sane=true, I am not running into npe, instead I am getting Assert Failures for a null object.\r\n\r\nERROR XJ001: Java exception: 'ASSERT FAILED col[2]  is null: org.apache.derby.shared.common.sanity.AssertFailure'.\r\njava.sql.SQLException: Java exception: 'ASSERT FAILED col[2]  is null: org.apache.derby.shared.common.sanity.AssertFailure'.\r\n        at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)\r\n        at org.apache.derby.impl.jdbc.Util.newEmbedSQLException(Util.java:87)\r\n        at org.apache.derby.impl.jdbc.Util.javaException(Util.java:244)\r\n        at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException (TransactionResourceImpl.java:403)\r\n        at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:346)\r\n        at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:2192)\r\n        at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:81)\r\n        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1325)\r\n        at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:625)\r\n        at org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:555)\r\n        at org.apache.derby.impl.tools.ij.ij.executeImmediate(ij.java:329)\r\n        at org.apache.derby.impl.tools.ij.utilMain.doCatch(utilMain.java:508)\r\n        at org.apache.derby.impl.tools.ij.utilMain.runScriptGuts(utilMain.java:3\r\n50)\r\n        at org.apache.derby.impl.tools.ij.utilMain.go(utilMain.java:248)\r\n        at org.apache.derby.impl.tools.ij.Main.go(Main.java:215)\r\n        at org.apache.derby.impl.tools.ij.Main.mainCore(Main.java:181)\r\n        at org.apache.derby.impl.tools.ij.Main.main(Main.java:73)\r\n        at org.apache.derby.tools.ij.main(ij.java:59)\r\nCaused by: org.apache.derby.shared.common.sanity.AssertFailure: ASSERT FAILED col[2]  is null\r\n        at org.apache.derby.shared.common.sanity.SanityManager.THROWASSERT(SanityManager.java:162)\r\n        at org.apache.derby.shared.common.sanity.SanityManager.THROWASSERT(SanityManager.java:147)\r\n        at org.apache.derby.impl.store.access.sort.MergeSort.checkColumnTypes(MergeSort.java:458)\r\n        at org.apache.derby.impl.store.access.sort.MergeInserter.insert(MergeInserter.java:98)\r\n        at org.apache.derby.impl.sql.execute.GroupedAggregateResultSet.loadSorter(GroupedAggregateResultSet.java:308)\r\n        at org.apache.derby.impl.sql.execute.GroupedAggregateResultSet.openCore(GroupedAggregateResultSet.java:180)\r\n        at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.openCore(P\r\nrojectRestrictResultSet.java:168)\r\n        at org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.open(BasicNoPutResultSetImpl.java:245)\r\n        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:384)\r\n        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1235)\r\n        ... 10 more","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2008-09-17T03:34:52.448+0000","updated":"2008-09-17T03:34:52.448+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12631857","id":"12631857","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=viyer","name":"viyer","emailAddress":"viyer at actuate dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Venkateswaran Iyer","active":true},"body":"Here's the complete stack:\r\n\r\nApache Derby Network Server - 10.4.2.0 - (689064) started and ready to accept connections on port 1527 at 2008-09-16 20:19:45.296 GMT \r\n----------------------------------------------------------------\r\n2008-09-16 20:26:34.328 GMT:\r\n Booting Derby version The Apache Software Foundation - Apache Derby - 10.4.2.0 - (689064): instance a816c00e-011c-6cd1-8f55-00004e6b54c8\r\non database directory C:\\apps\\derby\\db-derby-10.4.2.0-bin\\db-derby-10.4.2.0-bin\\bin\\ClassicModels  \r\n\r\nDatabase Class Loader started - derby.database.classpath=''\r\n2008-09-16 20:27:53.890 GMT Thread[DRDAConnThread_3,5,main] (XID = 525), (SESSIONID = 8), (DATABASE = ClassicModels), (DRDAID = C0A82DCA.GFE0-4183842832230338175{9}), Cleanup action starting\r\n2008-09-16 20:27:53.890 GMT Thread[DRDAConnThread_3,5,main] (XID = 525), (SESSIONID = 8), (DATABASE = ClassicModels), (DRDAID = C0A82DCA.GFE0-4183842832230338175{9}), Failed Statement is: SELECT \"APP\".\"Orders\".\"orderNumber\", AVG( \"APP\".\"OrderDetails\".\"quantityOrdered\" )\r\nFROM (\"APP\".\"Orders\" INNER JOIN \"APP\".\"OrderDetails\" ON \"APP\".\"Orders\".\"orderNumber\" = \"APP\".\"OrderDetails\".\"orderNumber\" ) \r\nGROUP BY \"APP\".\"Orders\".\"orderNumber\"\r\nHAVING AVG( \"APP\".\"OrderDetails\".\"quantityOrdered\" ) > 0\r\njava.lang.NullPointerException\r\n\tat org.apache.derby.impl.sql.execute.BasicSortObserver.getClone(Unknown Source)\r\n\tat org.apache.derby.impl.sql.execute.BasicSortObserver.insertNonDuplicateKey(Unknown Source)\r\n\tat org.apache.derby.impl.sql.execute.AggregateSortObserver.insertNonDuplicateKey(Unknown Source)\r\n\tat org.apache.derby.impl.store.access.sort.SortBuffer.insert(Unknown Source)\r\n\tat org.apache.derby.impl.store.access.sort.MergeInserter.insert(Unknown Source)\r\n\tat org.apache.derby.impl.sql.execute.GroupedAggregateResultSet.loadSorter(Unknown Source)\r\n\tat org.apache.derby.impl.sql.execute.GroupedAggregateResultSet.openCore(Unknown Source)\r\n\tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.openCore(Unknown Source)\r\n\tat org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.open(Unknown Source)\r\n\tat org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)\r\n\tat org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)\r\n\tat org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)\r\n\tat org.apache.derby.impl.jdbc.EmbedPreparedStatement.execute(Unknown Source)\r\n\tat org.apache.derby.impl.drda.DRDAStatement.execute(Unknown Source)\r\n\tat org.apache.derby.impl.drda.DRDAConnThread.processCommands(Unknown Source)\r\n\tat org.apache.derby.impl.drda.DRDAConnThread.run(Unknown Source)\r\nCleanup action completed","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=viyer","name":"viyer","emailAddress":"viyer at actuate dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Venkateswaran Iyer","active":true},"created":"2008-09-17T17:29:57.544+0000","updated":"2008-09-17T17:29:57.544+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12634204","id":"12634204","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":" This is a regression caused by DERBY-681 (svn revision 516454)","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2008-09-24T17:12:26.187+0000","updated":"2008-09-24T17:12:26.187+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12634206","id":"12634206","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"linking issue to DERBY-681 since it was caused by that issue.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2008-09-24T17:13:55.022+0000","updated":"2008-09-24T17:13:55.022+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12634275","id":"12634275","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"If I use an implicit join:\r\nselect t1.i, avg(t2.i2) from t1, t2 where ( t1.i = t2.i) group by t1.i\r\n having avg(t2.i2) > 0;\r\n\r\nThe query runs.  Can this be used as a workaround?\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2008-09-24T20:22:39.683+0000","updated":"2008-09-24T20:22:39.683+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12634298","id":"12634298","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=viyer","name":"viyer","emailAddress":"viyer at actuate dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Venkateswaran Iyer","active":true},"body":"That should work. Thanks.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=viyer","name":"viyer","emailAddress":"viyer at actuate dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Venkateswaran Iyer","active":true},"created":"2008-09-24T21:13:13.973+0000","updated":"2008-09-24T21:13:13.973+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12639647","id":"12639647","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"I have a question about virtualColumnId's for ResultColumns versus their underlying Expressions.  I am looking in the debugger in ProjectRestrictNode generateMinion where it maps the source columns. At line 1421 we have\r\n\t\tint[] mapArray = resultColumns.mapSourceColumns();\r\n\r\nThe second time we hit this line we get a mapArray:[3, -1, 5, -1, -1, 2, -1].  It seems that it is mapArray[2] that is off.\r\nThe virtualColumnId of the the third entry of resultColumns is 3 and if I force mapArray[2] to be 3 the query completes successfully and correctly.  The ResultColumn is an ##aggregate expression\r\name: ##aggregate expression\r\ntableName: T2\r\nisNameGenerated: false\r\nsourceTableName: T2\r\ntype: INTEGER\r\ncolumnDescriptor: null\r\nisGenerated: true\r\nisGeneratedForUnmatchedColumnInInsert: false\r\nisGroupingColumn: false\r\nisReferenced: true\r\nisRedundant: false\r\nvirtualColumnId: 3\r\nresultSetNumber: -1\r\ndataTypeServices: INTEGER\r\n\r\nThe expression is a ColumnReference with sourceColumn virtualColumId 5\r\ncolumnName: I2\r\ntableNumber: 1\r\ncolumnNumber: 3\r\nreplacesAggregate: false\r\ntableName: T2\r\nnestingLevel: 0\r\nsourceLevel: 0\r\ndataTypeServices: null\r\n\r\nmapSourceColumns() gets the virtualColumnId using\r\n\tVirtualColumnNode vcn = (VirtualColumnNode) resultColumn.getExpression();\r\n        ....\r\n        mapArray[index] = vcn.getSourceColumn().getVirtualColumnId();\r\nso returns 5 in this case.\r\n\r\nSo my question is what is the relationship between the ResultColumn and the source column in this case?  Is it likely that the correct thing to do for an aggregate is return the virtualColumnId of the the ResultColumn for the aggregate or was that just a coincidence in this case?\r\n\r\n\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2008-10-14T23:49:45.772+0000","updated":"2008-10-14T23:57:45.186+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12640312","id":"12640312","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"I printed out the query trees for the working query versus the failing query.  The failing query uses a JoinNode and passes through the code in JoinNode.buildRCL() \r\n\ttmpRCL.adjustVirtualColumnIds(resultColumns.size());\r\n\r\nI noticed that if I remove this adjustment the query works, but it of course causes other problems with other queries, but perhaps there is something wrong with the VirtualColumnId adjustment.\r\n\r\nThe working query doesn't use a JoinNode and so does not pass through this code and as best I can tell does not do the same adjustment elsewhere.  I don't know if any of this is helpful but I thought I would mention it.\r\n\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2008-10-16T20:58:36.514+0000","updated":"2008-10-16T20:58:36.514+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12640574","id":"12640574","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Kathey, thanks for providing the working version of the query (ie the one without the explicit inner join clause). It gives something to compare the failing query against.\r\n\r\nWhile trying to trace through the 2 queries, I found following discripency.\r\n\r\nBoth successful query and the NPE query fo through the following code path\r\nThread [main] (Suspended)\t\r\n\tProjectRestrictResultSet.doProjection(ExecRow) line: 514\t\r\n\tProjectRestrictResultSet.getNextRowCore() line: 291\t\r\n\tGroupedAggregateResultSet.getRowFromResultSet() line: 580\t\r\n\tGroupedAggregateResultSet.getNextRowFromRS() line: 566\t\r\n\tGroupedAggregateResultSet.loadSorter() line: 306\t\r\n\tGroupedAggregateResultSet.openCore() line: 180\t\r\n\tProjectRestrictResultSet.openCore() line: 168\t\r\n\tProjectRestrictResultSet(BasicNoPutResultSetImpl).open() line: 245\t\r\n\tGenericPreparedStatement.execute(Activation, boolean, long) line: 384\t\r\n\tEmbedStatement40(EmbedStatement).executeStatement(Activation, boolean, boolean) line: 1235\t\r\n\tEmbedStatement40(EmbedStatement).execute(String, boolean, boolean, int, int[], String[]) line: 625\t\r\n\tEmbedStatement40(EmbedStatement).execute(String) line: 555\t\r\n\tij.executeImmediate(String) line: 329\t\r\n\tMain.go(LocalizedInput, LocalizedOutput, Properties) line: 215\t\r\n\tutilMain.runScriptGuts() line: 350\t\r\n\tMain.main(String[]) line: 73\t\r\n\tutilMain.go(LocalizedInput[], LocalizedOutput, Properties) line: 248\t\r\n\tMain.mainCore(String[], Main) line: 181\t\r\n\tMain.main(String[]) line: 73\t\r\n\tij.main(String[]) line: 59\t\r\n\r\nBut if you examin row that results after the projection in ProjectRestrictResultSet, you will notice that the successful query has following row\r\nresult\tValueRow  (id=212)\t\r\n{ 1, NULL, 10, NULL, NULL, 10, NULL }\r\nwhereas NPE query has following row\r\nresult\tValueRow  (id=251)\t\r\n{ 1, NULL, null, NULL, NULL, 10, NULL }\t\r\n\r\nAs you can see, the 3rd column has value of null in NPE query whereas the successful query has value 10. Will debug more to see what causes this but thought will post this piece of information.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2008-10-17T16:55:31.419+0000","updated":"2008-10-17T16:55:31.419+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12641062","id":"12641062","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Thanks Mamta for looking at this. I think the reason for the difference is that sourceRow has only 3 columns yet projectMapping has values  [3, -1, 5, -1, -1, 2, -1], the third entry (5) does not refer to an actual column so when we get to \r\n\tresult.setColumn(index + 1, sourceRow.getColumn(projectMapping[index]));\r\n\r\nWe call ValueRow.getColumn()  which is defined as:\r\n\tpublic DataValueDescriptor\tgetColumn (int position) {\r\n\t\tif (position <= column.length)\r\n\t\t\treturn column[position-1];\r\n\t\telse\r\n\t\t\treturn (DataValueDescriptor)null;\r\n\t}\r\n\r\nand return null because position is greater than column.length.\r\n\r\nI found that projectMapping is originally generated in projectRestrictNode.generateMinion() when we call \r\n\tint[] mapArray = resultColumns.mapSourceColumns();\r\n\r\nResultColumnList. mapSourceColumns for the column in question  executes this code:\r\nelse if (resultColumn.getExpression() instanceof ColumnReference)\r\n\t\t\t{\r\n\t\t\t\tColumnReference cr = (ColumnReference) resultColumn.getExpression();\r\n                                .....\r\n\t\t\t\t\t// Virtual column #s are 1-based\r\n\t\t\t\t\tmapArray[index] = cr.getSource().getVirtualColumnId();\r\n\t\t\t}\r\n\r\n\r\nWhere the resultColumn looks like:\r\n\tResultColumn  (id=72)\t\r\n\texposedName\t\"##aggregate expression\"\t\r\n\tvirtualColumnId\t3\t\r\n\texpression\tColumnReference  (id=74)\t\r\n\t\tcolumnName\t\"I2\"\t\r\n\t\tsource\tResultColumn  (id=76)\t\r\n\t\t\texposedName\t\"I2\"\t\r\n\t\t\tvirtualColumnId\t5\t\r\n\t\t\texpression\tVirtualColumnNode  (id=94)\t\r\n\t\t\t\tsourceColumn\tResultColumn  (id=100)\t\r\n\t\t\t\t\texposedName\t\"I2\"\t\r\n\t\t\t\t\tvirtualColumnId\t2\t\r\n\t\t\t\t\texpression\tVirtualColumnNode  (id=102)\t\r\n\t\t\t\t\t\tsourceColumn\tResultColumn  (id=214)\t\r\n\t\t\t\t\t\t\texpression\tVirtualColumnNode  (id=227)\t\r\n\t\t\t\t\t\t\tvirtualColumnId\t2\t\r\n\t\t\t\t\t\t\t\tsourceColumn\tResultColumn  (id=239)\t\r\n\t\t\t\t\t\t\t\t\texposedName\t\"I2\"\t\r\n\t\t\t\t\t\t\t\t\texpression\tBaseColumnNode  (id=251)\t\r\n\t\t\t\t\t\t\t\t\t\tcolumnName\t\"I2\"\t\r\n\t\t\t\t\t\t\t\t\t\tvirtualColumnId\t2\t\r\n\r\n\r\nThe virtualColumnId of the ColumnReference under the ##aggregate expression is *5*, yet there are more deeply nested VirtualColumnNode's with a virtualColumnId of 2 which I think is correct.  I think I need to better understand mapSourceColumns()  and the meaning of this deeply nested ResultColumn structure to understand what's right here.\r\n\r\nKathey\r\n\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2008-10-20T16:39:14.696+0000","updated":"2008-10-20T16:39:14.696+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12641067","id":"12641067","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Weill it looks like the indentation for my ResultColumn summary did not show up in the comment so I am attaching a file AggregateExpressionResultColumn.txt","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2008-10-20T16:50:10.339+0000","updated":"2008-10-20T16:50:10.339+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12642202","id":"12642202","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"Thanks for your work on this, Kathey.\r\n\r\nI spent some time looking at this, and there definitely seems to be something amiss with the virtual column ids for the aggregates, but I wasn't able to figure out what it is that's off.\r\n\r\nYou may want to try running two queries that are as similar as possible, where one passes and the other fails, and then try to figure out what it is that's different between the two compilation paths. The ones I've been using are:\r\n\r\n-- Passes.\r\nselect t1.i, avg(t2.i2)\r\n  from t1 inner join t2 on (t1.i = t2.i)\r\n  group by t1.i having avg(t2.i) > 0;\r\n\r\n-- Fails.\r\nselect t1.i, avg(t2.i)\r\n  from t1 inner join t2 on (t1.i = t2.i)\r\n  group by t1.i having avg(t2.i) > 0;\r\n\r\nThe only difference between the two is the column that is referenced in the avg for the SELECT (t2.i2 vs t2.i).  That said, I just now also noticed the following:\r\n\r\n-- Passes.\r\nselect t1.i, avg(t2.i2)\r\n  from t1 inner join t2 on (t1.i = t2.i)\r\n  group by t1.i having avg(t2.i) > 0;\r\n\r\n-- Passes.\r\nselect t1.i, avg(t2.i2)\r\n  from t1 inner join t2 on (t1.i = t2.i)\r\n  group by t1.i having max(t2.i) > 0;\r\n\r\n-- Fails.\r\nselect t1.i, avg(t2.i2)\r\n  from t1 inner join t2 on (t1.i = t2.i)\r\n  group by t1.i having avg(t2.i2) > 0;\r\n\r\n-- Fails.\r\nselect t1.i, avg(t2.i2)\r\n  from t1 inner join t2 on (t1.i = t2.i)\r\n  group by t1.i having min(t2.i2) > 0;\r\n\r\nFrom these tiny examples, it *seems* that if the aggregate in the SELECT list references the same column as the aggregate in the HAVING clause, then the query fails; if they reference *different* columns, the query passes.\r\n\r\nThat might be something to investigate further?  Without having looked at all into it (I only just now realized the apparent correlation), I think the \"SubstituteExpressionVisitor\" that is used by GroupByNode relies in some way on \"equivalent\" expressions, and then it plugs VirtualColumnNodes into the tree based on that equivalency.  I wonder if  the fact that the SELECT clause and the HAVING clause are have \"equivalent\" column references is somehow messing the virtual column ids up somewhere...?  It's pure speculation, but if you're looking for options, that might be one to pursue...","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2008-10-23T17:05:51.646+0000","updated":"2008-10-23T17:05:51.646+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12642243","id":"12642243","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"Army's observation about the SubstituteExpressionVisitor made me remember\r\nthe discussion in DERBY-3094. It may not be directly related, but there is some\r\ndetailed discussion in the comments to that issue regarding various paths\r\nthrough the code in question, which might be useful. So I thought I'd mention it.\r\n\r\nPlus, although I have no reason to think this would be true, it might be interesting\r\nto try backing out the changes for DERBY-3094 and see if that had any affect\r\non either the repro script or on the various test cases that Army mentions.\r\n\r\nHopefully this is just a red herring, and we don't have to drag all the complexity\r\nof DERBY-3094 into this issue but hopefully it's also helpful for people working\r\non this issue to be aware of that history.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2008-10-23T19:33:30.666+0000","updated":"2008-10-23T19:33:30.666+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12643316","id":"12643316","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Thanks Army and Brian for looking at this pesky issue. With regard to DERBY-3094, thank you for the write up. It was indeed most informative.  As you suggested I backed out the change for DERBY-3094 and found no appreciable difference in the behaviour of the queries in question in this issue.\r\n\r\n\r\nI looked at the SubstituteExpressionVisitor logic and don't think it is related. The result column in question is the one created in AggregateNode.java with the code\r\nnode = (operand == null) ?\r\n\t\t\tthis.getNewNullResultExpression() :\r\n\t\t\toperand;\r\n\r\n\t\treturn (ResultColumn) getNodeFactory().getNode(\r\n\t\t\t\t\t\t\t\tC_NodeTypes.RESULT_COLUMN,\r\n\t\t\t\t\t\t\t\t\"##aggregate expression\",\r\n\t\t\t\t\t\t\t\tnode,\r\n\t\t\t\t\t\t\t\tgetContextManager());\r\n\t}\r\n\r\nwhere it is the operand being wrapped. I do not think this column is traversed with the SubstituteExpressionVisitor.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2008-10-28T19:34:03.157+0000","updated":"2008-10-28T19:34:03.157+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12644199","id":"12644199","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"I looked a bit more at this issue and I think I've discovered at least part of the problem.  A query like:\r\n\r\n  select t1.i, avg(t2.i)\r\n    from t1 inner join t2 on (t1.i = t2.i)\r\n    group by t1.i having avg(t2.i) > 0;\r\n\r\nhas two aggregates in it, which means the compile time query tree has two AggregateNodes, each of which has an \"operand\" that is a column reference.  The result column to which the operand points is determined at bind time, and in this case the result column \"t2.i\" points to a bind-time JoinNode.  The JoinNode's bind-time result column list is simply a concatenation of the result column lists from its operands.  In our example, the query specifies T1 followed by T2, so the JoinNode's bind-time RCL is: { T1.i, T1.c, T2.i, T2.c2, T2.i2 }.  Notice how, with respect to this list, the position of \"t2.i\" is \"3\".  So when we bind the AggregateNodes, each of them ends up with an operand that is a ColumnReference which points to the \"t2.i\" column of the bind-time JoinNode, which in turn has virtual column id of \"3\".\r\n\r\nAfter binding is complete we start optimization, the first phase of which is preprocessing.  As part of SelectNode preprocessing we look at the FromList to see if there are any JoinNodes that can be flattened.  In the above query the JoinNode *can* be flattened, which means it effectively disappears.  That in turn means that any result columns in the SELECT list have to be updated to reflect the fact that they no longer point to the JoinNode; instead, they point directly to the underlying base tables.  The process of flattening the JoinNode and updating the SelectNode's result column list begins with the following call in SelectNode.preprocess():\r\n\r\n    // Flatten any flattenable FromSubquerys or JoinNodes\r\n    fromList.flattenFromTables(resultColumns, \r\n        wherePredicates, \r\n        whereSubquerys,\r\n      groupByList);\r\n\r\nNotice how we pass the SelectNode's RCL into the flattenFromTables method, but we do *not* pass the HAVING clause.  Long story short, the AggregateNode in the SelectNode's RCL is properly updated to reflect the removal of the JoinNode--but the AggregateNode in the HAVING clause continues to point to a result column from the now-useless JoinNode.  The *real* column to which the Aggregate should be pointing is actually buried *beneath* the JoinNode's ResultColumn, so the aggregate's operand should have been remapped to point to the buried column. (And indeed, that's exactly what happens with the aggregate in the SelectNode's RCL.)\r\n\r\nWhen optimization is done and we modify the tree, result columns are updated to reflect the final join order and also to remove any un-referenced columns.  But since the HAVING aggregate node is still pointing to the unused JoinNode result column, it doesn't see any changes--it continues to point to a ResultColumn that has a virtual column id of \"3\" and which points to a JoinNode that is no longer valid.\r\n\r\nThe final query plan inclues a *new* JoinNode between T1 and T2, and that JoinNode's RCL only contains columns which are referenced in the query.  Thus the execution-time JoinNode result column list is, for the above query, { T1.i, T2.i }.  Note how it only has TWO columns in it, not five like the bind-time JoinNode.  So when it comes time to execute the query, the aggregate in the having clause ends up pointing to column \"3\" of the new JoinNode's RCL, and since that doesn't exist, the column value is set to null (as Kathey noted in earlier comments).  Attempts to reference that column for GROUP BY sorting, then, result in the NPE.\r\n\r\nThe reason the same query works if the two aggregates reference two _different_ columns in T2 has nothing to do with equivalence--that was a red herring, sorry for the miscue.  The reason the query passes appears to have something to do with referenced columns--esp. the SelectNode (which includes the Select RCL and the Having clause) then references TWO columns from T2 plus ONE column from T1, leading to THREE columns in the execution JoinNode's RCL: { T1.i, T2.i, T2.i2 }.  So now the RCL has three columns instead of two, which means the result column in the HAVING aggregate, which still has the INCORRECT virtual id of \"3\", accidentally points to a valid column, and thus the query passes--but that was just chance, the code is still technically wrong.\r\n\r\nThis also explains why the original query passes if the user does NOT specify \"inner join\".  The inclusion of \"inner join\" leads to the creation of the bind-time JoinNode between T1 and T2, against which the aggregates are then bound.  In preprocessing we realize the JoinNode is useless so we flatten it out of the query, and that causes the aforementioned problem.  But if the query does not have \"inner join\", the bind-time JoinNode is never created, which means both aggregate nodes already point directly to the underlying base tables.  Throughout optimization and query generation the base table result columns are properly updated, which means both aggregates end up pointing to the correct place, and all is well.\r\n\r\nSo all of that said, I think the fix for this problem is to somehow ensure that the HAVING clause's AggregateNode is correctly remapped when/if necessary, esp. if it points to a JoinNode that has been flattened out.  I happened to notice that, when the JoinNode is flattened, all of its result columns are marked as \"redundant\" as part of the flattening process (see JoinNode.flatten()).  So the quick (and possibly NOT complete) fix that I found was to add an \"if\" statement to the getNewExpressionResultColumn() method of AggregateNode.java.  That method is called as part of \"modification of access paths\"--i.e. after optimization has completed--and is used for creating the result column that will ultimately be used for aggregate input at execution time.  I found that if I added logic to remap the Aggregate's operand (if it's a column reference), then the posted query starts running without error:\r\n\r\nIndex: java/engine/org/apache/derby/impl/sql/compile/AggregateNode.java\r\n===================================================================\r\n--- java/engine/org/apache/derby/impl/sql/compile/AggregateNode.java    (revision 707244)\r\n+++ java/engine/org/apache/derby/impl/sql/compile/AggregateNode.java    (working copy)\r\n@@ -539,6 +539,26 @@\r\n                        this.getNewNullResultExpression() :\r\n                        operand;\r\n\r\n +        /* The operand for this aggregate node was initialized at bind\r\n +         * time.  Between then and now it's possible that certain changes\r\n +         * have been made to the query tree which affect this operand. In\r\n +         * particular, if the operand was pointing to a result column in\r\n +         * a JoinNode and then that JoinNode was flattened during pre-\r\n +         * processing, all of the references to that JoinNode--including\r\n +         * this aggregate's operand--need to be updated to reflect the\r\n +         * fact that the Join Node no longer exists.  So check to see if\r\n +         * the operand is a column reference, and if so, make a call to\r\n +         * remap it to its underlying expression.  If nothing has happened\r\n +         * then this will be a no-op; but if something has changed to void\r\n +         * out the result column to which the operand points, the result\r\n +         * column will be marked \"redundant\" and the following call should\r\n +         * remap as appropriate. DERBY-3880.\r\n +         */\r\n +        if (operand instanceof ColumnReference)\r\n +        {\r\n +            ((ColumnReference)operand).remapColumnReferencesToExpressions();\r\n +        }\r\n +\r\n            return (ResultColumn) getNodeFactory().getNode(\r\n                                                                C_NodeTypes.RESULT_COLUMN,\r\n                                                                \"##aggregate expression\",\r\n\r\nI didn't run any other tests, and I admit that this change may not be sufficient (or it may be too general), but it does cause the reported query to run without error, so at the very least it demonstrates the problem.  There could very well be a better way to fix it...","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2008-10-31T03:16:12.859+0000","updated":"2008-10-31T03:16:12.859+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12644393","id":"12644393","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Thanks Army for the great explanation and patch proposal.  I'll give it a try.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2008-10-31T18:40:32.682+0000","updated":"2008-10-31T18:40:32.682+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12644992","id":"12644992","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Army's patch passes regression tests.  I'll add a test and commit, then backport to 10.4 and 10.3. Thanks Army!\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2008-11-04T16:35:45.317+0000","updated":"2008-11-04T16:35:45.317+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12645520","id":"12645520","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"The fix has been committed to trunk, 10.4 and 10.3.  Giving Army the point since he came up with the fix.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2008-11-06T17:33:31.188+0000","updated":"2008-11-06T17:33:31.188+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12646605","id":"12646605","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"Hi Army, Kathey, sorry it took me a while to read through Army's excellent description of 30-Oct\r\n\r\nI have a couple questions that came to mind while I was studying Army's notes:\r\n\r\n1) Army says  \"so the JoinNode's bind-time RCL is: { T1.i, T1.c, T2.i, T2.c2, T2.i2 }\" but I don't\r\nsee how that is, if the query is \r\n\r\n      select t1.i, avg(t2.i)\r\n          from t1 inner join t2 on (t1.i = t2.i)\r\n          group by t1.i having avg(t2.i) > 0; \r\n\r\nIs it possible that the query Army was analyzing was actually \"on (t1.c = t2.c2)\" ? Otherwise,\r\nI'm having trouble seeing why T1.c and T2.c2 are in the join node's RCL. \r\n\r\n2) While I was reading Army's writeup, I anticipated that I was going to see a fix which\r\ninvolved passing the HAVING clause expressions to fromList.flattenFromTables() so that\r\nit could properly maintain the ColumnReference data in the HAVING clause during flattening. \r\n\r\nBut it seems like the essence of Army's fix is to observe that we don't need to maintain\r\nthe ColumnReference instances inside of AggregateNode instances because we can\r\nalways go back at the end of optimization and re-construct the ColumnReference info.\r\n\r\nThis seems very nice, because I've seen numerous problems over the past several\r\nyears which involved situations where we lost track of the ColumnReference's table\r\nand column pointers during the compilation and optimization processing. That code\r\noverall seems very tricky and trouble-prone. I could track down the actual JIRA id's\r\nif you wish; they involved GROUP BY and ORDER BY analysis, which is similar, but\r\ncertainly not identical, to HAVING clause analysis.\r\n\r\nSo now I'm wondering: if it's true that we can figure out the proper ColumnReference\r\ninformation at the *end* of the optimization process, and don't have to maintain\r\nthat data during the compilation/optimzation process, then perhaps we shouldn't be\r\ndoing it at all, but rather should simply wait til optimization is complete, then fix-up all\r\nthe ColumnReferences in the tree at the end.\r\n\r\nThat is, if it's safe to allow the ColumnReference in the aggregate of a HAVING clause\r\nto \"decay\" (become in-accurate) during optimization, and then fix it up at the end,\r\nwhy do we have to re-map the ColumnReference information for the SELECT's RCL?\r\n\r\nAnd similarly could we avoid having to \"fix-up\" the GROUP BY and ORDER BY clauses?\r\n\r\nOr is it only safe to allow HAVING clause ColumnReference instances to diverge\r\nfrom reality for short periods, because they are fundamentally different from the\r\naggregate nodes in the select RCL?\r\n\r\n3) Army says \"the compile time query tree has two AggregateNodes\". I've noticed\r\nthis myself. In fact, while looking at somewhat similar situations, I've noticed that\r\n(I think) the actual code that is generated to execute the query may contain\r\nmultiple computations of the same expressions. That is, when this query runs,\r\nis it true that we are actually going to *compute* AVG(t2.i) twice? We'll only do\r\none pass over the data, of course, but we'll have two running-total values that\r\nare redundantly accumulating the t2.i sub-totals as we go?\r\n\r\nI've been wondering if maybe there is some sort of fundamental \"common sub-expression\r\ndetection\" which the Derby compilation system is not performing, such that it\r\ndoesn't recognize when two parts of a query are actually computing the same\r\nresult, and so we end up generating a query which performs more computation\r\nthan is needed, redundantly computing values multiple times in situations where\r\nthey are mentioned multiple times.\r\n\r\nI noticed this in studying GROUP BY queries, where if the GROUP BY clause\r\ncontained an expression, and that expression matched a similar expression\r\nin the SELECT list, the resulting query seemed to compute the expression twice,\r\nwhen it would have been adequate to compute it only once.\r\n\r\nI'm not intending to \"hijack the thread\" with any of these questions; I'm extremely\r\nhappy that we've solved this problem and that the query now runs correctly.\r\nI'm just trying to improve my understanding of Derby internals by taking this\r\nopportunity to ask a few questions about parts of this issue that puzzled me.\r\n\r\nThanks VERY much to Army and Kathey for all the hard work they did on this problem!\r\n\r\n  ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2008-11-11T17:19:07.803+0000","updated":"2008-11-11T17:19:07.803+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12646775","id":"12646775","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"Hi Bryan,\r\n\r\nThanks for your interest in this issue.\r\n\r\n> Army says \"so the JoinNode's bind-time RCL is: { T1.i, T1.c, T2.i, T2.c2, T2.i2 }\" but I don't\r\n> see how that is [...] I'm having trouble seeing why T1.c and T2.c2 are in the join node's RCL.\r\n\r\nI think the key observation here is in the sentence immediately preceding the one that you quoted, namely:\r\n\r\n  The JoinNode's bind-time result column list is simply a concatenation of the result column\r\n  lists from its operands.\r\n\r\nDue to the specification of \"inner join\" the parser will create a parse-time JoinNode whose left operand is a FromBaseTable representing T1 and whose right operand is a FromBaseTable representing T2.  Note how neither operand has a ProjectRestrictNode above it, which in turn means we will *not* project out any columns (at this point).  Thus the FromBaseTable for T1 has an RCL with *ALL* of T1's columns in it, and the FromBaseTable for T2 has an RCL with *ALL* of T2's columns in it.  The fact that some columns are never referenced in the query has no effect on the RCLs for the FromBaseTables at this point in binding.\r\n\r\nTo verify, you can put a breakpoint in JoinNode.buildRCL() and, when the breakpoint hits, look at the leftOperand and rightOperand.  They will both be FromBaseTables and the RCLs will have all columns that exist in the underlying base tables.  So the JoinNode's RCL then becomes a concatenation of all columns from T1 and all columns from T2, hence { T1.i, T1.c, T2.i, T2.c2, T2.i2 }--even though T1.c and T2.c2 are never referenced in the query.\r\n\r\n> I anticipated that I was going to see a fix which involved passing the HAVING clause\r\n> expressions to fromList.flattenFromTables() so that it could properly maintain the\r\n> ColumnReference data in the HAVING clause during flattening. \r\n\r\nTo be honest, I think you're absolutely right: that seems like a more robust approach to the problem.  See below...\r\n\r\n> if it's safe to allow the ColumnReference in the aggregate of a HAVING clause\r\n> to \"decay\" (become in-accurate) during optimization, and then fix it up at the end,\r\n> why do we have to re-map the ColumnReference information for the SELECT's\r\n> RCL?\r\n\r\nGood question.  I do not think it is generally safe to assume that a temporarily inaccurate ColumnReference is going to be okay.  The vast majority of the ColumnReference remapping that occurs during optimization happens in order to support the pushing of predicates down the tree and/or to allow the insertion of query tree nodes into an existing tree.  In both cases the column reference is being remapped from one valid ResultColumn to another valid ResultColumn.  In other words, we can't just look at the ColumnReference after optimization has finished and say \"pick the only one that's valid\", because there could be an arbitrarily long chain of ResultColumns, VirtualColumnNodes, and ColumnReferences, all of which are valid and referenceable by different parts of the query tree.  The only way to know which one is the \"right\" one for a given ColumnReference is to remap (or un-remap) in \"real time\"--ex. when we push/pull a predicate, we have to remap its column reference as part of the push/pull.\r\n\r\nThat said, the fact that a post-optimization remapping of the HAVING aggregate's ColumnReference corrected the problem was a pleasant surprise to me, as I too was more inclined to believe that, by then, it would be too late.  But I made the change, saw that it made sense and that it fixed the immediate problem, and that's what I posted.  Having done so, I think it's worth it to echo the final few sentences from that same comment, namely:\r\n\r\n  I admit that this change may not be sufficient (or it may be too general), but it does\r\n  cause the reported query to run without error, so at the very least it demonstrates\r\n  the problem. There could very well be a better way to fix it...\r\n\r\nI posted a quick fix to demonstrate the problem and stopped there.  Kathey was kind enough to pick it up and take it to completion.  But at a higher level, I think you're right: there's probably a better (and safer) way to fix this bug, and your suggestion that such a fix would involve passing the HAVING clause expressions to fromList.flattenFromTables() seems like a good one to me...\r\n\r\n> I've noticed that (I think) the actual code that is generated to execute the query may\r\n> contain multiple computations of the same expressions. That is, when this query\r\n> runs, is it true that we are actually going to *compute* AVG(t2.i) twice?\r\n\r\nI have not looked at this in any detail, but I believe the answer is \"Yes\", at least based on the tracing I was doing when I was trying to track down the cause of this issue.  But I wasn't specifically investigating that particular behavior at the time, so it's possible I missed something...","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2008-11-12T01:47:39.988+0000","updated":"2008-11-12T01:47:39.988+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404477/comment/12646804","id":"12646804","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"Thanks Army!\r\n\r\nI had overlooked your explanation about the construction of the JoinNode RCL; thanks\r\nfor the clarification. I worked through JoinNode.buildRCL and I see exactly what you mean:\r\n\r\n                /* Now we append the propagated RCL from the right to the one from\r\n                 * the left and call it our own.\r\n                 */\r\n                resultColumns.nondestructiveAppend(tmpRCL);\r\n\r\nIt seems like it would be worth following up some more on the other topics; I'll see about\r\nfiling them as separate JIRA issues so we can pursue them down the line.\r\n\r\nThanks again not only for the fix, but even better for helping me understand how it works.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2008-11-12T05:22:48.754+0000","updated":"2008-11-12T05:22:48.754+0000"}]},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-3880/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i06qrb:"}}