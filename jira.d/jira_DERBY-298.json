{"expand":"renderedFields,names,schema,transitions,operations,editmeta,changelog","id":"32702","self":"https://issues.apache.org/jira/rest/api/latest/issue/32702","key":"DERBY-298","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/10594","id":"10594","key":"DERBY","name":"Derby","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=10594&avatarId=10122","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=10594&avatarId=10122","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=10594&avatarId=10122","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=10594&avatarId=10122"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10090","id":"10090","description":"DB related projects","name":"DB"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12311953","id":"12311953","description":"","name":"10.1.3.1","archived":false,"released":true,"releaseDate":"2006-06-30"},{"self":"https://issues.apache.org/jira/rest/api/2/version/11187","id":"11187","description":"","name":"10.2.1.6","archived":false,"released":true,"releaseDate":"2006-10-02"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12310220":"2005-05-24 22:50:51.0","customfield_12312322":null,"customfield_12312323":null,"customfield_12310420":"21879","customfield_12310222":"3_*:*_1_*:*_19968955000_*|*_1_*:*_1_*:*_472522000_*|*_6_*:*_1_*:*_0_*|*_5_*:*_1_*:*_37509160109","customfield_12312320":null,"customfield_12312321":null,"customfield_12312120":null,"customfield_12312121":null,"resolutiondate":"2006-01-10T18:41:19.000+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312326":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312324":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-298/watchers","watchCount":0,"isWatching":false},"created":"2005-05-19T04:30:02.000+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/4","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/minor.png","name":"Minor","id":"4"},"labels":[],"customfield_12312333":null,"customfield_12312334":null,"customfield_12310310":"3.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/10991","id":"10991","description":"snapshot","name":"10.0.2.1","archived":false,"released":true,"releaseDate":"2004-12-06"}],"customfield_12311120":null,"customfield_12312330":null,"issuelinks":[],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"customfield_12312337":null,"customfield_12312338":null,"updated":"2007-03-20T21:53:59.107+0000","customfield_12312335":null,"customfield_12311720":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/11412","id":"11412","name":"Store"}],"timeoriginalestimate":null,"description":"If the system crashes after a rollforward backup; last log file \nis empty(say log2.dat). On next crash-recovery system ignores the  empty log \nfile and starts writing to the previous log(say log1.dat),  \neven thought there was successfule log file switch  before the crash.\nThe reason I belive it is done this way to avoid special \nhandling of crashes  during the log switch process. \n\nProblem is  on rollfroward restore from a backup log1.dat will get overwritten \nfrom the copy in the backup, so any transaction that got added to log1.dat\nafter the backup was taken will be lost. \n \nOne possible solution that comes to my mind to solve this problem is \n 1) check if an  empty a log file exist after a redo crash-recovery , if \n     the log archive mode is enabled.\n 2) If it exists , delete and do log file switch again \n\n \nRepro:\nconnect 'jdbc:derby:wombat;create=true';\ncreate table t1(a int ) ;\ninsert into t1 values(1) ;\ninsert into t1 values(2) ;\ncall SYSCS_UTIL.SYSCS_BACKUP_DATABASE_AND_ENABLE_LOG_ARCHIVE_MODE(\n    'extinout/mybackup', 0);\n\n--crash (NO LOG RECORDS WENT IN AFTER THE BACKUP).\n\nconnect 'jdbc:derby:wombat';\ninsert into t1 select a*2 from t1 ;\ninsert into t1 select a*2 from t1 ;\ninsert into t1 select a*2 from t1 ;\ninsert into t1 select a*2 from t1 ;\ninsert into t1 select a*2 from t1 ;\ninsert into t1 select a*2 from t1 ;\ninsert into t1 select a*2 from t1 ;\nselect count(*) from t1 ;\n\n--exit from jvm and restore from backup\n\nconnect\n'jdbc:derby:wombat;rollForwardRecoveryFrom=extinout/mybackup/wombat';\nselect count(*) from t1 ;  -- THIS WILL GIVE INCORRECT VALUES","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12310200":null,"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"aggregatetimeestimate":null,"customfield_12312022":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12310921":null,"customfield_12310920":"40135","summary":"rollforward will not work correctly  if the system happens to crash immediately after rollforward backup.","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tsuresh","name":"tsuresh","emailAddress":"suresh dot thalamati at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Suresh Thalamati","active":true},"subtasks":[],"customfield_12310090":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tsuresh","name":"tsuresh","emailAddress":"suresh dot thalamati at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Suresh Thalamati","active":true},"customfield_12310291":null,"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"environment":null,"customfield_12311020":null,"customfield_12310050":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"startAt":0,"maxResults":12,"total":12,"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/32702/comment/66168","id":"66168","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"body":"Looking at the code, I became a bit confused about the definition of an empty log file.   Scan.getNextRecordForward contains debug output when it detects an empty log file.  It will then return without setting knownGoodLogEnd.  Hence, new log records will be written to the end of the previous file.  As Suresh says this is probably to be able to handle crashes during log switch.\r\n\r\nHowever, this is not what happens when I run the recovery part of the example in this report.  Since, currentLogFileLength is a large number, it detects \"zapped log end on log file\", goes on to the next file, which does not exist, and returns.  (Who sets the length of a log file?  Is this maximum size until a log switch is performed?)  The effect is the same, but this can not be used to detect an empty log file and apply the solution proposed by Suresh.  Instead, one would have to do some hairy file handling at a later stage.\r\n\r\nAn alternative way to fix this would be to just create a dummy log record in the new log file as part of the backup command.  This would make the redo scan end in the new log file.  However, this will not work for those who do backup with OS-commands (i.e., copy the files directly).\r\n\r\nI would also think it should be possible to do the log switch in such a way that it is possible to detect during recovery whether the log switch had completed or not.  If this was the case, one could just set knownGoodLogEnd of the redo scan to the start of the empty file if the log switch was completed.  Does anyone know if this is possible?\r\n\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"created":"2005-05-24T22:50:51.000+0000","updated":"2005-05-24T22:50:51.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/32702/comment/66209","id":"66209","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"body":"On second thoughts, recovery after an OS-command backup is not an issue since the database will be shut down when the backup is  performed.  So, why not insert a \"dummy\" record in the new log file when doing backup?  Then, no changes would be needed to the recovery mechanism.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"created":"2005-05-25T07:15:08.000+0000","updated":"2005-05-25T07:15:08.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/32702/comment/12313185","id":"12313185","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"body":"This is further discussed in the following thread: http://thread.gmane.org/gmane.comp.apache.db.derby.devel/4170\r\n\r\nMy current view is that as long as the header it valid, it should be safe to use a new empty log file after recovery.  Unless someone protests, I will change the recovery code to accept the newest log file even if its empty.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"created":"2005-06-10T04:33:07.000+0000","updated":"2005-06-10T04:33:07.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/32702/comment/12314995","id":"12314995","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"body":"The attached patch fixes the bug by setting the logEnd after recovery to the beginning of the new empty log file instead of the end of the previous file. \r\nThe patch contains changes to the following files:\r\n\r\nM      java/engine/org/apache/derby/impl/store/raw/log/FileLogger.java\r\n        - At the end of the redo scan, if the scan stopped in a file succeeding the file of the last log record, update logEnd to this position.\r\n        - Change assert to allow logEnd to be in a newer file than that of the last log record.\r\n         \r\nM      java/engine/org/apache/derby/impl/store/raw/log/Scan.java\r\n        - Introduced new variable newFileStart which will only have a valid LogInstant value when the scan is at the header of the file.\r\n        - When a new file is entered, set newFileStart to the first  possible LogInstant of this file (end of header).\r\n        - When a log record is encountered, set newFileStart to INVALID_LOG_INSTANT.\r\n        - Changed getLogRecordEnd() to return newFileStart if that is valid (i.e., scan is at the start of a file)\r\n        - Removed comment about not starting to write to the new empty log file, since that is not true anymore.\r\n\r\nA      java/testing/org/apache/derbyTesting/functionTests/tests/store/RecoveryAfterBackup_app.properties\r\n         - Test properties\r\n\r\nM      java/testing/org/apache/derbyTesting/functionTests/tests/store/copyfiles.ant\r\n         - Added new property files\r\n\r\nA      java/testing/org/apache/derbyTesting/functionTests/tests/store/RecoveryAfterBackupSetup_app.properties\r\n        - Test properties. \r\n        - useextdirs=true needed so the backup is placed somewhere the next test can find it.\r\n\r\nA      java/testing/org/apache/derbyTesting/functionTests/tests/store/RecoveryAfterBackup.java\r\n        - Test that is supposed to be run after RecoveryAfterBackupSetup.java.\r\n        - Does recovery, updates the database, shutdowns the database, and does roll-forward restore.\r\n        - Checks that updates made after recovery is reflected in the database after roll-forward restore.\r\n\r\nA      java/testing/org/apache/derbyTesting/functionTests/tests/store/RecoveryAfterBackupSetup.java\r\n        - Test that does the preparation for the RecoveryAfterBackup test.\r\n        -  Inserts a few records, makes a backup, and stops without shutting down.\r\n\r\nM      java/testing/org/apache/derbyTesting/functionTests/harness/RunTest.java\r\n        - For tests where the database is not deleted at the end of the test, do not delete the external directories either.\r\n        - This is necessary to be able to access the backup in suceeding tests.\r\n\r\nA      java/testing/org/apache/derbyTesting/functionTests/master/RecoveryAfterBackupSetup.out\r\n        - Test output\r\n\r\nA      java/testing/org/apache/derbyTesting/functionTests/master/RecoveryAfterBackup.out\r\n        - Test output\r\n\r\nMM     java/testing/org/apache/derbyTesting/functionTests/suites/storerecovery.runall\r\n        - Added tests to storerecovery suite.\r\n        - Changed property eol-style.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"created":"2005-07-04T19:17:40.000+0000","updated":"2005-07-04T19:17:40.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/32702/comment/12315265","id":"12315265","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tsuresh","name":"tsuresh","emailAddress":"suresh dot thalamati at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Suresh Thalamati","active":true},"body":"Hi Øystein, \r\n\r\n I could not  understand from the  changes,  If the new log file will be recognized in the following two cases:\r\n 1)  After the log switch,  if the first log record to the file  gets partially written on a preallocated log file \r\n 2) After the log swith , if  the first log write is written out of order incompletely and the checksum check verification fails.\r\n \r\nIn Scan.java : newFileStart gets set to LogCounter.INVALID_LOG_INSTANT,  immediately \r\nafter reading the instant , but the partial record verification and checksum checks happen\r\nafter that and valid  logEnd  value  still refers to previous log file . \r\n\r\nand also  it might  be good idea to make sure all the fields written in the initialization of  the log file are correct before using the new log file during recovery: initialization writes 4 fileds seperately , \r\nwhereas verification only looks at 3 fields. \r\n\r\nLogToFIle.java()  : initLogFile() :\r\nnewlog.writeInt(fid);\r\nnewlog.writeInt(OBSOLETE_LOG_VERSION_NUMBER); // for silly backwards compatibility reason\r\nnewlog.writeLong(number);\r\nnewlog.writeLong(prevLogRecordEndInstant);\r\n\r\nwhereas  LogTOFIle: private boolean verifyLogFormat(StorageRandomAccessFile log, longnumber) \r\nwhich is called before the swicth does not  read/verify  \"prevLogRecordEndInstant\" . \r\n\r\n\r\nThanks\r\n-suresh\r\n  \r\n\r\n\r\n\r\n\r\n\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tsuresh","name":"tsuresh","emailAddress":"suresh dot thalamati at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Suresh Thalamati","active":true},"created":"2005-07-08T07:29:28.000+0000","updated":"2005-07-08T07:29:28.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/32702/comment/12315919","id":"12315919","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"body":"Suresh,\r\n\r\nThe intent is that the new log file should be recognized after a log switch, regardless of what log records may have been written after this log switch. I see your point that if the log file contains a single corrupt record,  the log switch will not have an effect since newFileStart has been reset and logEnd has not been advanced to the new file.  Thanks for detecting this.\r\n\r\nMy suggestion for fixing this, is to drop the introduction of newFileStart and just update logEnd to the start of the new log file when the log file is detected.  In addition, logEnd must not be reset to INVALID_LOG_INSTANT when a scan is closed.  This way it is possible to get the logEnd after the scan is closed and check whether it has been advanced since the last log record was processed.\r\n\r\nFor the verification of prevLogRecordEndInstant, I guess that the best is to verify this for all files processed during recovery.  I assume that the prevLogRecordEndInstant of a file should be equal to the current logEnd when switching to this file. \r\n\r\nThanks for the advice, I will create a new patch.\r\n \r\nØystein","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"created":"2005-07-15T22:27:33.000+0000","updated":"2005-07-15T22:27:33.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/32702/comment/12361100","id":"12361100","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"body":"The recently attached patch (derby-298a.diff) addresses Suresh's\r\nreview comments.  The only major change from the previous patch is in\r\njava/engine/org/apache/derby/impl/store/raw/log/Scan.java. The changes\r\nto this file compared to the current head of trunk are:\r\n \r\n   - When a new log file is entered, check that the header of this\r\n     file refers to the end of the last log record of the previous log\r\n     file.  If not, stop the scan.\r\n   - If the header was consistent, update knowGoodLogEnd to the first\r\n     possible LogInstant of this file (end of header).\r\n   - close() no longer reset knownGoodLogEnd since it is needed by\r\n     FileLogger after the scan is closed.\r\n   - Changed comment of getLogRecordEnd() to reflect that it can be\r\n     used after the scan is closed, and that it at that time may\r\n     return the start of an empty log file.\r\n   - Removed comment about not starting to write to the new empty log\r\n     file, since that is not true anymore.\r\n\r\nIn addition, the property files for the tests have been updated so\r\nthey are run without the security manager.\r\n\r\nderbyall has been run with no new failures.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"created":"2005-12-22T20:12:00.000+0000","updated":"2005-12-22T20:12:00.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/32702/comment/12361808","id":"12361808","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tsuresh","name":"tsuresh","emailAddress":"suresh dot thalamati at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Suresh Thalamati","active":true},"body":"Øystein ,\r\n\r\nI reviewed the  latest patch, it looks good.  But  I could  not understand why you would need the following check ?\r\n\r\nFileLogge.java :\r\n+            long end = redoScan.getLogRecordEnd(); \r\n+            if (end != LogCounter.INVALID_LOG_INSTANT\r\n\r\nIf end is  LogCounter.INVALID_LOG_INSTANT then logEnd is also likely to be LogCounter.INVALID_LOG_INSTANT  right ?\r\n\r\n+                && (LogCounter.getLogFileNumber(logEnd) \r\n+                    < LogCounter.getLogFileNumber(end))) {\r\n+                logEnd = end;\r\n+            }\r\n\r\nIn what secnario  condition  will be  false ?   If end is  LogCounter.INVALID_LOG_INSTANT then logEnd is also likely to be \r\n\r\n\r\nAnother minor thing I notices is  test files copyrigth notices have wrong file names :\r\nRecoveryAfterBackup.java:\r\nDerby - Class org.apache.derbyTesting.functionTests.store.LogChecksumSetup\r\nRecoveryAfterBackupSetup.java:\r\nDerby - Class org.apache.derbyTesting.functionTests.store.LogChecksumSetup\r\n\r\n\r\nThanks\r\n-suresh","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=tsuresh","name":"tsuresh","emailAddress":"suresh dot thalamati at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Suresh Thalamati","active":true},"created":"2006-01-05T11:18:51.000+0000","updated":"2006-01-05T11:18:51.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/32702/comment/12361817","id":"12361817","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"body":"Suresh,\r\n\r\nYou are right that with my latest version of the patch,\r\ngetLogRecorEnd() will only return INVALID_LOG_INSTANT when the scan\r\ndid not get out of the starting blocks.  Regardsless of that, the\r\nsecond part of the if test will always be false when end is\r\nINVALID_LOG_INSTANT.\r\n\r\nI will remove the unecessary check and fix the copyright notices.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"created":"2006-01-05T17:45:36.000+0000","updated":"2006-01-05T17:45:36.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/32702/comment/12361843","id":"12361843","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"body":"derby-298b.diff is an updated patch that fixes the issues raised by Suresh in his latest review.\r\nThe storeall testsuite has been run without errors.  Are currently running the derbyall testsuite.  \r\nWill notify list later today if derbyall should fail.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"created":"2006-01-05T22:02:19.000+0000","updated":"2006-01-05T22:02:19.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/32702/comment/12362313","id":"12362313","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"body":"Verified that the added test run without failure.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"created":"2006-01-10T18:41:19.000+0000","updated":"2006-01-10T18:41:19.000+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/32702/comment/12362691","id":"12362691","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=djd","name":"djd","emailAddress":"djd at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daniel John Debrunner","active":true},"body":"This patch added two new tests, RecoveryAfterBackup and RecoveryAfterBackupSetup, both of which are being run without a SecurityManager due to the noSecurityManager=true in their _app.properties files.\r\n\r\nWhy are these tests excluded from running with a SecurityManager?\r\nIt should be rare that a test is to not to be run with a SecurityManager, if such a need arises the noSecurityManager=true must be commented to indicate why this is the case.\r\n\r\nThe default for any new tests in the existing harness should be to run with the SecurityManager.\r\n\r\nThere are a handful of tests that have noSecurityManager=true with no comment or a comment that says needs investigating, I'm working on all of these since they are exisiting tests, but it's not my itch to clean up new tests.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=djd","name":"djd","emailAddress":"djd at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daniel John Debrunner","active":true},"created":"2006-01-14T06:44:58.000+0000","updated":"2006-01-14T06:44:58.000+0000"}]},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-298/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i078g7:"}}