{"expand":"renderedFields,names,schema,transitions,operations,editmeta,changelog","id":"12404026","self":"https://issues.apache.org/jira/rest/api/latest/issue/12404026","key":"DERBY-3872","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/10594","id":"10594","key":"DERBY","name":"Derby","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=10594&avatarId=10122","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=10594&avatarId=10122","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=10594&avatarId=10122","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=10594&avatarId=10122"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10090","id":"10090","description":"DB related projects","name":"DB"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12313401","id":"12313401","description":"Head of 10.4 branch","name":"10.4.2.1","archived":false,"released":false},{"self":"https://issues.apache.org/jira/rest/api/2/version/12313771","id":"12313771","description":"build: 764942, 14/Apr/09. Voted release: 28/Apr/09. Announced: 1/May/09","name":"10.5.1.1","archived":false,"released":true,"releaseDate":"2009-04-28"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12310220":"2008-09-10 02:49:13.095","customfield_12312322":null,"customfield_12312323":null,"customfield_12310420":"23891","customfield_12310222":"1_*:*_1_*:*_4174291469_*|*_5_*:*_1_*:*_0","customfield_12312320":null,"customfield_12312321":null,"customfield_12312120":null,"customfield_12312121":null,"resolutiondate":"2008-10-28T04:26:54.576+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312326":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312324":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-3872/watchers","watchCount":0,"isWatching":false},"created":"2008-09-09T20:55:23.107+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12312334":null,"customfield_12310310":"4.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12313142","id":"12313142","description":"","name":"10.3.3.0","archived":false,"released":true,"releaseDate":"2008-05-12"}],"customfield_12311120":null,"customfield_12312330":null,"issuelinks":[{"id":"12321623","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12321623","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"inwardIssue":{"id":"12325311","key":"DERBY-681","self":"https://issues.apache.org/jira/rest/api/2/issue/12325311","fields":{"summary":"Eliminate the parser's rewriting of the abstract syntax tree for queries with GROUP BY and/or HAVING clauses","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/4","id":"4","description":"An improvement or enhancement to an existing feature or task.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/improvement.png","name":"Improvement","subtask":false}}}}],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"customfield_12312337":null,"customfield_12312338":null,"updated":"2011-01-21T17:52:06.440+0000","customfield_12312335":null,"customfield_12311720":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"components":[],"timeoriginalestimate":null,"description":"Use attached SQL script to create two tables , execute the following SQL and throw the exception and stack trace below.  NOTE:  removing the 'always true' clause '.. ( integer (1.1) = 1) ..\" from the SQL and the query does not fail.  Releated??\n\nselect  q1.\"DEPTNO\" from DEPTTAB q1, EMPTAB q2 where  ( integer (1.1) = 1)  and  ( q2.\"DEPT_DEPTNO\" =  q1.\"DEPTNO\")  \nGROUP BY q1.\"DEPTNO\" \nHAVING  max( q2.\"SALARY\") >=  ( select  q3.\"SALARY\" from EMPTAB q3 where  ( q3.\"EMPID\" =  q1.\"DEPTNO\") ) \n\nERROR 38000: The exception 'java.lang.NullPointerException' was thrown while evaluating an expression.\n. . .derby.iapi.error.StandardException.newException\n. . .derby.iapi.error.StandardException.unexpectedUserException\n. . .derby.impl.services.reflect.DirectCall.invoke\n. . .derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore\n. . .derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow\n. . .derby.impl.jdbc.EmbedResultSet.movePosition\n. . .derby.impl.jdbc.EmbedResultSet.next\n. . .derby.tools.JDBCDisplayUtil.indent_DisplayResults\n. . .derby.tools.JDBCDisplayUtil.indent_DisplayResults\n. . .derby.tools.JDBCDisplayUtil.indent_DisplayResults\n. . .derby.tools.JDBCDisplayUtil.DisplayResults\n. . .derby.impl.tools.ij.utilMain.displayResult\n. . .derby.impl.tools.ij.utilMain.doCatch\n. . .derby.impl.tools.ij.utilMain.runScriptGuts\n. . .derby.impl.tools.ij.utilMain.go\n. . .derby.impl.tools.ij.Main.go\n. . .derby.impl.tools.ij.Main.mainCore\n. . .derby.impl.tools.ij.Main14.main\n. . .derby.tools.ij.main\nCaused by: java.lang.NullPointerException\n. . .derby.iapi.types.NumberDataType.compare\n. . .derby.impl.store.access.btree.ControlRow.compareIndexRowFromPageToKey\n. . .derby.impl.store.access.btree.ControlRow.searchForEntry\n. . .derby.impl.store.access.btree.LeafControlRow.search\n. . .derby.impl.store.access.btree.BTreeScan.positionAtStartForForwardScan\n. . .derby.impl.store.access.btree.BTreeForwardScan.positionAtStartPosition\n. . .derby.impl.store.access.btree.BTreeForwardScan.fetchRows\n. . .derby.impl.store.access.btree.BTreeScan.fetchNext\n. . .derby.impl.sql.execute.TableScanResultSet.getNextRowCore\n. . .derby.impl.sql.execute.IndexRowToBaseRowResultSet.getNextRowCore\n. . .derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore\n. . .derby.impl.sql.execute.OnceResultSet.getNextRowCore\n. . .derby.exe.ac601a400fx011cx480cx5eacx00000010d8100.g0\n. . .derby.exe.ac601a400fx011cx480cx5eacx00000010d8100.e6\n\t... 17 more\n============= begin nested exception, level (1) ===========\njava.lang.NullPointerException\n. . .derby.iapi.types.NumberDataType.compare\n. . .derby.impl.store.access.btree.ControlRow.compareIndexRowFromPageToKey\n. . .derby.impl.store.access.btree.ControlRow.searchForEntry\n. . .derby.impl.store.access.btree.LeafControlRow.search\n. . .derby.impl.store.access.btree.BTreeScan.positionAtStartForForwardScan\n. . .derby.impl.store.access.btree.BTreeForwardScan.positionAtStartPosition\n. . .derby.impl.store.access.btree.BTreeForwardScan.fetchRows\n. . .derby.impl.store.access.btree.BTreeScan.fetchNext\n. . .derby.impl.sql.execute.TableScanResultSet.getNextRowCore\n. . .derby.impl.sql.execute.IndexRowToBaseRowResultSet.getNextRowCore\n. . .derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore\n. . .derby.impl.sql.execute.OnceResultSet.getNextRowCore\n. . .derby.exe.ac601a400fx011cx480cx5eacx00000010d8100.g0\n. . .derby.exe.ac601a400fx011cx480cx5eacx00000010d8100.e6\n. . .derby.impl.services.reflect.DirectCall.invoke\n. . .derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore\n. . .derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow\n. . .derby.impl.jdbc.EmbedResultSet.movePosition\n. . .derby.impl.jdbc.EmbedResultSet.next\n. . .derby.tools.JDBCDisplayUtil.indent_DisplayResults\n. . .derby.tools.JDBCDisplayUtil.indent_DisplayResults\n. . .derby.tools.JDBCDisplayUtil.indent_DisplayResults\n. . .derby.tools.JDBCDisplayUtil.DisplayResults\n. . .derby.impl.tools.ij.utilMain.displayResult\n. . .derby.impl.tools.ij.utilMain.doCatch\n. . .derby.impl.tools.ij.utilMain.runScriptGuts\n. . .derby.impl.tools.ij.utilMain.go\n. . .derby.impl.tools.ij.Main.go\n. . .derby.impl.tools.ij.Main.mainCore\n. . .derby.impl.tools.ij.Main14.main\n. . .derby.tools.ij.main\n============= end nested exception, level (1) ===========\nCleanup action completed\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12310200":[{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10420","value":"Regression","id":"10420"}],"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"aggregatetimeestimate":null,"customfield_12312022":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12310921":null,"customfield_12310920":"37268","summary":"NullPoinerException thrown when INTEGER function used as a predicate in a WHERE clause of a SELECT .. GROUP BY ..  HAVING statement","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stan","name":"stan","emailAddress":"Stan dot Bradbury at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Stan Bradbury","active":true},"subtasks":[],"customfield_12310090":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stan","name":"stan","emailAddress":"Stan dot Bradbury at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Stan Bradbury","active":true},"customfield_12310291":null,"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"environment":null,"customfield_12311020":null,"customfield_12310050":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"startAt":0,"maxResults":32,"total":32,"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12629686","id":"12629686","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"With the current trunk, I also see a NPE, but the stack trace is different. My stack trace is:\r\n\r\njava.lang.NullPointerException\r\n        at org.apache.derby.impl.sql.execute.BaseActivation.getColumnFromRow(BaseActivation.java:1419)\r\n        at org.apache.derby.exe.ac4ac48095x011cx4a35x4fd4x00000013bb68f.e8(Unknown Source)\r\n        at org.apache.derby.impl.services.reflect.DirectCall.invoke(ReflectGeneratedClass.java:155)\r\n        at org.apache.derby.impl.sql.execute.TableScanResultSet.openCore(TableScanResultSet.java:250)\r\n        at org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet.openCore(IndexRowToBaseRowResultSet.java:202)\r\n        at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.openCore(ProjectRestrictResultSet.java:168)\r\n        at org.apache.derby.impl.sql.execute.OnceResultSet.openCore(OnceResultSet.java:119)\r\n        at org.apache.derby.exe.ac4ac48095x011cx4a35x4fd4x00000013bb68f.g0(Unknown Source)\r\n        at org.apache.derby.exe.ac4ac48095x011cx4a35x4fd4x00000013bb68f.e6(Unknown Source)\r\n        at org.apache.derby.impl.services.reflect.DirectCall.invoke(ReflectGeneratedClass.java:151)\r\n        at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(ProjectRestrictResultSet.java:267)\r\n        at org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow(BasicNoPutResultSetImpl.java:460)\r\n        at org.apache.derby.impl.jdbc.EmbedResultSet.movePosition(EmbedResultSet.java:423)\r\n        at org.apache.derby.impl.jdbc.EmbedResultSet.next(EmbedResultSet.java:367)\r\n        at org.apache.derby.tools.JDBCDisplayUtil.indent_DisplayResults(JDBCDisplayUtil.java:382)\r\n        at org.apache.derby.tools.JDBCDisplayUtil.indent_DisplayResults(JDBCDisplayUtil.java:338)\r\n        at org.apache.derby.tools.JDBCDisplayUtil.indent_DisplayResults(JDBCDisplayUtil.java:241)\r\n        at org.apache.derby.tools.JDBCDisplayUtil.DisplayResults(JDBCDisplayUtil.java:229)\r\n        at org.apache.derby.impl.tools.ij.utilMain.displayResult(utilMain.java:435)\r\n        at org.apache.derby.impl.tools.ij.utilMain.doCatch(utilMain.java:509)\r\n        at org.apache.derby.impl.tools.ij.utilMain.runScriptGuts(utilMain.java:350)\r\n        at org.apache.derby.impl.tools.ij.utilMain.go(utilMain.java:248)\r\n        at org.apache.derby.impl.tools.ij.Main.go(Main.java:215)\r\n        at org.apache.derby.impl.tools.ij.Main.mainCore(Main.java:181)\r\n        at org.apache.derby.impl.tools.ij.Main.main(Main.java:73)\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2008-09-10T02:49:13.095+0000","updated":"2008-09-10T02:49:13.095+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12629791","id":"12629791","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"This bug was introduced by the fix for DERBY-681 (revision 516454).","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-09-10T13:03:56.806+0000","updated":"2008-09-10T13:03:56.806+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12629906","id":"12629906","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"The stack trace changed with \r\n\r\nr662947 | bpendleton | 2008-06-03 19:44:17 -0700 (Tue, 03 Jun 2008) | 4 lines\r\n\r\nDERBY-3097: Remove unnecessary if stmt from BaseActivation.getColumnFromRow\r\n\r\nThis change removes an unnecessary if statement from BaseActivation.java.\r\n\r\nMy first take is that there is not a problem with removing the if statement, just that it moved the NPE to a different place.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2008-09-10T18:39:14.460+0000","updated":"2008-09-10T18:39:14.460+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12629950","id":"12629950","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"It doesn't seem related directly to the integer function as described in the summary. If we use (1 =1) as in:\r\n\r\nselect  q1.\"DEPTNO\" from DEPTTAB q1, EMPTAB q2 where (1 =1) and ( q2.\"DEPT_DEPTNO\" =  q1.\"DEPTNO\")  GROUP BY q1.\"DEPTNO\" HAVING  max( q2.\"SALARY\") >=  ( select  q3.\"SALARY\" from EMPTAB q3 where  ( q3.\"EMPID\" =  q1.\"DEPTNO\") ) ;\r\n\r\nthe same problem occurs, but as stan mentioned if the always true predicate is removed the query runs fine.\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2008-09-10T20:32:15.299+0000","updated":"2008-09-10T20:32:15.299+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12630300","id":"12630300","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Well I put some printlns in for calls to BaseActivation.setCurrentRow, clearCurrentRow and getColumnFromRow and looked at the difference between the query with and without the (1 = 1) predicate.\r\nThe results are posted here as \r\nQueryWithTruePred.out\r\nand\r\nQueryWithoutTruePred.out \r\n\r\nI noticed two notable differences.  \r\n1)\r\nsetCurrentRow is called twice for each row with the true predicate ( the failing case). I don't know if this is normal.\r\n\r\n2) \r\nWhen compiling the final result, the failing case calls getColumnFromRow(5,1) for result set 5 when result set 5 has not been set, thus causing the NPE.  It seems it should be\r\ngetColumnFromRow(1,1) as it is for the passing case.\r\n\r\nI did a little debugging of ExpressionClassBuilder.pushColumnReference() and found that the ResultColumn that is being referenced in result set 5 is DEPTNO, but I haven't gotten much further than that.\r\n\r\nI am not actually sure what all the result set numbers are referring to.  \r\n\r\nAny suggestions are welcome.\r\n\r\n\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2008-09-11T18:43:18.356+0000","updated":"2008-09-11T18:43:18.356+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12630401","id":"12630401","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"I suspect that the problem is happening during the code generation phase\r\nof the compiler, so you'll want to be debugging the 'generate()' methods that\r\nare being called. Sometimes having a look at the overall 'shape' of the query\r\ntree is useful, by e.g. dumping the query plan, as it will tell you what result set 5\r\nis and then you may be able to figure out which generate() method to step through.\r\n\r\nI suspect that the problem involves result set handling. Why does the\r\nExpressionClassBuilder for the (1=1) expression think that there are any\r\ncolumn references at all? There should only be literal references, not column references,\r\nin the (1=1) expression.\r\n\r\nHope this helps, I know it's pretty free-form.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2008-09-11T22:21:06.749+0000","updated":"2008-09-11T22:21:06.749+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12630594","id":"12630594","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"I looked at the plans and noticed that the passing case (the one without the true predicate) was using a nested loop join and the failing case (the one with the true predicate was using a hash join), so I forced a hash join  for the query without the true predicate and also get a NPE.\r\n\r\ne.g.\r\nselect  q1.\"DEPTNO\" from DEPTTAB q1, EMPTAB q2 -- DERBY-PROPERTIES joinStrategy = HASH\r\nwhere ( q2.\"DEPT_DEPTNO\" =  q1.\"DEPTNO\")  GROUP BY q1.\"DEPTNO\" HAVING  max( q2.\"SALARY\") >=  ( select  q3.\"SALARY\" from EMPTAB q3 where  ( q3.\"EMPID\" =  q1.\"DEPTNO\") ) \r\n\r\n;\r\nand the trace is:\r\nCaused by: java.lang.NullPointerException\r\n\tat org.apache.derby.impl.sql.execute.BaseActivation.getColumnFromRow(BaseActivation.java:1422)\r\n\tat org.apache.derby.exe.acf81e0010x011cx571bx0fbfx000000428ba82.e7(Unknown Source)\r\n\tat org.apache.derby.impl.services.reflect.DirectCall.invoke(ReflectGeneratedClass.java:153)\r\n\tat org.apache.derby.impl.sql.execute.TableScanResultSet.reopenCore(TableScanResultSet.java:536)\r\n\tat org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet.reopenCore(IndexRowToBaseRowResultSet.java:285)\r\n\tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.reopenCore(ProjectRestrictResultSet.java:212)\r\n\tat org.apache.derby.impl.sql.execute.OnceResultSet.reopenCore(OnceResultSet.java:149)\r\n\tat org.apache.derby.impl.sql.execute.OnceResultSet.openCore(OnceResultSet.java:113)\r\n\tat org.apache.derby.exe.acf81e0010x011cx571bx0fbfx000000428ba82.g0(Unknown Source)\r\n\tat org.apache.derby.exe.acf81e0010x011cx571bx0fbfx000000428ba82.e5(Unknown Source)\r\n\tat org.apache.derby.impl.services.reflect.DirectCall.invoke(ReflectGeneratedClass.java:149)\r\n\tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(ProjectRestrictResultSet.java:267)\r\n\tat org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow(BasicNoPutResultSetImpl.java:460)\r\n\tat org.apache.derby.impl.jdbc.EmbedResultSet.movePosition(EmbedResultSet.java:423)\r\n\t... 13 more\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2008-09-12T15:31:08.772+0000","updated":"2008-09-12T15:31:08.772+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12631437","id":"12631437","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I spent some time simplifying the test case which reproduces the null pointer exception. The test case is as follows\r\n\r\nCREATE TABLE EMPTAB\r\n  (EMPID INTEGER NOT NULL,\r\n   SALARY DECIMAL(10, 4),\r\n   DEPT_DEPTNO INTEGER);\r\n\r\nALTER TABLE EMPTAB\r\n  ADD CONSTRAINT PK_EMPTAB PRIMARY KEY (EMPID);\r\n\r\nCREATE TABLE DEPTTAB\r\n  (DEPTNO INTEGER NOT NULL);\r\n\r\nALTER TABLE DEPTTAB\r\n  ADD CONSTRAINT PK_DEPTTAB PRIMARY KEY (DEPTNO);\r\n\r\ninsert into DEPTTAB values( 1 );\r\n\r\ninsert into EMPTAB values( 1, 1000, 1 );\r\n\r\nselect q1.\"DEPTNO\" from DEPTTAB q1, EMPTAB q2 -- DERBY-PROPERTIES joinStrategy = HASH \r\nwhere ( q2.\"DEPT_DEPTNO\" = q1.\"DEPTNO\") \r\nGROUP BY q1.\"DEPTNO\" HAVING 1 = \r\n  ( select q3.\"SALARY\" from EMPTAB q3 where ( q3.\"EMPID\" = q1.\"DEPTNO\") ) \r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2008-09-16T15:46:23.760+0000","updated":"2008-09-16T15:46:23.760+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12631439","id":"12631439","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"Thanks Mamta! I verified that your repro script produces the NPE in my environment,\r\n too, with the current trunk.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2008-09-16T15:50:59.555+0000","updated":"2008-09-16T15:50:59.555+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12631843","id":"12631843","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Thanks for verifying it, Bryan. I spent little more time on following 2 queries to see how we generate the code for them\r\nQuery1\r\n   select q1.\"DEPTNO\" from DEPTTAB q1, EMPTAB q2 -- DERBY-PROPERTIES joinStrategy = HASH \r\n    where ( q2.\"DEPT_DEPTNO\" = q1.\"DEPTNO\") \r\n    GROUP BY q1.\"DEPTNO\" HAVING 1 = \r\n    ( select q3.\"SALARY\" from EMPTAB q3 where ( q3.\"EMPID\" = q1.\"DEPTNO\") ) ;\r\n\r\nQuery2\r\n  select q1.\"DEPTNO\" from DEPTTAB q1, EMPTAB q2 \r\n     where ( q2.\"DEPT_DEPTNO\" = q1.\"DEPTNO\") \r\n     GROUP BY q1.\"DEPTNO\" HAVING 1 = \r\n     ( select q3.\"SALARY\" from EMPTAB q3 where ( q3.\"EMPID\" = q1.\"DEPTNO\") ) ;\r\n\r\nQuery1 results in a NPE whereas Query2 runs fine. Notice that Query1 has optimizer override to use hashjoin.\r\n\r\nWhat I found during the code generation phase of the 2 queries is that \r\n1)The number of resultsets generated for the 2 queries are not same. Query1 has 11 generated resultsets whereas Query2 has 10 generated resultsets.\r\n2)For the outer query, in case of Query1, the DEPTTAB is the left operand of the join node and EMPTAB is the right operand. The generated resultset for DEPTTAB get resultset number 3 assigned to it and the generated resultset for EMPTAB gets resultset number 4 assigned to it. For some reason, the order of these resultsets are switched in case of Query2. So, EMPTAB is the left operand for the join node and DEPTTAB is the right operand for the join node.\r\n3)Another thing to note at code generation time is for subquery. In case of Query1, we have 2 nodes associated with EMPTAB q3, namely IndexToBaseRowNode and FromBaseTable. In case of Query2, we have only one node for EMPTAB q3 and that is FromBaseTable.\r\n\r\nLastly, at runtime, right before we hit the NPE, activation object shows following current rows associated with each of the 11 generated resultsets\r\n[null, { 1 }, null, null, null, null, { 1 }, null, null, null, null]\r\nNotice that current row for resultset number 3 is null and that is causing the npe.\r\nFor Query2, the activation object shows following current rows associated with each of it's 10 generated resultsets\r\n[null, null, null, { 1 }, null, null, null, null, null, null]\r\nNotice that current row for resultset number 3 is not null.\r\n\r\nI am not sure how useful information is this, but I wanted to share what I have. I will continue debugging more.\r\n\r\n\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2008-09-17T16:50:18.889+0000","updated":"2008-09-17T16:50:18.889+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12632395","id":"12632395","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I have some more finidings to share on Query1\r\n   select q1.\"DEPTNO\" from DEPTTAB q1, EMPTAB q2 -- DERBY-PROPERTIES joinStrategy = HASH \r\n    where ( q2.\"DEPT_DEPTNO\" = q1.\"DEPTNO\") \r\n    GROUP BY q1.\"DEPTNO\" HAVING 1 = \r\n    ( select q3.\"SALARY\" from EMPTAB q3 where ( q3.\"EMPID\" = q1.\"DEPTNO\") ) ; \r\n\r\nThe query as written above results in NPE but if I change the order of tables in the outer query's from list as shown below, there is no NPE\r\n   select q1.\"DEPTNO\" from EMPTAB q2, DEPTTAB q1 -- DERBY-PROPERTIES joinStrategy = HASH \r\n    where ( q2.\"DEPT_DEPTNO\" = q1.\"DEPTNO\") \r\n    GROUP BY q1.\"DEPTNO\" HAVING 1 = \r\n    ( select q3.\"SALARY\" from EMPTAB q3 where ( q3.\"EMPID\" = q1.\"DEPTNO\") ) ; \r\n\r\nIt appears that changing the order of the tables makes Derby bypass the sort avoidance code. To be more specific, impl.sql.compile.GroupByNode:init method has following check\r\nif (index == glSize) {\r\n    isInSortedOrder = childResult.isOrderedOn(crs, true, (Vector)null);\r\n}\r\nThis piece of code assigns true to isInSortedOrder if DEPTTAB is first in the from list of query. The code comment in JoinNode.isOrdered which is what gets called by the code segment above has following interesting comment\r\n/* RESOLVE - easiest thing for now is to only consider the leftmost child */\r\nThis is why if I change the order of the tables in the from list, DEPTTAB is no more the leftmost child and hence isInSortedOrder ends up getting a value of FALSE when DEPTTAB is not the first table in the from list. (This piece of code so far is in Derby's query compile code.)\r\n\r\nAt query execution time, we check this flag is impl.sql.execute.GroupedAggregateResultSet:openCore as shown below\r\n/* If this is an in-order group by then we do not need the sorter.\r\n * (We can do the aggregation ourselves.)\r\n * We save a clone of the first row so that subsequent next()s\r\n * do not overwrite the saved row.\r\n */\r\nif (isInSortedOrder)\r\n{\r\n\tcurrSortedRow = getNextRowFromRS();\r\n\tif (currSortedRow != null)\r\n\t{\r\n\t\tcurrSortedRow = (ExecIndexRow)currSortedRow.getClone();\r\n\t\tinitializeVectorAggregation(currSortedRow);\r\n\t}\r\n}\r\nelse\r\n{\r\n/*\r\n** Load up the sorter\r\n*/\r\n\tscanController = loadSorter();\r\n}\r\n\r\nIf isInSortOrder is found to be true, we go through the code path which causes us to run into NPE. I need to do more debugging but I think what happens in this code path is we set the current row associated with various internal resutsets hanging off of the Activation object and most of these current row end up being NULL and later on, the code is looking for specific column value in the current row not expecting the current row to be NULL. \r\n\r\nI will also try to compare the code flow in 10.2 codeline vs trunk because the query in question works fine in 10.2 no matter how the tables are listed the from list in the query.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2008-09-18T21:20:51.920+0000","updated":"2008-09-18T21:20:51.920+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12633378","id":"12633378","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"While trying to run through the 10.2 codeline and trunk, one of the things I noticed is that impl.sql.compile.SelectNode:preprocess method has code around line number 1000 that looks like following in 10.2 codeline\r\n\t/* A valid group by without any aggregates is equivalent to \r\n\t * a distinct without the group by.  We do the transformation\r\n\t * in order to simplify the group by code.\r\n\t */\r\n\tif (groupByList != null &&\r\n\t\tselectAggregates.size() == 0 &&\r\n\t\twhereAggregates.size() == 0)\r\n\t{\r\n\t\tisDistinct = true;\r\n\t\tgroupByList = null;\r\n\t}\r\n\r\nThe corresponding code in trunk has additional check in the if condition as shown below\r\n\t/* A valid group by without any aggregates or a having clause\r\n\t * is equivalent to a distinct without the group by.  We do the transformation\r\n\t * in order to simplify the group by code.\r\n\t */\r\n\tif (groupByList != null &&\r\n\t\thavingClause == null &&\r\n\t\tselectAggregates.size() == 0 &&\r\n\t\twhereAggregates.size() == 0)\r\n\t{\r\n\t\tisDistinct = true;\r\n\t\tgroupByList = null;\r\n\t\twasGroupBy = true;\r\n\t}\r\n\r\nJust to see what would happen I removed the (havingClause == null &&) check in the trunk codeline and ran our queries that are running in NPE in this jira entry and they ran fine with no NPE. But of course, the solution couldn't be this easy because this change causes existing tests in junit suite to fail. I will try to undestand what was the logic behind the changes that went in for DERBY-681 but any other tips at all to make progress on this jira entry will be greatly appreciated. I am not sure if the queries in question in this jira entry should follow the new code path introduced by DERBY-681.\r\n\r\nI am wondering if anyone who has looked at other regressions caused by DERBY-681 know why removing the havingClause == null && check makes the queries in this jira entry run with no NPE. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2008-09-22T16:50:18.758+0000","updated":"2008-09-22T16:50:18.758+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12633670","id":"12633670","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"The (havingClause==null) check is not in the 10.2 code line because the abstract syntax tree would be rewritten so that it never had HAVING clauses in 10.2. In 10.3, the abstract syntax tree would preserve the HAVING clauses, so that's probably why the check was added. Adding more checks to the if statement shouldn't be problematic, though. It's just an optimization, so even removing the entire if should not cause any wrong results, I hope.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-09-23T10:08:29.888+0000","updated":"2008-09-23T10:08:29.888+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12633967","id":"12633967","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"Hi Mamta, thanks for all the hard work you've been doing to investigate this!\r\n\r\nI think your observation about the \"if\" statement in SelectNode.preprocess is very interesting.\r\n\r\nI believe that the idea behind that \"if\" statement is that some queries that are written\r\nas GROUP BY queries can be replaced (rewritten) to be DISTINCT queries instead.\r\n\r\nAs an example, consider this very simple query:\r\n\r\n   select last_name from employee group by last_name\r\n\r\nThat query can be re-written (internally) to be:\r\n\r\n  select distinct last_name from employee\r\n\r\nas the two queries have the same meaning (we only want 1 row in the\r\noutput for each different value of the LAST_NAME column).\r\n\r\nThis transformation is only valid if no aggregate functions (MIN MAX COUNT SUM AVG)\r\nare used, because if the aggregate functions are used then GROUP BY does\r\nsomething different than DISTINCT.\r\n\r\nNow, in the particular case of your problematic query, there are in fact no\r\naggregate functions being used, which is why this \"if\" statement is relevant.\r\n\r\nI think that what removing the (havingClause == null) check from the \"if\" statement\r\ndid was to give SelectNode.preprocess permission to convert your query:\r\n\r\n  select q1.\"DEPTNO\" from DEPTTAB q1, EMPTAB q2 -- DERBY-PROPERTIES joinStrategy = HASH\r\n    where ( q2.\"DEPT_DEPTNO\" = q1.\"DEPTNO\") \r\n    GROUP BY q1.\"DEPTNO\" HAVING 1 =\r\n          (  select q3.\"SALARY\" from EMPTAB q3 where ( q3.\"EMPID\" = q1.\"DEPTNO\") ) \r\n\r\ninto the simpler, but (I think) equivalent query:\r\n\r\nselect distinct q1.\"DEPTNO\" from DEPTTAB q1, EMPTAB q2 \r\nwhere ( q2.\"DEPT_DEPTNO\" = q1.\"DEPTNO\"  and \r\n   1 =  ( select q3.\"SALARY\" from EMPTAB q3 where ( q3.\"EMPID\" = q1.\"DEPTNO\") ) \r\n\r\n  (I'm not totally sure the above is valid syntax but hopefully it's close)\r\n\r\nThat is, the \"having\" clause is pretty much like the \"where\" clause, but it is\r\napplied *after* the GROUP BY is performed, whereas the where clause is\r\napplied *before* the GROUP BY.  By transforming the query internally to\r\nremove the GROUP BY, the HAVING clause is essentially collapsed into the where.\r\n\r\nNow, regarding why this is so relevant to your case, and why the \"sort avoidance\"\r\nquestion is important, here's a few more ideas:\r\n\r\nGROUP BY grouping can basically be performed in two fundamental ways:\r\n - sorting\r\n - hashing\r\n\r\nEither one of these techniques clusters the \"like\" values together so that they\r\ncan be recognized as belonging to the same group and be collapsed.\r\n\r\nIn Derby, I think, we *only* use the sorting techinque for group by processing,\r\n*not* the hashing technique (but please don't trust me on this, instead verify\r\nthis yourself). However, there is a weird little optimization where the sorting-based\r\ngroup by processing can either happen:\r\n - in the sorter, during a sort\r\n - or in the GROUP BY result set\r\nRegardless of where it happens, the idea is that the rows are sorted on the\r\nvalues that we're grouping by, then as we process them we compare the\r\ncurrent row to the previous row, and if they have the same \"key\" then they\r\ngo into the same \"group\" in the result.\r\n\r\nSorting the data can be *very* expensive, which is why the sort avoidance\r\nalgorithm is an important optimization. If the compilation / optimization processing\r\ncan determine that the rows are going to appear in sorted order by the group by\r\ncolumn(s), then we can skip the sort, so we do so.\r\n\r\nBeing able to skip the sort is usually because the column that we are\r\ngrouping on is a column which is used in an index, and by doing an\r\nindex-to-base-table access for that data, we can ensure that we get\r\nthe data via the index, and hence it is in sorted order.\r\n\r\nIt sounds like the bug may have something to do with *thinking* that the rows\r\nare going to appear in sorted order, so we can skip the sort, but then the \r\nquery plan gets changed around late in optimization and the actual rows\r\ndo not appear in sorted order, so the assumption that we could group them\r\nwithout needing to sort them was wrong.\r\n\r\nAnd the extra result set that you were seeing in the one case (11 result sets\r\nversus 10) may have to do with the result set that would have been present\r\nto perform the sorting, or it may have to do with an index-to-base traversal\r\nthat was expected to occur in order to ensure that the rows were in sorted order.\r\n\r\nI hope some of this is helpful; you are definitely going in the right direction with\r\ntrying to track this problem down; these problems are really tough so don't\r\nget discouraged just keep it up!\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2008-09-23T23:23:17.470+0000","updated":"2008-09-23T23:23:17.470+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12634137","id":"12634137","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Bryan, thank you so much. I can see that you spent lot of your time to analyze this issue. I will look through your comment further and use the information to debug this jira entry more.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2008-09-24T13:31:10.583+0000","updated":"2008-09-24T13:31:10.583+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12634288","id":"12634288","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"Thanks Mamta for the kind words, they are much appreciated. I had\r\nanother thought I wanted to share:\r\n\r\nI think that in the code in SelectNode.preprocess, the (havingClause == null)\r\ncheck is correct, and should be present, for the reasons that I mentioned\r\nin the previous comment.\r\n\r\nBut it occurs to me that perhaps the bug is that (havingClause == null)\r\nis missing from some *other* location in the code, and should have\r\nbeen added as part of DERBY-681; it could have been overlooked for\r\nthe reasons that Knut mentioned earlier.\r\n\r\nSo it might be worth searching around through the compiler and optimizer\r\ncode, to see if there are any other places where we have an \"if\" statement like:\r\n\r\n   if (groupByList != null &&  selectAggregates.size() == 0 && whereAggregates.size() == 0) \r\n\r\nand, if you find such code, consider whether possibly (havingClause == null)\r\nshould be added there as well.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2008-09-24T20:46:23.305+0000","updated":"2008-09-24T20:46:23.305+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12635443","id":"12635443","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I have spent more time on the execution side of the query in question to see why exactly we are running into NPE and following is what I found. At the high level, when a query is executed at the JDBC layer, Derby execution code goes through opening the language resultsets associated with the query. This code is in the method open() for the topmost language resultset and for all the language resultsets underneath the topmost resultset, openCore() method gets called. When the user natigates throught the JDBC resultset after the query execution, Derby execution code goes through getNextRow() method for the topmost language resultset and getNextRowCore() method for the resultsets underneath the topmost resultset. There are some exceptions in Derby code where the row fetching on the resultsets happen during the query execution (ie even before the user has requested say \"next\" on the JDBC resultset). One such example is when we have GroupedAggregateRS which has it's isInSortedOrder flag set to true. In this specific query, this flag is set to true indicating a performance optimization to avoid sorting and this pre-fetching of the rows at the time of JDBC query execution is resulting in NPE. More detailed information below.\r\n\r\nIn the following discussion \r\n\tRS stands for generated language resultset.\r\n\tPRS stands for ProjectRestrictedRS.\r\n\tRSN stands for resultset number associated with the RS.\r\n\tLeftRS stands for left RS.\r\n\tRightRS stands for right RS.\r\n\r\nThe query in question which results in NPE is as follows\r\nselect q1.\"DEPTNO\" from DEPTTAB q1, EMPTAB q2 -- DERBY-PROPERTIES joinStrategy = HASH \r\nwhere ( q2.\"DEPT_DEPTNO\" = q1.\"DEPTNO\") \r\nGROUP BY q1.\"DEPTNO\" HAVING 1 = \r\n  ( select q3.\"SALARY\" from EMPTAB q3 where ( q3.\"EMPID\" = q1.\"DEPTNO\") ); \r\n\r\n\r\nThe topmost generated RS for the entire query is a PRS(RSN = 6) and the source for this topmost PRS is GroupedAggregateRS (RSN = 1). The topmost PRS has restriction associated with it. The restriction handles just the HAVING clause of the query. The rest of the query (before the HAVING clause) is handled through GroupedAggregateRS (RSN = 1).\r\n\r\nTo be specific, GroupedAggregateRS (RSN=1) covers the following part of the query\r\nselect q1.\"DEPTNO\" from DEPTTAB q1, EMPTAB q2 -- DERBY-PROPERTIES joinStrategy = HASH \r\nwhere ( q2.\"DEPT_DEPTNO\" = q1.\"DEPTNO\") \r\nGROUP BY q1.\"DEPTNO\" \r\nThe generated RSs for this part of the query look as follows\r\n   The topmost generated RS for the entire query is a PRS(RSN = 6)\r\n\tThe source for PRS is GroupedAggregateRS (RSN = 1)\r\n\t\tThe source for GroupedAggregateRS is PRS (RSN = 5)\r\n\t\t\tThe source for PRS is HashJoinRS (RSN = 2)\r\n\t\t\t\tLeftRS is BulkTableScanRS (RSN = 3) DEPTTAB q1***\r\n\t\t\t\tRightRS is HashScanRS (RSN = 4) EMPTAB q2 ***Has qualifier associated with it.\r\n\r\nThe remaining part of the query as shown below is covered by the \"restriction\" field in PRS (RSN=6)\r\nHAVING 1 = ( select q3.\"SALARY\" from EMPTAB q3 where ( q3.\"EMPID\" = q1.\"DEPTNO\") ); \r\nThe generated RSs for the \"restriction\" on PRS (RSN=6) looks as follows\r\n  The topmost RS for 2nd part of query is OnceRS (RSN = 10)\r\n     The source for OnceRS is PRS (RSN = 9)\r\n        The source for PRS is IndexRowToBaseRowRS (RSN = 7) for EMPTAB q3\r\n           The source for IndexRowToBaseRowRS is TableScanRS (RSN = 8)**has startKeyGetter associated with it.\r\n\r\nWhen the query is executed from JDBC layer (say using PreparedStatement.execute), we start by calling the open() method (which calls openCore) on the topmost RS which is PRS (RSN=6). On all the subsequent RSs underneath the topmost RS, we will be calling the openCore() method. The openCore method on PRS (RSN=6) calls the openCore method on GroupedAggregateRS(RSN=1) which calls openCore on PRS (RSN=5) which makes a call to openCore on HashJoinRS(RSN=2). The **interesting thing here is** HashJoinRS calls openCore on the leftRS and then it **gets the next row on that leftRS**. This results in call to BulkTableScanRS(RSN=3).getNextRowCore The row that is obtained here is set as the current row for this RS in the activation object. So, the current rows for various RSs in activation object at this point looks as follows\r\n[null, null, null, { 1 }, null, null, null, null, null, null, null]\r\n\r\nThen the openCore method on HashJoinRS(RSN=2) calls openCore method on the rightRS(RSN=4) which is a HashScanRS. HashScanRS in it's openCore method deals with the qualifiers associated with it. In this particular query, the qualifier code looks at the current row associated with the leftRS in the activation object. The call to look at current row for leftRS in activation object happens in BaseActivation.getColumnFromRow(int, int) line: 1419\t\r\nOnce this work is done for the rightRS(RSN=4), the control goes back to openCore in GroupedAggregateRS (RSN=1). We check if isInSortedOrder is set to true for GroupedAggregateRS which in this particular case is set to true. Because of that, we execute following piece of code\r\n\tif (isInSortedOrder)\r\n\t{\r\n\t\tcurrSortedRow = getNextRowFromRS();\r\n\t\tif (currSortedRow != null)\r\n\t\t{\r\n\t\t\tcurrSortedRow = (ExecIndexRow) currSortedRow.getClone();\r\n\t\t\tinitializeVectorAggregation(currSortedRow);\r\n\t\t}\r\n\t}\r\nNotice that the above piece of code is causing us to start getting rows from the resultset even before the JDBC user has requested a next on the JDBC ResultSet. The code above causes us to get next row in HashJoinRS rightRS(RSN=4) because we have already gotten the next row on the leftRS earlier. Once we have the current row for HashJoinRS, we set it as the current row for this RS in the activation object. So, the current rows for various RSs in activation object at this point looks as follows \r\n[null, null, null, { 1 }, { 1 }, null, null, null, null, null, null]\r\n\r\nNow that we have the current row for the leftRS and the rightRS, we merge the 2 rows and establish the current row for HashJoinRS(RSN=2) and once again, we set this current row for HashJoinRS in the activation object. So, the current rows for various RSs in activation object at this point looks as follows\r\n[null, null, { 1, 1 }, { 1 }, { 1 }, null, null, null, null, null, null]\r\n\r\nNext, we set the current row of the PRS(RSN=5) and the current rows for various RSs in activation object at this point looks as follows\r\n[null, null, { 1, 1 }, { 1 }, { 1 }, { 1 }, null, null, null, null, null]\r\n\r\nOnce the current rows for various RSs associated with GroupedAggregateRS and RSs underneath are set, the openCore processing is over. We do not set the current row for the GroupedAggregateRS in openCore, it wil lbe done when the JDBC user invokes next on the JDBC resultset. The code associated with HAVING clause also gets run when the JDBC user requests next on the JDBC ResultSet. The code path for that next request is described below and that is where we run into NPE. \r\n\r\nAll the language RSs have methods called getNextRow() and getNextRowCore(). getNextRow() gets called only on the topmost RS. getNextRowCore() gets called on RSs underneath the topmost RS. We start out with following code flow\r\n\tPRN(RSN=6).getNextRow\r\n\t  PRN(RSN=6).getNextRowCore\r\n\t    GroupedAggregateRS(RSN=1).getNextRowCore\r\n\t      PRN(RSN=5).getNextRowCore\r\n\t        HashJoinRS(RSN=2).getNextRowCore\r\n\t          rightRS which is HashScanRS(RSN=4).getNextRowCore\r\n\r\nThere are no more rows in EMPTAB this time which is what HashScanRS (RSN=4) is dealing with and hence the current row for it will be null and it will set to that in the activation object as well as shown below.\r\n[null, null, { 1, 1 }, { 1 }, null, { 1 }, null, null, null, null, null]\r\nSince there is no row on the rightRS, we check if there is a row on the leftRS(BulkTableScanRS (RSN=3)). There is no row in the leftRS also. We mark it so in the activation object.\r\n[null, null, { 1, 1 }, null, null, { 1 }, null, null, null, null, null]\r\n\r\nAbsence of row on the leftRS results in closing the rightRS. Also, since there is no row on the leftRS and rightRS, we clear the current row for the HashJoinRS and also mark current row null for it in the activation object as shown below.\r\n[null, null, null, null, null, { 1 }, null, null, null, null, null]\r\nThis current row null setting goes up to PRS(RSN=5) which is on top of HashJoinRS as shown below\r\n[null, null, null, null, null, null, null, null, null, null, null]\r\nGroupedAggreateRS.getNextRowCore code sees that there are no more rows that could be used aggregation and hence it settles with the row prior to finding the null row. The activation object reflects that as follows\r\n[null, { 1 }, null, null, null, null, null, null, null, null, null]\r\n\r\nAt this point, the only RS that has a current row set on it is the GroupedAggregateRS and control of the code at this point is in the topmost RS PRS(RSN=6) \r\n\tProjectRestrictResultSet.getNextRowCore() line: 266\r\nHere we check if there is any restriction associated with this PRS and in this particular query, the HAVING clause is implemented as the restriction on the PRS. We first set the current row for this PRS to be what we got from the GroupedAggregateRS and next we will apply restriction to that row. The activation object looks as follows\r\n[null, { 1 }, null, null, null, null, { 1 }, null, null, null, null]\r\nThe code for applying the restriction is as follows in PRS.getNextRowCore() line: 267\r\n            restrictBoolean = (DataValueDescriptor) \r\n\t\t\trestriction.invoke(activation);\r\nThe execution of the code above causes us the create the RSs associated with the HAVING clause which are as follows\t\r\nThe topmost RS for 2nd part of query is OnceRS (RSN = 10)\r\n  The source for OnceRS is PRS (RSN = 9)\r\n    The source for PRS is IndexRowToBaseRowRS (RSN = 7) for EMPTAB q3\r\n      The source for IndexRowToBaseRowRS is TableScanRS (RSN = 8)**has startKeyGetter associated with it.\r\n\r\nWe go through the process of opening each one of these RSs by calling the openCore methods on them. The NullPointerException happens when we are opening the TableScanRS(RSN=8) which has startKeyGetter associated with it. We try to find the startPosition using the startKeyGetter as shown below\r\n\t\tif (startKeyGetter != null)\r\n\t\t{\r\n\t\t\tstartPosition = (ExecIndexRow) startKeyGetter.invoke(activation);\r\n\t\t\tif (sameStartStopPosition)\r\n\t\t\t{\r\n\t\t\t\tstopPosition = startPosition;\r\n\t\t\t}\r\n\t\t}\r\nThe startKeyGetter.invoke causes us to look at the current row of the RSN=3 which is the RS associated with the BulkTableScanRS for \"DEPTTAB q1\" but since the current row for it in activation object has been set to null, we run into NPE. \r\nThread [main] (Suspended (breakpoint at line 1419 in BaseActivation))\t\r\n\tacf81e0010x011cxa07fxbcfex0000003f01400(BaseActivation).getColumnFromRow(int, int) line: 1419\t\r\n\tacf81e0010x011cxa07fxbcfex0000003f01400.e6() line: not available\t\r\n\tDirectCall.invoke(Object) line: 151\t\r\n\tTableScanResultSet.openCore() line: 250\t\r\n\tIndexRowToBaseRowResultSet.openCore() line: 202\t\r\n\tProjectRestrictResultSet.openCore() line: 168\t\r\n\tOnceResultSet.openCore() line: 119\t\r\n\tacf81e0010x011cxa07fxbcfex0000003f01400.g0() line: not available [local variables unavailable]\t\r\n\tacf81e0010x011cxa07fxbcfex0000003f01400.e4() line: not available\t\r\n\tDirectCall.invoke(Object) line: 147\t\r\n\tProjectRestrictResultSet.getNextRowCore() line: 267\t\r\n\tProjectRestrictResultSet(BasicNoPutResultSetImpl).getNextRow() line: 460\t\r\n\tEmbedResultSet40(EmbedResultSet).movePosition(int, int, String) line: 423\t\r\n\tJDBCDisplayUtil.indent_DisplayResults(PrintWriter, ResultSet, Connection, int, int[], int[]) line: 338\t\r\n\tJDBCDisplayUtil.DisplayResults(PrintWriter, Statement, Connection) line: 229\t\r\n\tutilMain.doCatch(String) line: 509\t\r\n\tJDBCDisplayUtil.indent_DisplayResults(PrintWriter, Statement, Connection, int, int[], int[]) line: 241\t\r\n\tJDBCDisplayUtil.DisplayResults(PrintWriter, Statement, Connection) line: 229\t\r\n\tutilMain.displayResult(LocalizedOutput, ijResult, Connection) line: 435\t\r\n\tutilMain.go(LocalizedInput[], LocalizedOutput, Properties) line: 248\t\r\n\tutilMain.runScriptGuts() line: 350\t\r\n\tMain.mainCore(String[], Main) line: 181\t\r\n\tMain.go(LocalizedInput, LocalizedOutput, Properties) line: 215\t\r\n\tMain.mainCore(String[], Main) line: 181\t\r\n\tMain.main(String[]) line: 73\t\r\n\tij.main(String[]) line: 59\t\r\n\r\nNow, that I understand what is causing the NPE to happen, the next step is to figure out should the current row for the RS for DEPTTAB be null at this point when we know from the query that it needs to be available for us to enforce HAVING clause.\r\n\r\nI realize that this is a very long comment but I wanted to share the code flow during the query execution to pinpoint what is exactly happening. \r\n\r\nAs always, will appreciate any insight in understanding should the row which is needed to enforce the HAVING clause be null. Is the issue with code generation where we are trying to avoid sorting when the rows used for sorting are actually needed for the HAVING clause enforcement.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2008-09-29T16:52:25.259+0000","updated":"2008-09-29T16:52:25.259+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12635496","id":"12635496","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Also, I thought I should mention that I do not think the test case (the query which causes NPE) can be made any easier because we have to ensure that we have a group by which will be converted into an aggregate and we have to have a HAVING clause which is referencing the same table as the one in the outer query because the group by sort avoidance is going to make the table from outer query position itself on a null row which will in turn make having clause fail because it didn't expect to find a null row for that table.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2008-09-29T19:19:56.109+0000","updated":"2008-09-29T19:19:56.109+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12635564","id":"12635564","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"Hi Mamta ,thanks for the wonderful writeup! \r\n\r\n> The startKeyGetter.invoke causes us to look at the current row of the \r\n> RSN=3 which is the RS associated with the BulkTableScanRS for \"DEPTTAB q1\"\r\n\r\nThis seems incorrect to me; it seems like the startKeyGetter in the RSN 8\r\nshould be pointing to result set #1, not to result set #3.\r\n\r\nThis might be the sort of thing that would work in most queries by accident,\r\nbut would fail in your particular case because everything lined up just right.\r\n\r\nCan you step through the code generation for the HAVING clause\r\nsub-tree, and see where the startKeyGetter is getting its RSN from? Perhaps\r\nthere is some missing code that should have run when we were generating\r\nthe GroupBy result set (#5) and its parent PRN result set (#1) which should\r\nhave re-numbered the startKeyGetter result set reference in the having clause?\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2008-09-29T22:38:02.790+0000","updated":"2008-09-29T22:38:02.790+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12637536","id":"12637536","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I did code walk through during the code generation phase of the above query. Different resultsets and columns get their RSNs assigned to them during the code generation phase.\r\n\r\nThe stack trace below shows when the column belonging to HAVING clause indirectly gets the RSN 3 assigned to it.\r\nThread [main] (Suspended (breakpoint at line 413 in ResultColumn))\t\r\n\tResultColumn.setResultSetNumber(int) line: 413\t\r\n\tResultColumnList.setResultSetNumber(int) line: 2141\t\r\n\tFromBaseTable(ResultSetNode).assignResultSetNumber() line: 213\t\r\n\tFromBaseTable.generateResultSet(ExpressionClassBuilder, MethodBuilder) line: 3098\t\r\n\tFromBaseTable.generate(ActivationClassBuilder, MethodBuilder) line: 3065\t\r\n\tProjectRestrictNode.generateMinion(ExpressionClassBuilder, MethodBuilder, boolean) line: 1385\t\r\n\tProjectRestrictNode.generate(ActivationClassBuilder, MethodBuilder) line: 1336\t\r\n\tJoinNode.getJoinArguments(ActivationClassBuilder, MethodBuilder, ValueNode) line: 1577\t\r\n\tJoinNode.generateCore(ActivationClassBuilder, MethodBuilder, int, ValueNode, SubqueryList) line: 1555\t\r\n\tJoinNode.generate(ActivationClassBuilder, MethodBuilder) line: 1479\t\r\n\tProjectRestrictNode.generateMinion(ExpressionClassBuilder, MethodBuilder, boolean) line: 1472\t\r\n\tProjectRestrictNode.generate(ActivationClassBuilder, MethodBuilder) line: 1336\t\r\n\tGroupByNode.generate(ActivationClassBuilder, MethodBuilder) line: 1013\t\r\n\tProjectRestrictNode.generateMinion(ExpressionClassBuilder, MethodBuilder, boolean) line: 1472\t\r\n\tProjectRestrictNode.generate(ActivationClassBuilder, MethodBuilder) line: 1336\t\r\n\tScrollInsensitiveResultSetNode.generate(ActivationClassBuilder, MethodBuilder) line: 109\t\r\n\tCursorNode.generate(ActivationClassBuilder, MethodBuilder) line: 564\t\r\n\tCursorNode(StatementNode).generate(ByteArray) line: 347\t\r\n\tGenericStatement.prepMinion(LanguageConnectionContext, boolean, Object[], SchemaDescriptor, boolean) line: 447\t\r\n\tGenericStatement.prepare(LanguageConnectionContext, boolean) line: 88\t\r\n\tGenericLanguageConnectionContext.prepareInternalStatement(SchemaDescriptor, String, boolean, boolean) line: 796\t\r\n\tEmbedStatement40(EmbedStatement).execute(String, boolean, boolean, int, int[], String[]) line: 606\t\r\n\tEmbedStatement40(EmbedStatement).execute(String) line: 555\t\r\n\tij.executeImmediate(String) line: 329\t\r\n\tutilMain.doCatch(String) line: 508\t\r\n\tutilMain.runScriptGuts() line: 350\t\r\n\tutilMain.go(LocalizedInput[], LocalizedOutput, Properties) line: 248\t\r\n\tMain.go(LocalizedInput, LocalizedOutput, Properties) line: 215\t\r\n\tMain.mainCore(String[], Main) line: 181\t\r\n\tMain.main(String[]) line: 73\t\r\n\tij.main(String[]) line: 59\t\r\n\r\nThe stack trace above is handling the first part of the use query(the first part is shown below)\r\nselect q1.\"DEPTNO\" from DEPTTAB q1, EMPTAB q2 -- DERBY-PROPERTIES joinStrategy = HASH \r\nwhere ( q2.\"DEPT_DEPTNO\" = q1.\"DEPTNO\") \r\nGROUP BY q1.\"DEPTNO\" \r\nNote that we are not dealing with the HAVING clause at all at this point in the stack trace but the problem arises from the fact that the ResultColumn associated with the HAVING clause is the same object that is associated with the join node. Because of that, even though we are setting the RSN number 3 for the join node column, the ResultColumn associated with the HAVING clause ends up getting the same RSN 3 associated with it. I have tried to show below how different language ResultSet and column objects are associated with the entire user query\r\nthis\torg.apache.derby.impl.sql.compile.ProjectRestrictNode  (id=192)\t\r\n   childResult\torg.apache.derby.impl.sql.compile.GroupByNode  (id=156)\t\r\n      childResult\torg.apache.derby.impl.sql.compile.ProjectRestrictNode  (id=151)\t\r\n         childResult\torg.apache.derby.impl.sql.compile.JoinNode  (id=221)\t\r\n            leftResultSet\torg.apache.derby.impl.sql.compile.ProjectRestrictNode  (id=233)\t\r\n               childResult\torg.apache.derby.impl.sql.compile.FromBaseTable  (id=241)\t\r\n                  resultColumns\torg.apache.derby.impl.sql.compile.ResultColumnList  (id=317)\t\r\n                     v\tjava.util.Vector<E>  (id=2084)\t\r\n                        elementCount\t1\t\r\n                        elementData\tjava.lang.Object[10]  (id=2089)\t\r\n                           [0]\torg.apache.derby.impl.sql.compile.ResultColumn  (id=218)\t\r\n   restriction\torg.apache.derby.impl.sql.compile.AndNode  (id=98)\t\r\n      leftOperand\torg.apache.derby.impl.sql.compile.BinaryRelationalOperatorNode  (id=85)\t\r\n         rightOperand\torg.apache.derby.impl.sql.compile.SubqueryNode  (id=93)\t\r\n            resultSet\torg.apache.derby.impl.sql.compile.ProjectRestrictNode  (id=135)\t\r\n               childResult\torg.apache.derby.impl.sql.compile.ProjectRestrictNode  (id=121)\t\r\n                  childResult\torg.apache.derby.impl.sql.compile.IndexToBaseRowNode  (id=193)\t\r\n                     source\torg.apache.derby.impl.sql.compile.FromBaseTable  (id=195)\t\r\n                        restrictionList\torg.apache.derby.impl.sql.compile.PredicateList  (id=196)\t\r\n                           v\tjava.util.Vector<E>  (id=198)\t\r\n                              elementCount\t1\t\r\n                              elementData\tjava.lang.Object[10]  (id=200)\t\r\n                                 [0]\torg.apache.derby.impl.sql.compile.Predicate  (id=212)\t\r\n                                    andNode\torg.apache.derby.impl.sql.compile.AndNode  (id=120)\t\r\n                                       leftOperand\torg.apache.derby.impl.sql.compile.BinaryRelationalOperatorNode  (id=89)\t\r\n                                          rightOperand\torg.apache.derby.impl.sql.compile.ColumnReference  (id=124)\t\r\n                                             columnName\t\"DEPTNO\"\t\r\n                                             source\torg.apache.derby.impl.sql.compile.ResultColumn  (id=218)\t\t\r\n\r\nIn the object association above, if you search for string id=218, you will find that ResultColumn object with id=218 is hanging off the SubqueryNode as well as the JoinNode. I think this is the cause of the problem. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2008-10-07T16:30:25.279+0000","updated":"2008-10-07T16:30:25.279+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12637563","id":"12637563","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"> the ResultColumn associated with the HAVING clause is the same object that is associated with the join node\r\n\r\nExcellent work! I think this is a great theory, and makes a lot of sense.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2008-10-07T17:47:35.097+0000","updated":"2008-10-07T17:47:35.097+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12637586","id":"12637586","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Following is where we end up generating the code for HAVING clause which uses RSN 3 for the DEPTNO column\r\nThread [main] (Suspended)\t\r\n\tColumnReference.generateExpression(ExpressionClassBuilder, MethodBuilder) line: 920\t\r\n\tBinaryRelationalOperatorNode.generateExpressionOperand(Optimizable, int, ExpressionClassBuilder, MethodBuilder) line: 496\t\r\n\tPredicate.generateExpressionOperand(Optimizable, int, ExpressionClassBuilder, MethodBuilder) line: 670\t\r\n\tPredicateList.generateSetColumn(ExpressionClassBuilder, MethodBuilder, int, Predicate, Optimizable, LocalField, boolean) line: 3524\t\r\n\tPredicateList.generateStartKey(ExpressionClassBuilderInterface, MethodBuilder, Optimizable) line: 3348\t\r\n\tNestedLoopJoinStrategy(BaseJoinStrategy).fillInScanArgs1(TransactionController, MethodBuilder, Optimizable, OptimizablePredicateList, ExpressionClassBuilderInterface, MethodBuilder) line: 109\t\r\n\tNestedLoopJoinStrategy.getScanArgs(TransactionController, MethodBuilder, Optimizable, OptimizablePredicateList, OptimizablePredicateList, ExpressionClassBuilderInterface, int, MethodBuilder, int, int, int, boolean, int, int, boolean) line: 248\t\r\n\tFromBaseTable.getScanArguments(ExpressionClassBuilder, MethodBuilder) line: 3448\t\r\n\tFromBaseTable.generateResultSet(ExpressionClassBuilder, MethodBuilder) line: 3138\t\r\n\tFromBaseTable.generate(ActivationClassBuilder, MethodBuilder) line: 3065\t\r\n\tIndexToBaseRowNode.generate(ActivationClassBuilder, MethodBuilder) line: 234\t\r\n\tProjectRestrictNode.generateMinion(ExpressionClassBuilder, MethodBuilder, boolean) line: 1385\t\r\n\tProjectRestrictNode.generate(ActivationClassBuilder, MethodBuilder) line: 1336\t\r\n\tProjectRestrictNode.generateMinion(ExpressionClassBuilder, MethodBuilder, boolean) line: 1472\t\r\n\tProjectRestrictNode.generate(ActivationClassBuilder, MethodBuilder) line: 1336\t\r\n\tSubqueryNode.generateExpression(ExpressionClassBuilder, MethodBuilder) line: 1879\t\r\n\tBinaryRelationalOperatorNode(BinaryOperatorNode).generateExpression(ExpressionClassBuilder, MethodBuilder) line: 590\t\r\n\tAndNode(BinaryLogicalOperatorNode).generateExpression(ExpressionClassBuilder, MethodBuilder) line: 157\t\r\n\tProjectRestrictNode.generateMinion(ExpressionClassBuilder, MethodBuilder, boolean) line: 1516\t\r\n\tProjectRestrictNode.generate(ActivationClassBuilder, MethodBuilder) line: 1336\t\r\n\tScrollInsensitiveResultSetNode.generate(ActivationClassBuilder, MethodBuilder) line: 109\t\r\n\tCursorNode.generate(ActivationClassBuilder, MethodBuilder) line: 564\t\r\n\tCursorNode(StatementNode).generate(ByteArray) line: 347\t\r\n\tGenericStatement.prepMinion(LanguageConnectionContext, boolean, Object[], SchemaDescriptor, boolean) line: 447\t\r\n\tGenericStatement.prepare(LanguageConnectionContext, boolean) line: 88\t\r\n\tGenericLanguageConnectionContext.prepareInternalStatement(SchemaDescriptor, String, boolean, boolean) line: 796\t\r\n\tEmbedStatement40(EmbedStatement).execute(String, boolean, boolean, int, int[], String[]) line: 606\t\r\n\tEmbedStatement40(EmbedStatement).execute(String) line: 555\t\r\n\tij.executeImmediate(String) line: 329\t\r\n\tutilMain.doCatch(String) line: 508\t\r\n\tutilMain.runScriptGuts() line: 350\t\r\n\tutilMain.go(LocalizedInput[], LocalizedOutput, Properties) line: 248\t\r\n\tMain.go(LocalizedInput, LocalizedOutput, Properties) line: 215\t\r\n\tMain.mainCore(String[], Main) line: 181\t\r\n\tMain.main(String[]) line: 73\t\r\n\tij.main(String[]) line: 59\t\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2008-10-07T18:27:36.990+0000","updated":"2008-10-07T18:27:36.990+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12638026","id":"12638026","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Just wanted to summarize in brief my findings on this jira entry.\r\n\r\nThe main thing to notice about the query below is that derby engine identifies it to be the kind which can fall into sort avoidance code. \r\nconnect 'jdbc:derby:c:/dellater/db1;create=true';\r\nselect q1.\"DEPTNO\" from DEPTTAB q1, EMPTAB q2 -- DERBY-PROPERTIES joinStrategy = HASH \r\nwhere ( q2.\"DEPT_DEPTNO\" = q1.\"DEPTNO\") \r\nGROUP BY q1.\"DEPTNO\" HAVING 1 = \r\n  ( select q3.\"SALARY\" from EMPTAB q3 where ( q3.\"EMPID\" = q1.\"DEPTNO\") ); \r\n\r\nThis query is internally dealt in two parts, First one is the\r\nselect q1.\"DEPTNO\" from DEPTTAB q1, EMPTAB q2 -- DERBY-PROPERTIES joinStrategy = HASH \r\nwhere ( q2.\"DEPT_DEPTNO\" = q1.\"DEPTNO\") \r\nGROUP BY q1.\"DEPTNO\" \r\nand the second part is\r\nHAVING 1 = \r\n  ( select q3.\"SALARY\" from EMPTAB q3 where ( q3.\"EMPID\" = q1.\"DEPTNO\") ); \r\n\r\nSince the query qualifies for sort avoidance, Derby scans through the rows in the DEPTTAB and EMPTAB to do our own sorting and this leaves us with current row for DEPTTAB and EMPTAB to be nulls. Once we find the row for the first part of the query, Derby enforces the HAVING clause of the query as a restriction on the row returned from the first query. During the application of the restriction, q1.\"DEPTNO\" in HAVING clause has Derby look at the current row for DEPTTAB but since it is null, we end up getting null pointer exception. If I comment out the sort avoidance detection in the compile phase of the query, we do not run into NPE.\r\n\r\nHope this summary is useful in understanding why we are running into NPE. I have to say that I do not have lot of ideas at this point as to how to solve the NPE. I will keep poking into the code but if anyone has any pointers/ideas, I can definitely use them.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2008-10-08T18:41:26.801+0000","updated":"2008-10-08T18:41:26.801+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12638190","id":"12638190","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"> Just wanted to summarize in brief my findings on this jira entry. \r\n\r\nThanks for all of the *great* information on this one, Mamta!  I spent some time looking at this and your detailed comments were extremely useful in helping me get up to speed.\r\n\r\n> if anyone has any pointers/ideas, I can definitely use them.\r\n\r\nI did some tracing based on your earlier observation that \"the ResultColumn associated with the HAVING clause is the same object that is associated with the join node\".  When comparing a successful query with an unsuccessful one, I noticed that in *both* cases the HAVING clause includes a pointer to a ResultColumn that is also referenced by the JoinNode. So that in itself is not necessarily a problem.\r\n\r\nHowever, it turns out that for the successful query, the ResultColumn reference in question is *buried* beneath a chain of VirtualColumn-to-ResultColumn nodes that exist on the right side of the equality (q3.\"EMPID\" = q1.\"DEPTNO\") in the HAVING subquery.  In the failing query, though, the ResultColumn reference is the immediate child of a ColumnReference that is the right side of the equality--there are no intervening VirtualColumn nodes nor any other ResultColumns.\r\n\r\nI think what this means is that, in the failing query, when we set the result set number for the ResultColumns associated with the JoinNode, that result set number inadvertently gets picked up by the equality in the HAVING subquery, which ultimately leads to the NPE, as you discovered.  For the successful query, though, the intervening VirtualColumnNodes and ResultColumns have their *own* (correct) result set numbers, and those effectively \"hide\" the result set number that was set from the JoinNode.\r\n\r\nThat said, I did some tracing to try to find out where the intervening VirtualColumnNodes come from in the successful query.  It turns out that GroupByNode.addUnAggColumns() creates the nodes, and then it uses a Visitor implementation to \"substitute\" those nodes into the query tree at the right place(s).  For a successful query the Visitor performs the substitution in the base table, as it should; but for the failing query, the substitution never happens.  Upon further investigation I noticed that the failing query includes an IndexToBaseRowNode whose child is a FromBaseTable, while the successful query simply includes a FromBaseTable directly.  With that difference in mind I set a breakpoint in the \"addUnAggColumns()\" method at the line:\r\n\r\n%    havingClause.accept(\r\n%        (SubstituteExpressionVisitor)havingRefsToSubstitute.get(r));\r\n\r\nand traced from there.  One thing I quickly noticed was that the IndexToBaseRowNode class does *not* define an \"accept()\" method, which means it defaults to the \"accept()\" method of ResultSetNode.  That's a problem because ResultSetNode does not know about the FromBaseTable child that exists beneath IndexToBaseRowNode--so ResultSetNode.accept() correctly visits the IndexToBaseRowNode itself, but does *NOT* visit the underlying FromBaseTable.  As luck would have it, the substitution that the code in addUnAggColumns() is trying to make is intended for the FromBaseTable (and esp. for the \"restriction\" predicate that is contained within it), but since that node is never visited, the substitution never happens.\r\n\r\nAs an experiment I added an \"accept()\" method to IndexToBaseRowNode.java that was almost identical to the method as it exists today in SingleChildResultSetNode--I just changed \"childResult\" to \"source\" and that was it.  When I did that, I could see the substitution in addUnAggColumns() start to take effect for the failing query, which led to insertion of what appear to be the proper VirtualColumn nodes beneath the HAVING subquery's predicate, and in the end, the query ran to completion with no error.\r\n\r\nI didn't do *any* other testing of any sort, nor have I looked at the possible side effects of adding an accept() method to IndexToBaseRowNode (I can't think of any offhand).  But at first glance it seems like the \"right\" thing to do, and it made the repro for this issue run without error, so if you're looking for a \"what next\" step, you could perhaps investigate that angle a bit more...?\r\n\r\nThanks again for your work continued efforts on this issue!","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2008-10-09T05:55:57.871+0000","updated":"2008-10-09T06:02:21.221+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12638354","id":"12638354","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"Army, your analysis makes a lot of sense to me. Having a breakage\r\nin the addUnAggColumns visitor processing seems like it explains\r\nthe failure very nicely, and is the right way to fix it. Based on your\r\ndescription, I constructed the attached 'armysFix.diff' and I\r\nsuccessfully ran a complete set of regression tests without any errors.\r\n\r\nSo the change appears at least to do no harm (and, as I said above,\r\nfeels like a proper fix to me). It seems worth pursuing this fix as\r\na potential solution to the problem (with regression tests, etc.)","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2008-10-09T18:22:40.611+0000","updated":"2008-10-09T18:22:40.611+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12638677","id":"12638677","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"> I constructed the attached 'armysFix.diff' and I successfully ran a\r\n> complete set of regression tests without any errors.\r\n\r\nThanks much for verifying, Bryan!","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2008-10-10T23:19:15.988+0000","updated":"2008-10-10T23:19:15.988+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12639125","id":"12639125","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Sorry, I was out towards the end of last week and so couldn't respond sooner. Thanks a bunch Army and Bryan. Seems like we have definitely found a solution. I will apply the patch armysFix.diff and run all the junit and derbyall tests on my machine and commit the patch in next couple days. Thanks again for all your help.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2008-10-13T17:27:06.619+0000","updated":"2008-10-13T17:27:06.619+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12639146","id":"12639146","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"If you have time, I think it would be nice to improve the patch by including\r\nsome regression tests based on the repro scripts that you and Kathey isolated. \r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2008-10-13T18:14:33.598+0000","updated":"2008-10-13T18:14:33.598+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12639154","id":"12639154","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Yes, I will plan on incorporating the test case into the patch. Thanks.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2008-10-13T18:26:43.494+0000","updated":"2008-10-13T18:26:43.494+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12639959","id":"12639959","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Committed the fix for this jira entry into trunk with revision 705037 with following commit comments.\r\n\r\nDERBY-3872\r\n\r\nThe NPE in this jira entry was caused by the missing overwrite of accept() method in IndexToBaseRowNode.\r\nBecause of the missing code, the additional layer of VirtualColumn node over ResultColumn was not \r\nhappening for the where clause in HAVING. Once the accept method was added to IndexToBaseRowNode, the\r\nVirtualColumn on top of the ResultColumn got the correct resultset number associated with it and at the\r\ncode generation time, we start referencing the correct resultset rather than the one associated with\r\nthe JOIN clause. Thanks a ton to Army and Bryan on this jira entry for their help.\r\n\r\nI have added a test case for this in lang/GroupByTest.java","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2008-10-15T20:46:27.769+0000","updated":"2008-10-15T20:46:27.769+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12640558","id":"12640558","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Merged 705037 into 10.3 codeline. The changes went into 10.3 codeline as part of revision 705660. Will work on merging them into 10.4 codeline next.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2008-10-17T16:14:13.525+0000","updated":"2008-10-17T16:14:13.525+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12404026/comment/12643123","id":"12643123","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Merged 705037 into 10.4 codeline. The changes went into 10.4 codeline as part of revision 708426. \r\n\r\nWill close this jira entry now that the changes are in all the codelines since the bug was introduced.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2008-10-28T04:25:41.006+0000","updated":"2008-10-28T04:25:41.006+0000"}]},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-3872/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i06qr3:"}}