{"expand":"renderedFields,names,schema,transitions,operations,editmeta,changelog","id":"12383938","self":"https://issues.apache.org/jira/rest/api/latest/issue/12383938","key":"DERBY-3253","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/10594","id":"10594","key":"DERBY","name":"Derby","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=10594&avatarId=10122","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=10594&avatarId=10122","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=10594&avatarId=10122","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=10594&avatarId=10122"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10090","id":"10090","description":"DB related projects","name":"DB"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12313142","id":"12313142","description":"","name":"10.3.3.0","archived":false,"released":true,"releaseDate":"2008-05-12"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12313111","id":"12313111","description":"","name":"10.4.1.3","archived":false,"released":true,"releaseDate":"2008-04-24"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12310220":"2007-12-05 16:38:47.177","customfield_12312322":null,"customfield_12312323":null,"customfield_12310420":"23525","customfield_12310222":"1_*:*_1_*:*_1262765419_*|*_6_*:*_1_*:*_0_*|*_5_*:*_1_*:*_3132180868","customfield_12312320":null,"customfield_12312321":null,"customfield_12312120":null,"customfield_12312121":null,"resolutiondate":"2007-12-19T17:04:57.381+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312326":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312324":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-3253/watchers","watchCount":1,"isWatching":false},"created":"2007-12-05T02:18:51.962+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12312334":null,"customfield_12310310":"4.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12312590","id":"12312590","description":"","name":"10.3.1.4","archived":false,"released":true,"releaseDate":"2007-08-10"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12312876","id":"12312876","description":"","name":"10.3.2.1","archived":false,"released":true,"releaseDate":"2007-12-10"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12313111","id":"12313111","description":"","name":"10.4.1.3","archived":false,"released":true,"releaseDate":"2008-04-24"}],"customfield_12311120":null,"customfield_12312330":null,"issuelinks":[{"id":"12320149","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12320149","type":{"id":"12310000","name":"Duplicate","inward":"is duplicated by","outward":"duplicates","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/12310000"},"inwardIssue":{"id":"12389532","key":"DERBY-3464","self":"https://issues.apache.org/jira/rest/api/2/issue/12389532","fields":{"summary":"NPE is seemingly simple query","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}},{"id":"12318418","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12318418","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"inwardIssue":{"id":"27899","key":"DERBY-47","self":"https://issues.apache.org/jira/rest/api/2/issue/27899","fields":{"summary":"Some possible improvements to IN optimization","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/4","id":"4","description":"An improvement or enhancement to an existing feature or task.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/improvement.png","name":"Improvement","subtask":false}}}}],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"customfield_12312337":null,"customfield_12312338":null,"updated":"2009-06-30T15:55:42.305+0000","customfield_12312335":null,"customfield_12311720":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/11408","id":"11408","name":"SQL"}],"timeoriginalestimate":null,"description":"With a single value in the IN clause the query does not fail.\n > Run the following query in the attached database (v 10.3 db).  \n\nSELECT A.TIMESTAMP, B.F_NAMEADDR, B.TOTAL_F,\nB.TOTAL_FS, B.TOTAL_FT, B.TOTAL_FX\nFROM  TIME A, THE_VIEW B\nWHERE B.T_ID = A.T_ID AND B.F_NAMEADDR IN ('one.two.three.oscar','one.two.three.kathy')\nORDER BY A.TIMESTAMP ASC;\n\n> result\n\nERROR 38000: The exception 'java.lang.NullPointerException' was thrown while evaluating an expression.\nERROR XJ001: Java exception: ': java.lang.NullPointerException'.\n\nStack trace:\n Failed Statement is: SELECT A.TIMESTAMP, B.F_NAMEADDR, B.TOTAL_F,\nB.TOTAL_FS, B.TOTAL_FT, B.TOTAL_FX\nFROM  TIME A, THE_VIEW B\nWHERE B.T_ID = A.T_ID AND B.F_NAMEADDR IN ('one.two.three.oscar','one.two.three.kathy')\nORDER BY A.TIMESTAMP ASC\nERROR 38000: The exception 'java.lang.NullPointerException' was thrown while evaluating an expression.\n\tat org.apache.derby.iapi.error.StandardException.newException(Unknown Source)\n\tat org.apache.derby.iapi.error.StandardException.unexpectedUserException(Unknown Source)\n\tat org.apache.derby.impl.services.reflect.DirectCall.invoke(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.NestedLoopJoinResultSet.getNextRowCore(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.SortResultSet.getRowFromResultSet(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.SortResultSet.getNextRowFromRS(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.SortResultSet.loadSorter(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.SortResultSet.openCore(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.open(Unknown Source)\n\tat org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedStatement.execute(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedStatement.execute(Unknown Source)\n\tat org.apache.derby.impl.tools.ij.ij.executeImmediate(Unknown Source)\n\tat org.apache.derby.impl.tools.ij.utilMain.doCatch(Unknown Source)\n\tat org.apache.derby.impl.tools.ij.utilMain.runScriptGuts(Unknown Source)\n\tat org.apache.derby.impl.tools.ij.utilMain.go(Unknown Source)\n\tat org.apache.derby.impl.tools.ij.Main.go(Unknown Source)\n\tat org.apache.derby.impl.tools.ij.Main.mainCore(Unknown Source)\n\tat org.apache.derby.impl.tools.ij.Main14.main(Unknown Source)\n\tat org.apache.derby.tools.ij.main(Unknown Source)\nCaused by: java.lang.NullPointerException\n\tat org.apache.derby.exe.ac601a400fx0116xa813xc2f7x00000010a3602.e8(Unknown Source)\n\t... 21 more\n============= begin nested exception, level (1) ===========\njava.lang.NullPointerException\n\tat org.apache.derby.exe.ac601a400fx0116xa813xc2f7x00000010a3602.e8(Unknown Source)\n\tat org.apache.derby.impl.services.reflect.DirectCall.invoke(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.NestedLoopJoinResultSet.getNextRowCore(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.SortResultSet.getRowFromResultSet(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.SortResultSet.getNextRowFromRS(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.SortResultSet.loadSorter(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.SortResultSet.openCore(Unknown Source)\n\tat org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.open(Unknown Source)\n\tat org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedStatement.execute(Unknown Source)\n\tat org.apache.derby.impl.jdbc.EmbedStatement.execute(Unknown Source)\n\tat org.apache.derby.impl.tools.ij.ij.executeImmediate(Unknown Source)\n\tat org.apache.derby.impl.tools.ij.utilMain.doCatch(Unknown Source)\n\tat org.apache.derby.impl.tools.ij.utilMain.runScriptGuts(Unknown Source)\n\tat org.apache.derby.impl.tools.ij.utilMain.go(Unknown Source)\n\tat org.apache.derby.impl.tools.ij.Main.go(Unknown Source)\n\tat org.apache.derby.impl.tools.ij.Main.mainCore(Unknown Source)\n\tat org.apache.derby.impl.tools.ij.Main14.main(Unknown Source)\n\tat org.apache.derby.tools.ij.main(Unknown Source)\n============= end nested exception, level (1) ===========\n\nSchema info:\n\nCREATE TABLE TIME (\"T_ID\" BIGINT NOT NULL, \"TIMESTAMP\" TIMESTAMP NOT NULL, \"DAY\" INTEGER NOT NULL, \"WEEK\" INTEGER NOT NULL, \"MONTH\" INTEGER NOT NULL, \"YEAR_COL\" INTEGER NOT NULL);\n\nCREATE TABLE F  (\"F_ID\" BIGINT NOT NULL, \"T_ID\" BIGINT NOT NULL, \"F_NAMEADDR\" VARCHAR(250) NOT NULL, \"TOTAL_F\" BIGINT NOT NULL, \"TOTAL_FS\" BIGINT NOT NULL, \"TOTAL_FT\" BIGINT NOT NULL, \"TOTAL_FX\" BIGINT NOT NULL);\n\nCREATE VIEW the_view AS SELECT  T.T_ID  AS T_ID ,   T.F_NAMEADDR AS F_NAMEADDR,\n T.TOTAL_F AS TOTAL_F,  T.TOTAL_FS AS TOTAL_FS,  T.TOTAL_FT AS TOTAL_FT  , T.TOTAL_FX AS TOTAL_FX \n   FROM    F AS T \n    WHERE   T.T_ID = (SELECT MAX(T_ID) FROM F);\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12310200":[{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10420","value":"Regression","id":"10420"}],"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"aggregatetimeestimate":null,"customfield_12312022":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12310921":null,"customfield_12310920":"38836","summary":"NullPointer Exception (NPE) from query with IN predicate containing two values and joining a view with a large table.  ERROR 38000: The exception 'java.lang.NullPointerException' was thrown while evaluating an expression.","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stan","name":"stan","emailAddress":"Stan dot Bradbury at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Stan Bradbury","active":true},"subtasks":[],"customfield_12310090":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stan","name":"stan","emailAddress":"Stan dot Bradbury at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Stan Bradbury","active":true},"customfield_12310291":null,"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"environment":null,"customfield_12311020":null,"customfield_12310050":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"startAt":0,"maxResults":13,"total":13,"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12383938/comment/12548515","id":"12548515","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stan","name":"stan","emailAddress":"Stan dot Bradbury at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Stan Bradbury","active":true},"body":"The database with two tables and view definition needed to demonstrate this bug.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stan","name":"stan","emailAddress":"Stan dot Bradbury at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Stan Bradbury","active":true},"created":"2007-12-05T02:22:26.451+0000","updated":"2007-12-05T02:22:26.451+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12383938/comment/12548720","id":"12548720","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"Based on a quick test it looks like this is a regression caused by DERBY-47.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2007-12-05T16:38:47.177+0000","updated":"2007-12-05T16:38:47.177+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12383938/comment/12549191","id":"12549191","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"Not sure if this a direct result of DERBY-47, or if DERBY-47 just changed execution plans such that another problem is now exposed, see esp. DERBY-3097 and related discussion.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2007-12-06T20:59:38.189+0000","updated":"2007-12-06T21:01:30.503+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12383938/comment/12551682","id":"12551682","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"A surprisingly simple repro of this NPE can be created as follows:\r\n\r\n  create table t1 (i int, vc varchar(10));\r\n  insert into t1 values (1, 'one'), (2, 'two'), (3, 'three'), (1, 'un');\r\n\r\n  select * from t1, (select * from t1) x\r\n    where t1.i = x.i and x.vc in ('un', 'trois');\r\n\r\nThe key here is that the IN list's left operand points to a column from the subselect, X.VC.  As part of DERBY-47, the IN list will be changed into a BinaryRelationalOperatorNode of the form \"X.VC = ?\", and that node, which we call a \"probe predicate\", will serve to represent the IN list operator throughout the various phases of optimization.\r\n\r\nThat said, as part of preprocessing Derby will look at the query and realize that the sub-select can be flattened.  When flattening the subquery, any references to the subquery's RCL will be remapped to point to the underlying expression.  That means the left operand of the probe predicate \"X.VC = ?\" will be changed to point directly to column \"VC\" of table T1.  The code where this happens is in the \"flatten\" method of FromSubquery:\r\n\r\n        /* Remap all ColumnReferences from the outer query to this node.\r\n         * (We replace those ColumnReferences with clones of the matching\r\n         * expression in the SELECT's RCL.\r\n         */\r\n        rcl.remapColumnReferencesToExpressions();\r\n        outerPList.remapColumnReferencesToExpressions();\r\n\r\nFor the example query above, outerPList holds the two predicates \"T1.I = X.I\" and \"X.VC = ?\", so we will attempt to remap the column references in those two predicates.  That brings us to the remapColumnReferencesToExpressions() method of BinaryOperatorNode, where we have:\r\n\r\n    public ValueNode remapColumnReferencesToExpressions()\r\n        throws StandardException\r\n    {\r\n        leftOperand = leftOperand.remapColumnReferencesToExpressions();\r\n        rightOperand = rightOperand.remapColumnReferencesToExpressions();\r\n        return this;\r\n    }\r\n\r\nNotice how the leftOperand can change here--and in the above query, it *will* change to point directly to T1 instead of indirectly to the subquery.  So now the probe predicate's left operand is different from the left operand of the original InListOperatorNode that the probe predicate replaced. That in it itself is fine, but it causes problems later.\r\n\r\nNamely, when it comes time to generate the final tree for the query, we realize that the probe predicate is not \"useful\" for probing because it references \"VC\", which is the second column in table T1.  Since probe predicates are only useful if they reference the first column in the table, per \"orderUsefulPredicates(...)\" of PredicateList.java: \r\n\r\n            else if (pred.isInListProbePredicate()\r\n                    && (indexPosition > 0))\r\n            {\r\n                /* If the predicate is an IN-list probe predicate\r\n                 * then we only consider it to be useful if the\r\n                 * referenced column is the *first* one in the\r\n                 * index (i.e. if (indexPosition == 0)).  Otherwise\r\n                 * the predicate would be treated as a qualifier\r\n                 * for store, which could lead to incorrect\r\n                 * results.\r\n                 */\r\n             ....\r\n\r\nthe probe predicate is not useful.  That in turn means that when it comes time to generate the IN list operator, we'll \"revert\" back to the original InListOperatorNode--i.e. we will generate the InListOperatorNode *instead of* generating the probe predicate.  This is found in the generateExpression() method of BinaryOperatorNode:\r\n\r\n            if (ilon != null)\r\n            {\r\n                ilon.generateExpression(acb, mb);\r\n                return;\r\n            }\r\n\r\nBut there's a problem here: as mentioned above, ilon (the InListOperatorNode) still has a left operand that points to a column from the *subquery*.  Since we flattened the subquery out, that left operand is no longer valid--and that ultimately causes an execution time NPE because we try to apply the IN list restriction to a column from a subquery that does not exist.\r\n\r\nI tried a one-line fix to this code that seems to have resolved the issue:\r\n\r\n            if (ilon != null)\r\n            {\r\n                ilon.setLeftOperand(this.leftOperand); // Added this line\r\n                ilon.generateExpression(acb, mb);\r\n                return;\r\n            }\r\n\r\n(with appropriate code comments, of course).\r\n\r\nThis has the effect of making sure that when we \"revert\" back to the original InListOperatorNode generation, we'll still generate the correct leftOperand--i.e. the left operand as it exists in the \"probe predicate\" upon completion of optimization.\r\n\r\nI'm attaching this small fix as d3253_v1.patch.  I have yet to run the regression tests (they are running now), but I thought I'd post my findings for early review in the interim...","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2007-12-14T04:01:07.804+0000","updated":"2007-12-14T04:01:07.804+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12383938/comment/12551824","id":"12551824","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"Hi Army, thanks for taking the time to explain this in detail.\r\n\r\nRestating what I think I heard you say:\r\n\r\n - when we remap the predicate's column references during flattening,\r\n   we modify the leftOperand of the InListOperatorNode, but when we\r\n   generate the InListOperatorNode's expression (rather than the probe\r\n   predicate's expression), we \"recover\" the InListOperatorNode's\r\n   leftOperand from its BinaryOperatorNode's parent.\r\n\r\nDid I follow your explanation correctly?\r\n\r\nIf so, it seems like it might be (slightly) cleaner if the logic were\r\ncentralized in the InListOperatorNode itself, perhaps by defining an\r\nextra field in the node to hold the \"before remapping\" version of\r\nthe leftOperand so that we can use that value rather than the remapped\r\nleftOperand during generateExpression.\r\n\r\nI'm just trying to avoid having code where BinaryOperatorNode corrects\r\nfor a problem that is occuring in a child node; I always worry when I\r\nsee class A having code that corrects the behavior of class B.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2007-12-14T15:13:08.229+0000","updated":"2007-12-14T15:13:08.229+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12383938/comment/12551848","id":"12551848","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"> Did I follow your explanation correctly? \r\n\r\nSorry, I think I messed up the explanation slightly.  The order of events is:\r\n\r\n  -- Preprocess InListOperatorNode, which has some left operand OP_0, and convert it\r\n    into a \"probe predicate\", which is a BinaryRelationalOperatorNode.  That probe\r\n    predicate does two things: 1) assumes its left operand from InListOperatorNode,\r\n    i.e. the probe predicate's left operand is OP_0, as well; and 2) stores a pointer\r\n    to the InListOperatorNode so that, if needed, the probe predicate can \"revert\" back\r\n    to the InListOperatorNode at generation time.  Upon completion of the preprocess\r\n    phase for InListOperatorNode, the new probe predicate and the original InListOperatorNode\r\n    both have the same left operand (OP_0)\r\n\r\n  -- Preprocess the subquery node, which involves flattening it.  As part of flattening\r\n    the *probe predicate*'s left operand (*not* the InListOperatorNode's left operand) \r\n    changes to OP_1; this is because it (the probe predicate) now represents the\r\n    IN operation for the query tree, not the InListOperatorNode. So the InListOperatorNode \r\n    remains the same after flattening--i.e. its left operand is still OP_0.  That\r\n    means the probe predicate and the InListOperatorNode have now different\r\n    left operands.\r\n\r\n  -- Optimization completes, we decide that the probe predicate is not useful.\r\n\r\n  -- During code generation, we see that the probe predicate is not useful so we \"revert\"\r\n    back to the original InListOperatorNode by calling \"generate\" on that node (which we\r\n    stored inside the probe predicate (BinaryRelationalOperatorNode) at the beginning,\r\n    per #2 of the first bullet above).  But since the InListOperatorNode still has the old\r\n    operand OP_0, it generates the wrong column reference.\r\n\r\n> If so, it seems like it might be (slightly) cleaner if the logic were\r\n> centralized in the InListOperatorNode itself,\r\n\r\nI don't think this is possible--or at least, not straightforward--because once the probe predicate comes into the picture, it (the probe predicate) becomes the focus of all method calls related to the IN list--so the only way to keep the InListOperatorNode up to date would be to add logic in BinaryRelationalOperatorNode that sends all method calls relating to leftOperand on down to the InListOperatorNode, as well.  Note that doing so would require that the logic go into BinaryRelationalOperatorNode, not into InListOperatorNode.\r\n\r\nThat was the way I was leaning when I first started, but a) that would require more logic in more places in BinaryRelationalOperatorNode to propagate operations down to the InListOperatorNode, and b) it seemed like the odds of missing some leftOperand operation could be non-neglible for very compilcated queries (just a theory, I didn't actually investigate this further).  That said, it seemed like doing a single \"setLeftOperand()\" call at generation time was the preferable mechanism.\r\n\r\nI am of course open to change if you think this there is a better approach?\r\n\r\nThanks for the feedback!","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2007-12-14T16:23:58.005+0000","updated":"2007-12-14T16:30:00.434+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12383938/comment/12551860","id":"12551860","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"The flow of execution makes more sense now, thanks for filling it in more completely.\r\n\r\nSo when we revert from the probe predicate back to the original in-list-op, the problem\r\nis that the original in-list-op reflects the unflattened query, and since we've decided\r\nto flatten the query, it refers to a result set that no longer exists?\r\n\r\nThen I think when we perform the flattening, the probe predicate should ensure\r\nthat it not only re-maps its own column references, but also calls the in-list that\r\nit's stashed away, and gives the in-list a chance to re-map its column references.\r\n\r\nThat is: perform flatten remapping for *both* predicates, so that whichever one we\r\neventually decide to use, it correctly matches the overall query tree.\r\n\r\nI guess that is basically the approach you were describing when you said \r\n\r\n   \"the only way to keep the InListOperatorNode up to date would be to add logic in \r\n    BinaryRelationalOperatorNode that sends all method calls relating to\r\n     leftOperand on down to the InListOperatorNode, as well.\"\r\n\r\nIt seems like the \"probe predicate\" is this nifty shape-shifting operator that\r\nsays: \"I'd like to be a multi-probe index operator, but if it turns out I can't be,\r\nthen I'll switch back and be an IN list instead. Until we decide, I'll retain enough\r\ninformation that I can be either operator.\" Given that perspective, to me\r\nit seems valid that the code has to be routinely passing method calls to both\r\nvariants of the operator, since in a sense it *is* both variants of the operator,\r\nsimultaneously, until at some crucial instant the optimizer determines that\r\nit can finalize the decision as to which variant to use.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2007-12-14T17:07:54.188+0000","updated":"2007-12-14T17:07:54.188+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12383938/comment/12552317","id":"12552317","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"Hi Bryan,\r\n\r\nThank you for your continued feedback.\r\n\r\nI'm attaching two files.  The first is d3253_v2_incomplete.patch, which was my first attempt at addressing the issue in the \"other\" way, i.e.:\r\n\r\n> add logic in BinaryRelationalOperatorNode that sends all method calls\r\n> relating to leftOperand on down to the InListOperatorNode, as well.\r\n\r\nI tried the obvious places where this had to be done and the error reported for this issue did indeed disappear.  However, running more complicated queries with that approach leads to *other* execution-time NullPointerExceptions, plus a few changed query plans.  When I applied the patch and ran derbyall there were four test failures, all of which suffered from at least one execution-time NPE:\r\n\r\n  derbyall/derbyall.fail:lang/inbetween.sql\r\n  derbyall/derbyall.fail:lang/predicatePushdown.sql\r\n  derbyall/derbyall.fail:lang/predicatesIntoViews.sql\r\n  derbyall/derbyall.fail:lang/subquery.sql\r\n\r\nI looked briefly into this to try to figure out what the problem was, but I admit that I gave up pretty quickly.  In order to be sure that this approach works, I think we'd have to 1) look through all of the code to find any place that retrieved the left operand of a BinaryRelationalOperatorNode, 2) check to see if that place made any changes to the left operand in any way (direct or indirect), and 3) if changes were made, add logic to propagate those changes down to left operand of the InListOperatorNode that is tucked away inside the BinaryRelationalOperatorNode (if there is one).  Does that sound correct to you?  Or am I making this too complicated?\r\n\r\nThe fact that just hitting what I thought to be the \"basics\" causes failures leads me back to my original assessment of this approach: \r\n\r\n> a) that would require more logic in more places in BinaryRelationalOperatorNode\r\n> to propagate operations down to the InListOperatorNode, and b) it seems like\r\n> the odds of missing some leftOperand operation could be non-neglible for very\r\n> complicated queries.\r\n\r\nYou mentioned:\r\n\r\n> it seems valid that the code has to be routinely passing method calls to both\r\n> variants of the operator, since in a sense it *is* both variants of the operator,\r\n> simultaneously, until at some crucial instant the optimizer determines that\r\n> it can finalize the decision as to which variant to use.\r\n\r\nIs this in some way saying that instead of \"do the work once and apply the result to the correct place\", we'd be opting for \"do the work twice and then throw one of the results away\"?  Given the fact the doing the work a \"second\" time affects more code and is more error-prone, I wonder if that is really the best approach?  Regardless of which \"version\" of the operator we use, there should only be one correct form for the left operand when it comes time to generate code--and that should be exactly same between the two \"versions\".  So if we have the operand in its correct form, it seems reasonable to just push it to the right place for code generation...\r\n\r\nI fully admit that I may be biased here and that my bias may be keeping from seeing a silly mistake (or omission) in my attempt at this approach.  So I've attached my changes to this issue (d3253_v2_incomplete.patch); please feel free to look at it and to clean it up if there's anything obvious I missed.  My apologies in advance if that proves to be the case.\r\n\r\nI'm also attaching a second file, d3253_v3.patch, which is a slight variation of the _v1 patch.  With this approach we still use the \"setLeftOperand(this.leftOperand)\" approach seen in _v1, but instead of doing it once at code generation time, we do it as part of the BinaryRelationalOperatorNode.getInListOp() method.  That is to say, any time any caller tries to access the InListOperatorNode that sits beneath a \"probe predicate\", we ensure that the InListOperatorNode has a valid, up-to-date left operand--which comes from the probe predicate itself--before returning it to the caller.  This solves the issue, and passes all regression tests.\r\n\r\nI feel like _v3 is the best of the three approaches.  It has more changes than _v1 but unlike _v1, it ensures that *any* code which accesses the underlying InListOperatorNode will see a left operand that has the correct information.  It also seems a tad more maintainable than _v2 since the latter requires that any future code which directly or indirectly changes a BinaryRelationalOperatorNode's left operand must also account for the possibility that such a node is a probe predicate with an underlying InListOperatorNode.\r\n\r\nI'd like to proceed with the _v3 patch as my proposed solution.  If it is still generally felt that _v2 is the best overall approach, then perhaps I can go ahead with the _v3 approach for now and anyone who is so inclined can implement the _v2 approach as a longer term solution.  Does that seem like an acceptable proposal, or do you think that _v3 is in itself an incorrect or un-commitable fix?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2007-12-17T03:06:00.676+0000","updated":"2007-12-17T03:06:00.676+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12383938/comment/12552607","id":"12552607","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"I think the _v3 patch is a good one; I like the approach of the patch. Thank you\r\nfor adding the comments, they are quite clear. I think that the manipulation\r\nof the leftOperand field is well encapsulated with this approach.\r\n\r\nI downloaded and reviewed the _v3 patch against the current trunk.\r\nIn my environment, the new regression test fails as expected without the\r\ncode changes from the patch, and passes with the code changes applied.\r\n\r\nThank you again for taking the time to explore the various alternatives\r\nin detail, and for explaining how the processing works, it has been quite\r\nilluminating and I've learned a lot from observing your work.\r\n\r\n+1 to commit from me!\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2007-12-18T03:00:20.573+0000","updated":"2007-12-18T03:00:20.573+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12383938/comment/12553404","id":"12553404","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"Committed d3253_v3.patch with svn #605616:\r\n\r\n  URL: http://svn.apache.org/viewvc?rev=605616&view=rev\r\n\r\nMany thanks (again) to Bryan for the review and discussion--I appreciate your time!  I ran the svn merge command to port this back to 10.3 and it merged with no errors:\r\n\r\n  svn merge -r 605615:605616 https://svn.apache.org/repos/asf/db/derby/code/trunk\r\n\r\nI'll kick off the 10.3 regression tests today.  If they pass and if no issues arise in trunk for the new couple of days, I plan to commit to 10.3 by the end of the week...","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2007-12-19T17:04:57.331+0000","updated":"2007-12-19T17:04:57.331+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12383938/comment/12554004","id":"12554004","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"Update Fix Version to reflect that this has now been ported back to 10.3, as of:\r\n\r\n  URL: http://svn.apache.org/viewvc?rev=606277&view=rev","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2007-12-21T19:23:25.845+0000","updated":"2007-12-21T19:23:56.784+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12383938/comment/12559983","id":"12559983","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dyret","name":"dyret","emailAddress":"Dyre dot Tjeldvoll at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Dyre Tjeldvoll","active":true},"body":"Stan, do you think we can close this now?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dyret","name":"dyret","emailAddress":"Dyre dot Tjeldvoll at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Dyre Tjeldvoll","active":true},"created":"2008-01-17T16:37:57.613+0000","updated":"2008-01-17T16:37:57.613+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12383938/comment/12562285","id":"12562285","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stan","name":"stan","emailAddress":"Stan dot Bradbury at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Stan Bradbury","active":true},"body":"Catching up on Closing my reported issues.  Thanks to Dyre for the workflow reminder today.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stan","name":"stan","emailAddress":"Stan dot Bradbury at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Stan Bradbury","active":true},"created":"2008-01-24T23:07:58.173+0000","updated":"2008-01-24T23:07:58.173+0000"}]},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-3253/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i070fj:"}}