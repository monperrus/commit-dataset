{"expand":"renderedFields,names,schema,transitions,operations,editmeta,changelog","id":"12665641","self":"https://issues.apache.org/jira/rest/api/latest/issue/12665641","key":"DERBY-6317","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/10594","id":"10594","key":"DERBY","name":"Derby","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=10594&avatarId=10122","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=10594&avatarId=10122","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=10594&avatarId=10122","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=10594&avatarId=10122"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10090","id":"10090","description":"DB related projects","name":"DB"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12323475","id":"12323475","description":"Head of 10.8 branch starting 2014-01-13","name":"10.8.3.3","archived":false,"released":false},{"self":"https://issues.apache.org/jira/rest/api/2/version/12323562","id":"12323562","description":"Head of 10.9 branch after releasing 10.9.1.0","name":"10.9.2.2","archived":false,"released":false},{"self":"https://issues.apache.org/jira/rest/api/2/version/12326659","id":"12326659","description":"candidate for Second release for 10.10 branch","name":"10.10.2.0","archived":false,"released":true,"releaseDate":"2014-04-15"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12324243","id":"12324243","description":"First release on the 10.11 branch","name":"10.11.1.1","archived":false,"released":true,"releaseDate":"2014-08-26"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12310220":"2013-08-27 16:27:49.953","customfield_12312322":null,"customfield_12312323":null,"customfield_12310420":"345581","customfield_12310222":"1_*:*_1_*:*_1952524956_*|*_5_*:*_1_*:*_0","customfield_12312320":null,"customfield_12312321":null,"customfield_12312120":null,"customfield_12312121":null,"resolutiondate":"2013-09-18T16:48:04.828+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312326":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312324":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-6317/watchers","watchCount":5,"isWatching":false},"created":"2013-08-27T02:25:59.931+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12312334":null,"customfield_12310310":"8.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12317968","id":"12317968","description":"second release on the 10.8 branch","name":"10.8.2.2","archived":false,"released":true,"releaseDate":"2011-10-24"}],"customfield_12311120":null,"customfield_12312330":null,"issuelinks":[],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"customfield_12312337":null,"customfield_12312338":null,"updated":"2015-01-21T00:22:55.740+0000","customfield_12312335":null,"customfield_12311720":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/11408","id":"11408","name":"SQL"}],"timeoriginalestimate":null,"description":"The optimizer can chose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0.  \r\n\r\nAssume that you have two tables that are being joined like:\r\n\r\n\r\nSELECT * FROM T1, T0\r\nWHERE T1.ID = T0.F_ID and\r\nT0.ID = 3;\r\n\r\nAlso assume that T0 has two columns, ID and F_ID and F_ID is a foreign key on T1.ID.   Assume that T1.ID is the primary key of T1 and (T0.F_ID, T0.ID) is the primary key on T0.  Assume that there is a non-unique index on T0.ID.\r\n\r\nThe correct query plan for this should be to query T0 using the non-unique index on T0.ID and then use the foreign key value in those rows to do query T1 using the primary key on T1.\r\n\r\nWith some values of T0.ID in the above query this query plan is chosen and works.  With other values of T0.ID , the query plan does an query on T0 using the non-unique index on T0.ID and then does a table scan on T1.\r\n\r\nFor example, in my case the query:\r\n\r\nSELECT * FROM T1, T0\r\nWHERE T1.ID = T0.F_ID and\r\nT0.ID = 22112129;\r\n\r\nhas this query plan.   \r\n\r\nThe problem appears to be in BTreeCostController.java.  When this returns the same value for the \"left_of_start\" and the \"left_of_stop\" (which is being used to estimate the number of rows and cost), then the estimate cost and row count becomes 0.0.   When this is used in the join order of T0, T1, then the cost of the table scan for T1 becomes 0.0 as well.\r\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12310200":[{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10362","value":"Performance","id":"10362"},{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10421","value":"Seen in production","id":"10421"}],"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"aggregatetimeestimate":null,"customfield_12312022":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12310921":null,"customfield_12310920":"345882","summary":"Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bbergquist","name":"bbergquist","emailAddress":"brett at thebergquistfamily dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Brett Bergquist","active":true},"subtasks":[],"customfield_12310090":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bbergquist","name":"bbergquist","emailAddress":"brett at thebergquistfamily dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Brett Bergquist","active":true},"customfield_12310291":null,"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"environment":"Derby 10.8.2.2 on Oracle Solaris 10 ","customfield_12311020":null,"customfield_12310050":{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10051","value":"Urgent","id":"10051"},"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"startAt":0,"maxResults":42,"total":42,"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13750905","id":"13750905","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bbergquist","name":"bbergquist","emailAddress":"brett at thebergquistfamily dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Brett Bergquist","active":true},"body":"When BTreeCostController.java returns the same value for \"left_of_start\" and \"left_of_stop\", this conceptually means that very few rows are going to be returned using the index but it does not mean that 0 (zero rows) are going to be returned which is what the code currently does.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bbergquist","name":"bbergquist","emailAddress":"brett at thebergquistfamily dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Brett Bergquist","active":true},"created":"2013-08-27T02:28:17.924+0000","updated":"2013-08-27T02:28:17.924+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13751398","id":"13751398","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"The following email thread has critical info for this bug:\r\nI think i found were the issue occurs.  I am able to reproduce the problem with Derby 10.8.2.2.   The database has about 7 million records in APP.CONFIGURATION_BUNDLES3 and about 48 million records in COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3.   On  COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3, there is a non-unique index on COSEDDROPPROFILEDSCPTABLEENTRY_ID.\r\n\r\nSometimes on the same query with specific values, the query works correctly in that the query plan chooses to do an index lookup on COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3 using the index and then an index lookup on APP.CONFIGURATION_BUNDLES3.   Other times on the same query with another query value, the query plan chooses to do an index lookup on APP.CONFIGURATION_BUNDLES3 and then a table scan on APP.CONFIGURATION_BUNDLES3 which is incorrect.   The problem occurs because of the cost and row estimate on COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3 for specific values.\r\n\r\nHere is a query that works correctly:\r\n\r\nSELECT * FROM APP.CONFIGURATION_BUNDLE3 T1,\r\nAPP.COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3 t0\r\nWHERE t1.ID = t0.COSEDDROPPROFILEDSCPTABLEBUNDLE_ID and\r\nt0.COSEDDROPPROFILEDSCPTABLEENTRY_ID = 3;\r\n\r\nand here is the same query with a different value that fails with the table scan:\r\n\r\nSELECT * FROM APP.CONFIGURATION_BUNDLE3 T1,\r\nAPP.COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3 t0\r\nWHERE t1.ID = t0.COSEDDROPPROFILEDSCPTABLEBUNDLE_ID and\r\nt0.COSEDDROPPROFILEDSCPTABLEENTRY_ID = 22112129;\r\n\r\nNote that both of these values will exist, the number of rows in the first will be 42 and the second will be 1.  Also note that the values of COSEDDROPPROFILEDSCPTABLEENTRY_ID are pretty spaced out so the value 22112129 is at about 7% of the sequence of values in order.  Also note that there is a non-unique index on  COSEDDROPPROFILEDSCPTABLEENTRY_ID as I said above.\r\n\r\n   In BTreeCostController.java, we have:\r\n\r\n        public void getScanCost(\r\n    int                     scan_type,\r\n    long                    row_count,\r\n    int                     group_size,\r\n    boolean                 forUpdate,\r\n    FormatableBitSet                 scanColumnList,\r\n    DataValueDescriptor[]   template,\r\n    DataValueDescriptor[]   startKeyValue,\r\n    int                     startSearchOperator,\r\n    DataValueDescriptor[]   stopKeyValue,\r\n    int                     stopSearchOperator,\r\n    boolean                 reopen_scan,\r\n    int                     access_type,\r\n    StoreCostResult         cost_result)\r\n        throws StandardException\r\n    {\r\n        float       left_of_start;\r\n        float       left_of_stop;\r\n        ControlRow  control_row = null;\r\n        long        input_row_count = (row_count < 0 ? num_rows : row_count);\r\n\r\n        try\r\n        {\r\n            // Find the starting page and row slot.\r\n            if (startKeyValue == null)\r\n            {\r\n                left_of_start = 0;\r\n            }\r\n            else\r\n            {\r\n                // Search for the starting row.\r\n\r\n                SearchParameters sp = new SearchParameters(\r\n                    startKeyValue,\r\n                    ((startSearchOperator == ScanController.GE) ?\r\n                        SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH :\r\n                        SearchParameters.POSITION_RIGHT_OF_PARTIAL_KEY_MATCH),\r\n                    template, this, true);\r\n\r\n                control_row =\r\n                    ControlRow.get(this, BTree.ROOTPAGEID).search(sp);\r\n\r\n                control_row.release();\r\n                control_row = null;\r\n\r\n                left_of_start = sp.left_fraction;\r\n            }\r\n\r\n            if (stopKeyValue == null)\r\n            {\r\n                left_of_stop = 1;\r\n            }\r\n            else\r\n            {\r\n                // Search for the stopping row.\r\n\r\n                SearchParameters sp =\r\n                    new SearchParameters(\r\n                        stopKeyValue,\r\n                        ((stopSearchOperator == ScanController.GE) ?\r\n                          SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH :\r\n                          SearchParameters.POSITION_RIGHT_OF_PARTIAL_KEY_MATCH),\r\n                        template, this, true);\r\n\r\n                control_row =\r\n                    ControlRow.get(this, BTree.ROOTPAGEID).search(sp);\r\n\r\n                control_row.release();\r\n                control_row = null;\r\n\r\n                left_of_stop = sp.left_fraction;\r\n            }\r\n\r\n            // System.out.println(\r\n              //   \"\\n\\tleft_of_start = \" + left_of_start +\r\n                // \"\\n\\tleft_of_stop  = \" + left_of_stop);\r\n\r\n            // what percentage of rows are between start and stop?\r\n\r\n            float ret_fraction = left_of_stop - left_of_start;\r\n\r\n            // If for some reason the stop position comes before the start\r\n            // position, assume 0 rows will return from query.\r\n            if (ret_fraction < 0)\r\n                ret_fraction = 0;\r\n\r\n            // Never return estimate of more rows than exist, sometimes\r\n            // the recursive estimation through the btree may return a number\r\n            // like 1.00001.\r\n            if (ret_fraction > 1)\r\n                ret_fraction = 1;\r\n\r\n            float estimated_row_count = input_row_count * ret_fraction;\r\n\r\n            // first the base cost of positioning on the first row in the scan.\r\n            double cost =\r\n                getFetchFromFullKeyCost(scanColumnList, access_type);\r\n\r\n            // add the base cost of bringing each page for the first time into\r\n            // the cache.  This is basically the cost of bringing each leaf\r\n            // uncached into the cache and reading the control row off of it.:\r\n            cost +=\r\n                (num_pages * ret_fraction) * BASE_UNCACHED_ROW_FETCH_COST;\r\n\r\n            // Now some magic to try and figure out the cost of doing a\r\n            // scan along the leaf level of the tree.  Mostly just assume\r\n            // the costs are the same as the heap, and ignore qualifier\r\n            // processing and stop row comparisons for now.\r\n\r\n            // the base cost of getting each of the rows from a page assumed\r\n            // to already be cached (by the scan fetch) - this is only for all\r\n            // rows after the initial row on the page has been accounted for\r\n            // under the BASE_UNCACHED_ROW_FETCH_COST cost.:\r\n            long cached_row_count = ((long) estimated_row_count) - num_pages;\r\n            if (cached_row_count < 0)\r\n                cached_row_count = 0;\r\n\r\n            if (scan_type == StoreCostController.STORECOST_SCAN_NORMAL)\r\n                cost += cached_row_count * BASE_GROUPSCAN_ROW_COST;\r\n            else\r\n                cost += cached_row_count * BASE_HASHSCAN_ROW_FETCH_COST;\r\n\r\n            // finally add the cost associated with the number of bytes in row:\r\n            long row_size =\r\n                (input_row_count == 0) ?\r\n                    4 : (num_pages * page_size) / input_row_count;\r\n\r\n            cost +=\r\n                (estimated_row_count * row_size) * BASE_ROW_PER_BYTECOST;\r\n\r\n            if (SanityManager.DEBUG)\r\n            {\r\n                if (cost < 0)\r\n                    SanityManager.THROWASSERT(\"cost \" + cost);\r\n\r\n                if (estimated_row_count < 0)\r\n                    SanityManager.THROWASSERT(\r\n                        \"estimated_row_count = \" + estimated_row_count);\r\n            }\r\n\r\n            // return the cost\r\n            cost_result.setEstimatedCost(cost);\r\n\r\n            // RESOLVE - should we make sure this number is > 0?\r\n            cost_result.setEstimatedRowCount(Math.round(estimated_row_count));\r\n        }\r\n        finally\r\n        {\r\n            if (control_row != null)\r\n                control_row.release();\r\n        }\r\n\r\n        // System.out.println(\"BTreeCostController.getScanCost():\" +\r\n          //   \"\\n\\t cost = \" + cost_result.getEstimatedCost() +\r\n            // \"\\n\\t rows = \" + cost_result.getEstimatedRowCount());\r\n\r\n        return;\r\n    }\r\n\r\nThe problem that I am seeing is that on certain queries coming in the \"left_of_start\" and the \"left_of_stop\" can be the same value.   When this occurs, the \"ret_fraction\" becomes 0.0 and the estimated row count becomes \"0.0\" and the estimated cost becomes \"0.0\".\r\n\r\nWhen this occurs in the query plan and the join order is APP.COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3 and then APP.CONFIGURATION_BUNDLE3, this outer cost of \"0.0\" has the effect of causing the cost of the table scan of APP.CONFIGURATION_BUNDLE3 appear to be the lowest cost.   This is incorrect.\r\n\r\nFor discrete values that are unique within a large index, it seems to me (and is observed), that the rows left of the start value and rows left of the stop value could very well be the same when the starting and stopping values are the same as in this case.\r\n\r\nAs a test, I modified the above code to estimate the rows as 1 when this is the case and ran the code and it immediately pick the access path that it should.  Probably 1 row is not correct but I am having a little trouble to come up with the value that it should be when the starting and stopping row percentage are exactly the same (in this case left_of_stop and right_of_stop is 0.07715294 and the number of rows in the table are 48248128).\r\n\r\nBelow I have the output of the optimizer trace for the two queries that I label CORRECT and iNCORRECT in which this can be seen.\r\n\r\n-- CORRECT OPTIMIZER TRACE ---\r\n\r\n\"SELECT * FROM APP.CONFIGURATION_BUNDLE3 T1,\r\nAPP.COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3 t0\r\nWHERE t1.ID = t0.COSEDDROPPROFILEDSCPTABLEBUNDLE_ID and\r\nt0.COSEDDROPPROFILEDSCPTABLEENTRY_ID = 3\r\nOptimization started at time 1377549782052 using optimizer 1655768029\r\n\r\n\r\nConsidering join order:  0 with assignedTableMap = {}\r\n\r\n\r\nCalling nextAccessPath() for base table T1 with 0 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0\r\nAdding unordered optimizable, # of predicates = 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 0 is :\r\nLevel2CostEstimateImpl: at 457048813, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0\r\nLock mode set to MODE_TABLE because no start or stop position\r\nCost of 1.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\n\r\nRemembering join strategy NESTEDLOOP as best for table 0\r\nin best access path\r\nCalling nextAccessPath() for base table T1 with 0 predicates.\r\n\r\nConsidering join strategy HASH for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0\r\nAdding unordered optimizable, # of predicates = 0\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T1 with 0 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} scan for table number 0 is :\r\nLevel2CostEstimateImpl: at 457048813, cost == 1540600.81, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0\r\nLock mode set to MODE_TABLE because no start or stop position\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 457048813, cost == 1.5267433370000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\nCost of 1.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 1.5267433370000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\nCalling nextAccessPath() for base table T1 with 0 predicates.\r\n\r\nConsidering join strategy HASH for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T1 with 0 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} for table 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} scan for table number 0 is :\r\nLevel2CostEstimateImpl: at 457048813, cost == 2359582.402, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0\r\nLock mode set to MODE_TABLE because no start or stop position\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 457048813, cost == 1.6086414962000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\nCost of 1.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 1.6086414962000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\nCalling nextAccessPath() for base table T1 with 0 predicates.\r\n\r\nConsidering join strategy HASH for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} for table 0\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T1 with 0 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} for table 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} scan for table number 0 is :\r\nLevel2CostEstimateImpl: at 457048813, cost == 2634793.8619999997, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0\r\nLock mode set to MODE_TABLE because no start or stop position\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 457048813, cost == 1.6361626422E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\nCost of 1.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 1.6361626422E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\nCalling nextAccessPath() for base table T1 with 0 predicates.\r\n\r\nConsidering join strategy HASH for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} for table 0\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T1 with 0 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\nNo more conglomerates to consider for table 0\r\nTotal cost of non-sort-avoidance plan is Level2CostEstimateImpl: at 70394772, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n\r\n\r\nConsidering join order:  0 1 with assignedTableMap = {0}\r\n\r\n\r\nCalling nextAccessPath() for base table T0 with 2 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1\r\nScanning heap, but we have a full match on a unique key.\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 997551539, cost == 1.2493973484000001E7, rowCount == 4.8248133E7, singleScanRowCount == 4.8248133E7\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 2, extra qualifier selectivity is : 0.010000000000000002\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0\r\nLock mode set to MODE_TABLE because no start or stop position\r\nCost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.2493973484000001E7, rowCount == 482481.3300000001, singleScanRowCount == 482481.3300000001 for table 1\r\nCost of 7003486.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 8.750136837956523E13, rowCount == 7003486.0, singleScanRowCount == 482481.3300000001 for table 1\r\n\r\nRemembering join strategy NESTEDLOOP as best for table 1\r\nin best access path\r\nCalling nextAccessPath() for base table T0 with 2 predicates.\r\n\r\nConsidering join strategy HASH for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1\r\nScanning heap, but we have a full match on a unique key.\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 0\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 997551539, cost == 1.3451277644000001E7, rowCount == 4.8248133E7, singleScanRowCount == 4.8248133E7\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 0.1\r\nLock mode set to MODE_TABLE because no start or stop position\r\nCost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.3451277644000001E7, rowCount == 4824813.3, singleScanRowCount == 4824813.3 for table 1\r\nCost of 7003486.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 1.3451277644000001E7, rowCount == 7003486.0, singleScanRowCount == 4824813.3 for table 1\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.3451277644000001E7, rowCount == 7003486.0, singleScanRowCount == 482481.33 for table 1\r\nSkipping access path due to excess memory usage, maximum is 1048576\r\nCalling nextAccessPath() for base table T0 with 2 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nGuaranteed to match a single row - cost is: 7.8575 for table 1\r\nLock mode set to MODE_RECORD because all start and stop positions are constant\r\nCost of 7003486.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 5.5029891245E7, rowCount == 7003486.0, singleScanRowCount == 1.0 for table 1\r\n\r\nRemembering join strategy NESTEDLOOP as best for table 1\r\nin best access path\r\nCalling nextAccessPath() for base table T0 with 2 predicates.\r\n\r\nConsidering join strategy HASH for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 0\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 997551539, cost == 1.70082898735E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 0.1\r\nLock mode set to MODE_TABLE because no start or stop position\r\nCost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.70082898735E7, rowCount == 4824813.2, singleScanRowCount == 4824813.2 for table 1\r\nCost of 7003486.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 1.70082898735E7, rowCount == 7003486.0, singleScanRowCount == 4824813.2 for table 1\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.70082898735E7, rowCount == 7003486.0, singleScanRowCount == 482481.32000000007 for table 1\r\nSkipping access path due to excess memory usage, maximum is 1048576\r\nCalling nextAccessPath() for base table T0 with 2 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 997551539, cost == 1.3959416302000001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 0.1\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 1, statistics start/stop selectivity is : 1.3264763349989454E-6\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1\r\nCost including extra statistics for index being considered start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 24.802827036771248, rowCount == 64.00000530590533, singleScanRowCount == 64.00000530590533 for table 1\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 997551539, cost == 128.99483567478512, rowCount == 64.00000530590533, singleScanRowCount == 64.00000530590533 for table 1\r\nCost of 7003486.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 9.034135257206582E8, rowCount == 7003486.0, singleScanRowCount == 64.00000530590533 for table 1\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 9.034135257206582E8, rowCount == 7003486.0, singleScanRowCount == 6.400000530590534 for table 1\r\nCalling nextAccessPath() for base table T0 with 2 predicates.\r\n\r\nConsidering join strategy HASH for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 0\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 997551539, cost == 1.4915061182000002E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.010000000000000002\r\nLock mode set to MODE_TABLE because no start or stop position\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 997551539, cost == 9.346302007800001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7 for table 1\r\nCost of 7003486.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 9.346302007800001E7, rowCount == 7003486.0, singleScanRowCount == 4.8248132E7 for table 1\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 9.346302007800001E7, rowCount == 7003486.0, singleScanRowCount == 482481.32000000007 for table 1\r\nSkipping access path due to excess memory usage, maximum is 1048576\r\nCalling nextAccessPath() for base table T0 with 2 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 997551539, cost == 8.544554508045316, rowCount == 4.0, singleScanRowCount == 4.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 997551539, cost == 15.056554508045316, rowCount == 4.0, singleScanRowCount == 4.0 for table 1\r\nCost of 7003486.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 1.0544836870533226E8, rowCount == 7003486.0, singleScanRowCount == 4.0 for table 1\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.0544836870533226E8, rowCount == 7003486.0, singleScanRowCount == 0.4 for table 1\r\nCalling nextAccessPath() for base table T0 with 2 predicates.\r\n\r\nConsidering join strategy HASH for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T0 with 2 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\nNo more conglomerates to consider for table 1\r\nTotal cost of non-sort-avoidance plan is Level2CostEstimateImpl: at 70394772, cost == 5.9364160905E7, rowCount == 7003486.0, singleScanRowCount == 1.0\r\nWe have a complete join order.\r\nThis is the cheapest plan so far.\r\nPlan is a normal plan.\r\nCost of cheapest plan is Level2CostEstimateImpl: at 70394772, cost == 5.9364160905E7, rowCount == 7003486.0, singleScanRowCount == 1.0\r\nRemembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false, costEstimate == Level2CostEstimateImpl: at 69248303, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0, coveringIndexScan == false, nonMatchingIndexScan == true, joinStrategy == NESTEDLOOP, lockMode == 7, optimizer level == 2 as truly the best for table -1 for plan type  normal\r\n\r\nRemembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false, costEstimate == Level2CostEstimateImpl: at 69248303, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0, coveringIndexScan == false, nonMatchingIndexScan == true, joinStrategy == NESTEDLOOP, lockMode == 7, optimizer level == 2 as truly the best for table 0 for plan type  normal\r\n\r\nRemembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID}, costEstimate == Level2CostEstimateImpl: at 2067575494, cost == 5.5029891245E7, rowCount == 7003486.0, singleScanRowCount == 1.0, coveringIndexScan == true, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table -1 for plan type  normal\r\n\r\nRemembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID}, costEstimate == Level2CostEstimateImpl: at 2067575494, cost == 5.5029891245E7, rowCount == 7003486.0, singleScanRowCount == 1.0, coveringIndexScan == true, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table 1 for plan type  normal\r\n\r\n\r\n\r\nRemembering join order as best:  0 1 with assignedTableMap = {0, 1}\r\n\r\n\r\n\r\n\r\nConsidering join order:  1 with assignedTableMap = {}\r\n\r\n\r\nCalling nextAccessPath() for base table T0 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1\r\nAdding unordered optimizable, # of predicates = 1\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 997551539, cost == 1.2493973484000001E7, rowCount == 4.8248133E7, singleScanRowCount == 4.8248133E7\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0\r\nLock mode set to MODE_TABLE because no start or stop position\r\nCost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.2493973484000001E7, rowCount == 4824813.3, singleScanRowCount == 4824813.3 for table 1\r\nCost of 1.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 1.2493973484000001E7, rowCount == 4824813.3, singleScanRowCount == 4824813.3 for table 1\r\nSelectivity from statistics found. It is 2.3194399498852528E-8\r\nCost including extra selectivity from statistics start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.2493973484000001E7, rowCount == 1.11908647187577, singleScanRowCount == 1.11908647187577 for table 1\r\n\r\nRemembering join strategy NESTEDLOOP as best for table 1\r\nin best access path\r\nCalling nextAccessPath() for base table T0 with 1 predicates.\r\n\r\nConsidering join strategy HASH for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1\r\nAdding unordered optimizable, # of predicates = 1\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T0 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 997551539, cost == 1.60550464935E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0\r\nLock mode set to MODE_TABLE because no start or stop position\r\nCost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.60550464935E7, rowCount == 4824813.2, singleScanRowCount == 4824813.2 for table 1\r\nCost of 1.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 1.60550464935E7, rowCount == 4824813.2, singleScanRowCount == 4824813.2 for table 1\r\nSelectivity from statistics found. It is 2.3194399498852528E-8\r\nCost including extra selectivity from statistics start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 1.60550464935E7, rowCount == 1.1190864486813705, singleScanRowCount == 1.1190864486813705 for table 1\r\nCalling nextAccessPath() for base table T0 with 1 predicates.\r\n\r\nConsidering join strategy HASH for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T0 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 997551539, cost == 1.3959416302000001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1\r\nLock mode set to MODE_TABLE because no start or stop position\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 997551539, cost == 9.250737519800001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7 for table 1\r\nCost of 1.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 9.250737519800001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7 for table 1\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 9.250737519800001E7, rowCount == 4824813.2, singleScanRowCount == 4824813.2 for table 1\r\nSelectivity from statistics found. It is 2.3194399498852528E-8\r\nCost including extra selectivity from statistics start/stop selectivity is : Level2CostEstimateImpl: at 997551539, cost == 9.250737519800001E7, rowCount == 1.1190864486813705, singleScanRowCount == 1.1190864486813705 for table 1\r\nCalling nextAccessPath() for base table T0 with 1 predicates.\r\n\r\nConsidering join strategy HASH for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T0 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 997551539, cost == 8.544554508045316, rowCount == 4.0, singleScanRowCount == 4.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 997551539, cost == 15.056554508045316, rowCount == 4.0, singleScanRowCount == 4.0 for table 1\r\nCost of 1.0 scans is: Level2CostEstimateImpl: at 997551539, cost == 15.056554508045316, rowCount == 4.0, singleScanRowCount == 4.0 for table 1\r\n\r\nRemembering join strategy NESTEDLOOP as best for table 1\r\nin best access path\r\nCalling nextAccessPath() for base table T0 with 1 predicates.\r\n\r\nConsidering join strategy HASH for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T0 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\nNo more conglomerates to consider for table 1\r\nTotal cost of non-sort-avoidance plan is Level2CostEstimateImpl: at 70394772, cost == 15.056554508045316, rowCount == 4.0, singleScanRowCount == 4.0\r\n\r\n\r\nConsidering join order:  1 0 with assignedTableMap = {1}\r\n\r\n\r\nCalling nextAccessPath() for base table T1 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0\r\nScanning heap, but we have a full match on a unique key.\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 0 is :\r\nLevel2CostEstimateImpl: at 457048813, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0\r\nLock mode set to MODE_TABLE because no start or stop position\r\nCost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 457048813, cost == 4334269.66, rowCount == 700348.6000000001, singleScanRowCount == 700348.6000000001 for table 0\r\nCost of 4.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 1.733707864E7, rowCount == 4.0, singleScanRowCount == 700348.6000000001 for table 0\r\n\r\nRemembering join strategy NESTEDLOOP as best for table 0\r\nin best access path\r\nCalling nextAccessPath() for base table T1 with 1 predicates.\r\n\r\nConsidering join strategy HASH for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0\r\nScanning heap, but we have a full match on a unique key.\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 3\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 3\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 0 is :\r\nLevel2CostEstimateImpl: at 457048813, cost == 4470393.76, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 0.1\r\nLock mode set to MODE_TABLE because no start or stop position\r\nCost of 4.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 4470393.76, rowCount == 4.0, singleScanRowCount == 7003486.0 for table 0\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 457048813, cost == 4470393.76, rowCount == 4.0, singleScanRowCount == 700348.6000000001 for table 0\r\nSkipping access path due to excess memory usage, maximum is 1048576\r\nCalling nextAccessPath() for base table T1 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0\r\nGuaranteed to match a single row - cost is: 6.286 for table 0\r\nLock mode set to MODE_RECORD because all start and stop positions are constant\r\nCost of 4.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 25.144, rowCount == 4.0, singleScanRowCount == 1.0 for table 0\r\nIndex does not cover query - cost including base row fetch is: 7.84 for table 0\r\n\r\nRemembering join strategy NESTEDLOOP as best for table 0\r\nin best access path\r\nCalling nextAccessPath() for base table T1 with 1 predicates.\r\n\r\nConsidering join strategy HASH for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 0\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} scan for table number 0 is :\r\nLevel2CostEstimateImpl: at 457048813, cost == 1679861.03, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 0.1\r\nLock mode set to MODE_TABLE because no start or stop position\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 457048813, cost == 1.540669359E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\nCost of 4.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 1.540669359E7, rowCount == 4.0, singleScanRowCount == 7003486.0 for table 0\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 457048813, cost == 1.540669359E7, rowCount == 4.0, singleScanRowCount == 700348.6000000001 for table 0\r\nSkipping access path due to excess memory usage, maximum is 1048576\r\nCalling nextAccessPath() for base table T1 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} for table 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} scan for table number 0 is :\r\nLevel2CostEstimateImpl: at 457048813, cost == 2359582.402, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1\r\nLock mode set to MODE_TABLE because no start or stop position\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 457048813, cost == 1.6086414962000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\nCost of 4.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 6.4345659848000005E7, rowCount == 4.0, singleScanRowCount == 7003486.0 for table 0\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 457048813, cost == 6.4345659848000005E7, rowCount == 4.0, singleScanRowCount == 700348.6000000001 for table 0\r\nCalling nextAccessPath() for base table T1 with 1 predicates.\r\n\r\nConsidering join strategy HASH for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} for table 0\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T1 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} for table 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} scan for table number 0 is :\r\nLevel2CostEstimateImpl: at 457048813, cost == 2634793.8619999997, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1\r\nLock mode set to MODE_TABLE because no start or stop position\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 457048813, cost == 1.6361626422E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\nCost of 4.0 scans is: Level2CostEstimateImpl: at 457048813, cost == 6.5446505688E7, rowCount == 4.0, singleScanRowCount == 7003486.0 for table 0\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 457048813, cost == 6.5446505688E7, rowCount == 4.0, singleScanRowCount == 700348.6000000001 for table 0\r\nCalling nextAccessPath() for base table T1 with 1 predicates.\r\n\r\nConsidering join strategy HASH for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} for table 0\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T1 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\nNo more conglomerates to consider for table 0\r\nTotal cost of non-sort-avoidance plan is Level2CostEstimateImpl: at 70394772, cost == 48.04055450804531, rowCount == 4.0, singleScanRowCount == 1.0\r\nWe have a complete join order.\r\nThis is the cheapest plan so far.\r\nPlan is a normal plan.\r\nCost of cheapest plan is Level2CostEstimateImpl: at 70394772, cost == 48.04055450804531, rowCount == 4.0, singleScanRowCount == 1.0\r\nRemembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID}, costEstimate == Level2CostEstimateImpl: at 726246088, cost == 15.056554508045316, rowCount == 4.0, singleScanRowCount == 4.0, coveringIndexScan == false, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table -1 for plan type  normal\r\n\r\nRemembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID}, costEstimate == Level2CostEstimateImpl: at 726246088, cost == 15.056554508045316, rowCount == 4.0, singleScanRowCount == 4.0, coveringIndexScan == false, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table 1 for plan type  normal\r\n\r\nRemembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID}, costEstimate == Level2CostEstimateImpl: at 1868435115, cost == 32.983999999999995, rowCount == 4.0, singleScanRowCount == 1.0, coveringIndexScan == false, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table -1 for plan type  normal\r\n\r\nRemembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID}, costEstimate == Level2CostEstimateImpl: at 1868435115, cost == 32.983999999999995, rowCount == 4.0, singleScanRowCount == 1.0, coveringIndexScan == false, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table 0 for plan type  normal\r\n\r\n\r\n\r\nRemembering join order as best:  1 0 with assignedTableMap = {0, 1}\r\n\r\n\r\nModifying access paths using optimizer 1655768029\r\nChanging access path for table 1\r\nChanging access path for table 0\r\n\"\r\n\r\n--- INCORRECT OPTIMIZER TRACE ---\r\n\r\n\"SELECT * FROM APP.CONFIGURATION_BUNDLE3 T1,\r\nAPP.COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3 t0\r\nWHERE t1.ID = t0.COSEDDROPPROFILEDSCPTABLEBUNDLE_ID and\r\nt0.COSEDDROPPROFILEDSCPTABLEENTRY_ID = 22112129\r\nOptimization started at time 1377549702099 using optimizer 2101481450\r\n\r\n\r\nConsidering join order:  0 with assignedTableMap = {}\r\n\r\n\r\nCalling nextAccessPath() for base table T1 with 0 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0\r\nAdding unordered optimizable, # of predicates = 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 0 is :\r\nLevel2CostEstimateImpl: at 1625417063, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0\r\nLock mode set to MODE_TABLE because no start or stop position\r\nCost of 1.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\n\r\nRemembering join strategy NESTEDLOOP as best for table 0\r\nin best access path\r\nCalling nextAccessPath() for base table T1 with 0 predicates.\r\n\r\nConsidering join strategy HASH for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0\r\nAdding unordered optimizable, # of predicates = 0\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T1 with 0 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} scan for table number 0 is :\r\nLevel2CostEstimateImpl: at 1625417063, cost == 1540600.81, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0\r\nLock mode set to MODE_TABLE because no start or stop position\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 1625417063, cost == 1.5267433370000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\nCost of 1.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 1.5267433370000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\nCalling nextAccessPath() for base table T1 with 0 predicates.\r\n\r\nConsidering join strategy HASH for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T1 with 0 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} for table 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} scan for table number 0 is :\r\nLevel2CostEstimateImpl: at 1625417063, cost == 2359582.402, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0\r\nLock mode set to MODE_TABLE because no start or stop position\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 1625417063, cost == 1.6086414962000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\nCost of 1.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 1.6086414962000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\nCalling nextAccessPath() for base table T1 with 0 predicates.\r\n\r\nConsidering join strategy HASH for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} for table 0\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T1 with 0 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} for table 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} scan for table number 0 is :\r\nLevel2CostEstimateImpl: at 1625417063, cost == 2634793.8619999997, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0\r\nLock mode set to MODE_TABLE because no start or stop position\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 1625417063, cost == 1.6361626422E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\nCost of 1.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 1.6361626422E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\nCalling nextAccessPath() for base table T1 with 0 predicates.\r\n\r\nConsidering join strategy HASH for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} for table 0\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T1 with 0 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\nNo more conglomerates to consider for table 0\r\nTotal cost of non-sort-avoidance plan is Level2CostEstimateImpl: at 245104354, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n\r\n\r\nConsidering join order:  0 1 with assignedTableMap = {0}\r\n\r\n\r\nCalling nextAccessPath() for base table T0 with 2 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1\r\nScanning heap, but we have a full match on a unique key.\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 572153096, cost == 1.2493973484000001E7, rowCount == 4.8248133E7, singleScanRowCount == 4.8248133E7\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 2, extra qualifier selectivity is : 0.010000000000000002\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0\r\nLock mode set to MODE_TABLE because no start or stop position\r\nCost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.2493973484000001E7, rowCount == 482481.3300000001, singleScanRowCount == 482481.3300000001 for table 1\r\nCost of 7003486.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 8.750136837956523E13, rowCount == 7003486.0, singleScanRowCount == 482481.3300000001 for table 1\r\n\r\nRemembering join strategy NESTEDLOOP as best for table 1\r\nin best access path\r\nCalling nextAccessPath() for base table T0 with 2 predicates.\r\n\r\nConsidering join strategy HASH for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1\r\nScanning heap, but we have a full match on a unique key.\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 0\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 572153096, cost == 1.3451277644000001E7, rowCount == 4.8248133E7, singleScanRowCount == 4.8248133E7\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 0.1\r\nLock mode set to MODE_TABLE because no start or stop position\r\nCost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.3451277644000001E7, rowCount == 4824813.3, singleScanRowCount == 4824813.3 for table 1\r\nCost of 7003486.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 1.3451277644000001E7, rowCount == 7003486.0, singleScanRowCount == 4824813.3 for table 1\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.3451277644000001E7, rowCount == 7003486.0, singleScanRowCount == 482481.33 for table 1\r\nSkipping access path due to excess memory usage, maximum is 1048576\r\nCalling nextAccessPath() for base table T0 with 2 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nGuaranteed to match a single row - cost is: 7.8575 for table 1\r\nLock mode set to MODE_RECORD because all start and stop positions are constant\r\nCost of 7003486.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 5.5029891245E7, rowCount == 7003486.0, singleScanRowCount == 1.0 for table 1\r\n\r\nRemembering join strategy NESTEDLOOP as best for table 1\r\nin best access path\r\nCalling nextAccessPath() for base table T0 with 2 predicates.\r\n\r\nConsidering join strategy HASH for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 0\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 572153096, cost == 1.70082898735E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 0.1\r\nLock mode set to MODE_TABLE because no start or stop position\r\nCost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.70082898735E7, rowCount == 4824813.2, singleScanRowCount == 4824813.2 for table 1\r\nCost of 7003486.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 1.70082898735E7, rowCount == 7003486.0, singleScanRowCount == 4824813.2 for table 1\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.70082898735E7, rowCount == 7003486.0, singleScanRowCount == 482481.32000000007 for table 1\r\nSkipping access path due to excess memory usage, maximum is 1048576\r\nCalling nextAccessPath() for base table T0 with 2 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 572153096, cost == 1.3959416302000001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 0.1\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 1, statistics start/stop selectivity is : 1.3264763349989454E-6\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1\r\nCost including extra statistics for index being considered start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 24.802827036771248, rowCount == 64.00000530590533, singleScanRowCount == 64.00000530590533 for table 1\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 572153096, cost == 128.99483567478512, rowCount == 64.00000530590533, singleScanRowCount == 64.00000530590533 for table 1\r\nCost of 7003486.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 9.034135257206582E8, rowCount == 7003486.0, singleScanRowCount == 64.00000530590533 for table 1\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 9.034135257206582E8, rowCount == 7003486.0, singleScanRowCount == 6.400000530590534 for table 1\r\nCalling nextAccessPath() for base table T0 with 2 predicates.\r\n\r\nConsidering join strategy HASH for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 0\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 572153096, cost == 1.4915061182000002E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.010000000000000002\r\nLock mode set to MODE_TABLE because no start or stop position\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 572153096, cost == 9.346302007800001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7 for table 1\r\nCost of 7003486.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 9.346302007800001E7, rowCount == 7003486.0, singleScanRowCount == 4.8248132E7 for table 1\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 9.346302007800001E7, rowCount == 7003486.0, singleScanRowCount == 482481.32000000007 for table 1\r\nSkipping access path due to excess memory usage, maximum is 1048576\r\nCalling nextAccessPath() for base table T0 with 2 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 572153096, cost == 15.715, rowCount == 2.0, singleScanRowCount == 2.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 572153096, cost == 18.971, rowCount == 2.0, singleScanRowCount == 2.0 for table 1\r\nCost of 7003486.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 1.32863132906E8, rowCount == 7003486.0, singleScanRowCount == 2.0 for table 1\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.32863132906E8, rowCount == 7003486.0, singleScanRowCount == 0.2 for table 1\r\nCalling nextAccessPath() for base table T0 with 2 predicates.\r\n\r\nConsidering join strategy HASH for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T0 with 2 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\nNo more conglomerates to consider for table 1\r\nTotal cost of non-sort-avoidance plan is Level2CostEstimateImpl: at 245104354, cost == 5.9364160905E7, rowCount == 7003486.0, singleScanRowCount == 1.0\r\nWe have a complete join order.\r\nThis is the cheapest plan so far.\r\nPlan is a normal plan.\r\nCost of cheapest plan is Level2CostEstimateImpl: at 245104354, cost == 5.9364160905E7, rowCount == 7003486.0, singleScanRowCount == 1.0\r\nRemembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false, costEstimate == Level2CostEstimateImpl: at 2063323644, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0, coveringIndexScan == false, nonMatchingIndexScan == true, joinStrategy == NESTEDLOOP, lockMode == 7, optimizer level == 2 as truly the best for table -1 for plan type  normal\r\n\r\nRemembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false, costEstimate == Level2CostEstimateImpl: at 2063323644, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0, coveringIndexScan == false, nonMatchingIndexScan == true, joinStrategy == NESTEDLOOP, lockMode == 7, optimizer level == 2 as truly the best for table 0 for plan type  normal\r\n\r\nRemembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID}, costEstimate == Level2CostEstimateImpl: at 714552952, cost == 5.5029891245E7, rowCount == 7003486.0, singleScanRowCount == 1.0, coveringIndexScan == true, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table -1 for plan type  normal\r\n\r\nRemembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID}, costEstimate == Level2CostEstimateImpl: at 714552952, cost == 5.5029891245E7, rowCount == 7003486.0, singleScanRowCount == 1.0, coveringIndexScan == true, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table 1 for plan type  normal\r\n\r\n\r\n\r\nRemembering join order as best:  0 1 with assignedTableMap = {0, 1}\r\n\r\n\r\n\r\n\r\nConsidering join order:  1 with assignedTableMap = {}\r\n\r\n\r\nCalling nextAccessPath() for base table T0 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1\r\nAdding unordered optimizable, # of predicates = 1\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 572153096, cost == 1.2493973484000001E7, rowCount == 4.8248133E7, singleScanRowCount == 4.8248133E7\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0\r\nLock mode set to MODE_TABLE because no start or stop position\r\nCost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.2493973484000001E7, rowCount == 4824813.3, singleScanRowCount == 4824813.3 for table 1\r\nCost of 1.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 1.2493973484000001E7, rowCount == 4824813.3, singleScanRowCount == 4824813.3 for table 1\r\nSelectivity from statistics found. It is 2.3194399498852528E-8\r\nCost including extra selectivity from statistics start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.2493973484000001E7, rowCount == 1.11908647187577, singleScanRowCount == 1.11908647187577 for table 1\r\n\r\nRemembering join strategy NESTEDLOOP as best for table 1\r\nin best access path\r\nCalling nextAccessPath() for base table T0 with 1 predicates.\r\n\r\nConsidering join strategy HASH for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1328 name = 989c00e1-0140-b54e-7bb1-ffff93450f77 uuid = a0d440e2-0140-b54e-7bb1-ffff93450f77 indexable = false for table 1\r\nAdding unordered optimizable, # of predicates = 1\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T0 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 572153096, cost == 1.60550464935E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0\r\nLock mode set to MODE_TABLE because no start or stop position\r\nCost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.60550464935E7, rowCount == 4824813.2, singleScanRowCount == 4824813.2 for table 1\r\nCost of 1.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 1.60550464935E7, rowCount == 4824813.2, singleScanRowCount == 4824813.2 for table 1\r\nSelectivity from statistics found. It is 2.3194399498852528E-8\r\nCost including extra selectivity from statistics start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 1.60550464935E7, rowCount == 1.1190864486813705, singleScanRowCount == 1.1190864486813705 for table 1\r\nCalling nextAccessPath() for base table T0 with 1 predicates.\r\n\r\nConsidering join strategy HASH for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1345 name = SQL130825075045880 uuid = 782c40df-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID, COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T0 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 572153096, cost == 1.3959416302000001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1\r\nLock mode set to MODE_TABLE because no start or stop position\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 572153096, cost == 9.250737519800001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7 for table 1\r\nCost of 1.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 9.250737519800001E7, rowCount == 4.8248132E7, singleScanRowCount == 4.8248132E7 for table 1\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 9.250737519800001E7, rowCount == 4824813.2, singleScanRowCount == 4824813.2 for table 1\r\nSelectivity from statistics found. It is 2.3194399498852528E-8\r\nCost including extra selectivity from statistics start/stop selectivity is : Level2CostEstimateImpl: at 572153096, cost == 9.250737519800001E7, rowCount == 1.1190864486813705, singleScanRowCount == 1.1190864486813705 for table 1\r\nCalling nextAccessPath() for base table T0 with 1 predicates.\r\n\r\nConsidering join strategy HASH for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1361 name = SQL130825075046150 uuid = 597e80e5-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEBUNDLE_ID} for table 1\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T0 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} scan for table number 1 is :\r\nLevel2CostEstimateImpl: at 572153096, cost == 7.8575, rowCount == 0.0, singleScanRowCount == 0.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 572153096, cost == 7.8575, rowCount == 0.0, singleScanRowCount == 0.0 for table 1\r\nCost of 1.0 scans is: Level2CostEstimateImpl: at 572153096, cost == 7.8575, rowCount == 0.0, singleScanRowCount == 0.0 for table 1\r\n\r\nRemembering join strategy NESTEDLOOP as best for table 1\r\nin best access path\r\nCalling nextAccessPath() for base table T0 with 1 predicates.\r\n\r\nConsidering join strategy HASH for table 1\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID} for table 1\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T0 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 1\r\nNo more conglomerates to consider for table 1\r\nTotal cost of non-sort-avoidance plan is Level2CostEstimateImpl: at 245104354, cost == 7.8575, rowCount == 0.0, singleScanRowCount == 0.0\r\n\r\n\r\nConsidering join order:  1 0 with assignedTableMap = {1}\r\n\r\n\r\nCalling nextAccessPath() for base table T1 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0\r\nScanning heap, but we have a full match on a unique key.\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 0 is :\r\nLevel2CostEstimateImpl: at 1625417063, cost == 4334269.66, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 1, extra qualifier selectivity is : 0.1\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 1.0\r\nLock mode set to MODE_TABLE because no start or stop position\r\nCost including extra qualifier start/stop selectivity is : Level2CostEstimateImpl: at 1625417063, cost == 4334269.66, rowCount == 700348.6000000001, singleScanRowCount == 700348.6000000001 for table 0\r\nCost of 0.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 0.0, rowCount == 0.0, singleScanRowCount == 700348.6000000001 for table 0\r\n\r\nRemembering join strategy NESTEDLOOP as best for table 0\r\nin best access path\r\nCalling nextAccessPath() for base table T1 with 1 predicates.\r\n\r\nConsidering join strategy HASH for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0\r\nScanning heap, but we have a full match on a unique key.\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 3\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 3\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false scan for table number 0 is :\r\nLevel2CostEstimateImpl: at 1625417063, cost == 4470393.76, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 0.1\r\nLock mode set to MODE_TABLE because no start or stop position\r\nCost of 0.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 4470393.76, rowCount == 0.0, singleScanRowCount == 7003486.0 for table 0\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 1625417063, cost == 4470393.76, rowCount == 0.0, singleScanRowCount == 700348.6000000001 for table 0\r\nSkipping access path due to excess memory usage, maximum is 1048576\r\nCalling nextAccessPath() for base table T1 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0\r\nGuaranteed to match a single row - cost is: 6.286 for table 0\r\nLock mode set to MODE_RECORD because all start and stop positions are constant\r\nCost of 0.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 0.0, rowCount == 0.0, singleScanRowCount == 1.0 for table 0\r\nIndex does not cover query - cost including base row fetch is: 0.0 for table 0\r\nCalling nextAccessPath() for base table T1 with 1 predicates.\r\n\r\nConsidering join strategy HASH for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 0\r\n\r\n# hash key columns = 1hashKeyColumns[0] = 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1281 name = SQL130825075032410 uuid = 2ba7c09b-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {ID} scan for table number 0 is :\r\nLevel2CostEstimateImpl: at 1625417063, cost == 1679861.03, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 0, extra non-qualifier selectivity is : 0.1\r\nLock mode set to MODE_TABLE because no start or stop position\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 1625417063, cost == 1.540669359E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\nCost of 0.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 1.540669359E7, rowCount == 0.0, singleScanRowCount == 7003486.0 for table 0\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 1625417063, cost == 1.540669359E7, rowCount == 0.0, singleScanRowCount == 700348.6000000001 for table 0\r\nSkipping access path due to excess memory usage, maximum is 1048576\r\nCalling nextAccessPath() for base table T1 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} for table 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} scan for table number 0 is :\r\nLevel2CostEstimateImpl: at 1625417063, cost == 2359582.402, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1\r\nLock mode set to MODE_TABLE because no start or stop position\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 1625417063, cost == 1.6086414962000001E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\nCost of 0.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 0.0, rowCount == 0.0, singleScanRowCount == 7003486.0 for table 0\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 1625417063, cost == 0.0, rowCount == 0.0, singleScanRowCount == 700348.6000000001 for table 0\r\nCalling nextAccessPath() for base table T1 with 1 predicates.\r\n\r\nConsidering join strategy HASH for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1297 name = CONFIGURATION_BUNDLE3_IX_2 uuid = 0ddd00a9-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {BUNDLE_NAME} for table 0\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T1 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} for table 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} scan for table number 0 is :\r\nLevel2CostEstimateImpl: at 1625417063, cost == 2634793.8619999997, rowCount == 7003486.0, singleScanRowCount == 7003486.0\r\n        Number of extra first column predicates is : 0, extra first column selectivity is : 1.0\r\n        Number of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n        Number of start/stop statistics predicates is : 0, statistics start/stop selectivity is : 1.0\r\n        Number of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n        Number of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1\r\nLock mode set to MODE_TABLE because no start or stop position\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 1625417063, cost == 1.6361626422E7, rowCount == 7003486.0, singleScanRowCount == 7003486.0 for table 0\r\nCost of 0.0 scans is: Level2CostEstimateImpl: at 1625417063, cost == 0.0, rowCount == 0.0, singleScanRowCount == 7003486.0 for table 0\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 1625417063, cost == 0.0, rowCount == 0.0, singleScanRowCount == 700348.6000000001 for table 0\r\nCalling nextAccessPath() for base table T1 with 1 predicates.\r\n\r\nConsidering join strategy HASH for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1313 name = CONFIGURATION_BUNDLE3_IX_1 uuid = a65c80ac-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {DTYPE} for table 0\r\nSkipping HASH JOIN because there are no hash key columns\r\nCalling nextAccessPath() for base table T1 with 1 predicates.\r\n\r\nConsidering join strategy NESTEDLOOP for table 0\r\nNo more conglomerates to consider for table 0\r\nTotal cost of non-sort-avoidance plan is Level2CostEstimateImpl: at 245104354, cost == 7.8575, rowCount == 0.0, singleScanRowCount == 700348.6000000001\r\nWe have a complete join order.\r\nThis is the cheapest plan so far.\r\nPlan is a normal plan.\r\nCost of cheapest plan is Level2CostEstimateImpl: at 245104354, cost == 7.8575, rowCount == 0.0, singleScanRowCount == 700348.6000000001\r\nRemembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID}, costEstimate == Level2CostEstimateImpl: at 2057836940, cost == 7.8575, rowCount == 0.0, singleScanRowCount == 0.0, coveringIndexScan == false, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table -1 for plan type  normal\r\n\r\nRemembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1377 name = COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY3_IX_0 uuid = 629f40ea-0140-b54e-7bb1-ffff93450f77 indexable = true, key columns = {COSEDDROPPROFILEDSCPTABLEENTRY_ID}, costEstimate == Level2CostEstimateImpl: at 2057836940, cost == 7.8575, rowCount == 0.0, singleScanRowCount == 0.0, coveringIndexScan == false, nonMatchingIndexScan == false, joinStrategy == NESTEDLOOP, lockMode == 6, optimizer level == 2 as truly the best for table 1 for plan type  normal\r\n\r\nRemembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false, costEstimate == Level2CostEstimateImpl: at 959713667, cost == 0.0, rowCount == 0.0, singleScanRowCount == 700348.6000000001, coveringIndexScan == false, nonMatchingIndexScan == true, joinStrategy == NESTEDLOOP, lockMode == 7, optimizer level == 2 as truly the best for table -1 for plan type  normal\r\n\r\nRemembering access path cd == ConglomerateDescriptor: conglomerateNumber = 1264 name = cbf5809d-0140-b54e-7bb1-ffff93450f77 uuid = 6c44409f-0140-b54e-7bb1-ffff93450f77 indexable = false, costEstimate == Level2CostEstimateImpl: at 959713667, cost == 0.0, rowCount == 0.0, singleScanRowCount == 700348.6000000001, coveringIndexScan == false, nonMatchingIndexScan == true, joinStrategy == NESTEDLOOP, lockMode == 7, optimizer level == 2 as truly the best for table 0 for plan type  normal\r\n\r\n\r\n\r\nRemembering join order as best:  1 0 with assignedTableMap = {0, 1}\r\n\r\n\r\nModifying access paths using optimizer 2101481450\r\nChanging access path for table 1\r\nChanging access path for table 0\r\n\"\r\n\r\n\r\nOn Aug 24, 2013, at 8:00 AM, \"Bergquist, Brett\" <BBergquist@canoga.com> wrote:\r\n\r\n> Derby developers (Mike, Manta, Bryan, Rick ,Knut, and if I forgot anyone that has help me in the past), I just want to thank you for your help!   I realize that you guys have day jobs just like me an taking the time out to give me some pointers is really appreciated!\r\n>\r\n> I am trying to produce reduced size and readily reproducible case but would you knot know it, the symptoms change    I saved a database that was working with 10.8.2.2 with (after shutting down) tar cvEf - db | compress >db.8.tar.Z earlier.   So just to verify again that this did indeed work correctly, I restored this database and the 10.8.2.2 libraries performed the queue and darn if the 10.8.2.2 did not exhibit the same problem.    So then last night I deleted the database and created it fresh again from the same exact script that allowed 10.8.2.2 to work and again it still has the same problem.\r\n>\r\n> So now I have no confidence of my test setup and also don't think the issue is confined to 10.9.1.1.   So I will be quiet until I get a case where it works and then understand why and what triggers it to not work.\r\n>\r\n>\r\n> On Aug 23, 2013, at 6:39 PM, mike matrigali <mikemapp1@gmail.com> wrote:\r\n>\r\n>> On 8/23/2013 2:55 PM, Bergquist, Brett wrote:\r\n>>> Mike I would love to open a Jira but having a reproducible case is important as I realize.  Right now, the reproducible database is 2Gb compressed which is really not practical to upload.\r\n>>>\r\n>>> My goal right now is to fix the problem.  The problem is in production, a large telecomm company, and the real database is about 200Gb.  The database has been hard upgraded and has been in use for about 2 weeks so rolling back to backup before the hard upgrade is not possible.  Only going forward is possible.   So I have the debugger connected up right now and am going through the code.  I am also comparing 10.8.2.2 version 10.9.1.0 to look for any suspicious differences.  I have to fix this now, not months from now.\r\n>>>\r\n>>> What would be really useful would be to:\r\n>>>\r\n>>> 1. understand how to turn on the optimizer tracing facility that I see in the 10.9.1.0 source.  For example:\r\n>>>\r\n>>>             optimizerTrace = lcc.getOptimizerTrace();\r\n>>>   I can figure this out, but if anyone can point to a wiki page or some other resource to enable the magic, sharing it will be most welcome.\r\n>> I have not used the following but have been pointed at it by those who do:\r\n>> http://wiki.apache.org/db-derby/OptimizerTracing\r\n>>>\r\n>>> 2. understand if it would be possible to access my test database that has been hard upgraded to 10.9.1.0 with 10.8.2.2.  I know that when I boot the database it will complain and not boot but if I am just doing a read-only query on the database with 10.8.2.2 and the query works, this will give me real confidence that the problem is in the code changes from 10.8.2.2 to 10.9.1.1 and not something related to the structure now stored in the database.\r\n>>>\r\n>>> So I am working on this, am looking for pointers of where to look in the code, and will open a Jira also supply a patch when I have this fixed.\r\n>>\r\n>> this one is hard, definitely nothing is supported to to do this, and no\r\n>> magic property is coming to mind.  If it does not take days to load your\r\n>> test db, I would just build a 10.8 db and load it.\r\n>>\r\n>> Mostly catalog issues are what happen in hard upgrade, so doing a query\r\n>> with old code on a new hard upgrade db \"probably\" works.  But even\r\n>> booting might write stuff that would then be a problem using it later,\r\n>> even if your intent is only to run read-only queries.\r\n>>\r\n>> You could build your own 10.8 and just change the code to skip the\r\n>> checks that don't allow it to boot.  This might work or it might corrupt\r\n>> the db during the boot process.  If you are trying this I would make\r\n>> a copy of the test db to try i on.\r\n>>>\r\n>>\r\n>>\r\n>\r\n>\r\n>\r\n\r\n\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-08-27T16:27:49.953+0000","updated":"2013-08-27T16:27:49.953+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13751406","id":"13751406","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"I think there are multiple things going wrong here, as you point out.  If you have the time can you answer the following\r\nwith you repro case (hopefully someone can come up with a program to create a test case now that we know underlying issue).\r\n\r\n1) can you try the query on some value where there are exactly 2 values, maybe just add another row to the value you know there is\r\n   only one of?  Just wondering if this is an off by 1 bug somewhere.\r\n\r\n2) Do you ever get a bad query plan if you use \"?\" parameters rather than exact values?  I would expect not as it should travel\r\n   a whole different path through the optimizer.\r\n\r\n3) you mention a cost of 0.0 (vs. row count of 0).  Where are you getting that from?  It seems like the btree method is trying \r\n   to always return a non-zero cost.  Just wondering if it is getting lost in the optimizer or if some print routine is not \r\n   printing enough decimals.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-08-27T16:34:34.193+0000","updated":"2013-08-27T16:34:34.193+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13751411","id":"13751411","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"I don't have a lot of experience reading the optimizer cost output.  It seems like cost of scanning millions of \r\nrows should be huge even if you think you are going to get \"0\" rows, so would like to understand if there is a\r\nbug there also.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-08-27T16:36:10.403+0000","updated":"2013-08-27T16:36:10.403+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13751421","id":"13751421","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"From a \"get it done\" perspective, making the routine return 1 row rather than 0 matches similar instances in other\r\nparts of the code (and there is a RESOLVE in the code that asks even if that should be the case).  It is still an\r\nestimate even though it is using real data, so there is always part that is a guess and since we know \"0's\" seem\r\nto cause problems it seem reasonable to me to make it 1.  It matches current assumptions about unique key indexes where\r\nwe return estimates of 1 row for matching key scan, when it could really return either 0 or 1 row.\r\n\r\nIt may hide other\r\nbugs in optimizer costing but seems like a reasonable incremental fix if it seems to fix your bug and passes existing\r\ntests.  \r\n\r\nYour app is definitely exploring areas that have not been tested in Derby.  When that code was written, it is likely no\r\ndisk existed in development that could have held your db.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-08-27T16:44:54.158+0000","updated":"2013-08-27T16:44:54.158+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13751474","id":"13751474","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bbergquist","name":"bbergquist","emailAddress":"brett at thebergquistfamily dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Brett Bergquist","active":true},"body":"Mike's request:\r\n\r\n   1) can you try the query on some value where there are exactly 2 values, maybe just add another row to the value you know there is \r\nonly one of? Just wondering if this is an off by 1 bug somewhere.\r\n\r\nI added a new row which has the same value being queried on (22112129) and the left_of_start and right_of_start still return the same value even though there are now two rows that will be returned in the query.   So it does not look like a off by 1 bug.   I surmise that since it it dealing with percentages and these are floating point, non-exact values, that what is happening is that sometimes the percentage of the result space starting and stopping regions are so close that the percentages become equivalent.\r\n\r\n   3) The BtreeCostController is probably never returning a 0.0 cost, but in FromBaseTable.java, we have:\r\n\r\n\r\n\t\t\t/*\r\n\t\t\t** Let the join strategy decide whether the cost of the base\r\n\t\t\t** scan is a single scan, or a scan per outer row.\r\n\t\t\t** NOTE: The multiplication should only be done against the\r\n\t\t\t** total row count, not the singleScanRowCount.\r\n\t\t\t*/\r\n\t\t\tdouble newCost = costEstimate.getEstimatedCost();\r\n\r\n\t\t\tif (currentJoinStrategy.multiplyBaseCostByOuterRows())\r\n\t\t\t{\r\n\t\t\t\tnewCost *= outerCost.rowCount();\r\n\t\t\t}\r\n\r\n\t\t\tcostEstimate.setCost(\r\n\t\t\t\tnewCost,\r\n\t\t\t\tcostEstimate.rowCount() * outerCost.rowCount(),\r\n\t\t\t\tcostEstimate.singleScanRowCount());\r\n\r\nSo if the row count of the outer table of the join is 0.0, the newCost can end up being 0.0, even though the cost for the table being processed is very large.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bbergquist","name":"bbergquist","emailAddress":"brett at thebergquistfamily dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Brett Bergquist","active":true},"created":"2013-08-27T17:29:36.092+0000","updated":"2013-08-27T17:29:36.092+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13751549","id":"13751549","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bbergquist","name":"bbergquist","emailAddress":"brett at thebergquistfamily dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Brett Bergquist","active":true},"body":"Mikes request:\r\n\r\n   2) Do you ever get a bad query plan if you use \"?\" parameters rather than exact values? I would expect not as it should travel\r\na whole different path through the optimizer.\r\n\r\nI tried this and what happens is that BtreeCostController.getScanCost is called with null values for startKeyValue and stopKeyValue.  This causes the left_of_start to be set to 0.0 and left_of_stop to be set to 1.0, effectively causing this to estimate that the complete range of index values are going to be processed.\r\n\r\nThen the selectivity as defined by the statistics take more effect.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bbergquist","name":"bbergquist","emailAddress":"brett at thebergquistfamily dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Brett Bergquist","active":true},"created":"2013-08-27T18:24:09.453+0000","updated":"2013-08-27T18:30:19.358+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13751616","id":"13751616","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"for question #2, is the query plan \"correct\" when you use \"?\" parameter?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-08-27T19:25:03.014+0000","updated":"2013-08-27T19:25:03.014+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13751678","id":"13751678","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bbergquist","name":"bbergquist","emailAddress":"brett at thebergquistfamily dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Brett Bergquist","active":true},"body":"It does choose a valid and optimal one but because the BtreeCostController is really not coming into play.  That is returning all rows as the estimate row count.  So for example, for a 7M row table, the estimate row count is 7M and the cost is very high because of the other calculations done in there (ie. cost += (estimated_row_count * row_size) * BASE_ROW_PER_BYTECOST).\r\n\r\nThen FromBaseTable uses the statistics selectivity in the final cost computation.\r\n\r\nSo the answer is yes it gets a \"correct\" plan, but though a different computation of the cost.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bbergquist","name":"bbergquist","emailAddress":"brett at thebergquistfamily dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Brett Bergquist","active":true},"created":"2013-08-27T20:26:22.948+0000","updated":"2013-08-27T20:26:22.948+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13751680","id":"13751680","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"i do see a lot of cost *= cost and rowcount = rowcount1 * rowcount2 kinds of code in the optimizer, so even more\r\nreason not to return 0 out of the store costs.  \r\n\r\nI guess the optmizer model might not be wrong if it is actually the case that if there were 0 rows in the outer table that\r\nit would actually not do the full scan.  But since these are all estimates seems like there always should be some cost that\r\nis linearly related to number of rows scanned if there are actually not 0 rows.  better to be a little pessimistic and return\r\n1 row rather 0.  \r\n\r\nThere may be ways to make that btree code be smarter when it is returning a very small number of rows, especially if the\r\nstart search and stop search are actually the same page.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-08-27T20:28:34.128+0000","updated":"2013-08-27T20:28:34.128+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13751708","id":"13751708","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":">It does choose a valid and optimal one but because the BtreeCostController is really not coming into play. That is returning all rows as the >estimate row count. So for example, for a 7M row table, the estimate row count is 7M and the cost is very high because of the other >calculations done in there (ie. cost += (estimated_row_count * row_size) * BASE_ROW_PER_BYTECOST).\r\n\r\n>Then FromBaseTable uses the statistics selectivity in the final cost computation.\r\n\r\n>So the answer is yes it gets a \"correct\" plan, but though a different computation of the cost.\r\n\r\ngood, just wanted to make sure that there was not a bug in that area also.  I believe this is working as designed, picking\r\na correct plan for the \"average\" possible value - since this compiled plan then can be used over and over by different values.\r\nThis is what we usually recommend to users to avoid a recompile cost on every execution, which may be why this bug has \r\nexisted for a long time.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-08-27T20:53:07.467+0000","updated":"2013-08-27T20:53:07.467+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13751906","id":"13751906","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"Here is a patch against trunk to get some feedback for \r\nthe discussion.  It simply always returns \r\nat least one row as the estimated rows returned whenever store is asked how many rows qualify for a particular range of an\r\nindex scan (in store asking for 1 key is still a range scan where the start is >= key and stop is > key).\r\n\r\nI have no repro at this point, but would like to check one in with any fix.  If the\r\nrepro really needs 47 million rows would likely not include it in nightly tests, and instead add it to the large data tests.\r\n\r\nRunning existing tests now to see if this causes any problems with existing tests.  All tests passed on this initial patch,\r\nand Brett reports it fixed the issue in his database.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-08-27T23:43:48.737+0000","updated":"2013-08-28T18:08:03.890+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13752338","id":"13752338","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bbergquist","name":"bbergquist","emailAddress":"brett at thebergquistfamily dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Brett Bergquist","active":true},"body":"I have the patch applied and it fixes the estimated row cost.  \r\n\r\nBut if you look farther above, the estimated_row_count is computed from the ret_fraction (which can end up as 0.0 if the left_of_start and left_of_stop are the same) and this is used in computing the initial cost and later used in computed the cached_row_count which is also used in computing the cost.\r\n\r\nMight it not be useful to have the estimated_row_count be set to \"1\" when the ret_fraction is 0.0 so that these other calculations are based the one row?  This is nearly what would happen if in the example above with 48 million rows, that the left_of_start returned 0.07715294 and the left_of_stop returned 0.07715295, the estimated_row_count would be .48 rows.  That way the cost does not become 0.0 when the left_of_start and left_of_stop are the same.\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bbergquist","name":"bbergquist","emailAddress":"brett at thebergquistfamily dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Brett Bergquist","active":true},"created":"2013-08-28T12:25:39.644+0000","updated":"2013-08-28T12:25:39.644+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13752645","id":"13752645","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"This second patch addresses brett's comment about making cost return based on 1 row.  This version moves the default setting of a minimum of 1 row returned up in the routine so that all other calculations are based on at least 1 row being returned.\r\n\r\nWill run full tests on this version.  This patch also passed full tests on trunk.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-08-28T18:07:10.993+0000","updated":"2013-08-28T23:11:45.319+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13753303","id":"13753303","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I am trying to see if I can reproduce the problem. I am trying it right now with 8million rows in the table which I think looks like the table Brett has but with 48million rows. When I tried 800,000 rows, the problem did not reproduce. I will post the result of that run when it is finished but I wanted to share the test code to make sure I am mimicking Brett's tables and indexes correctly. Please let me know if the test code needs to be changed to match the problem schema. I have also added a println in BTreeCostController.getScanCost as follows\r\n            if (ret_fraction < 0) {\r\n                //added following println\r\n            \tSystem.out.println(\"In engine code with ret_fraction<0\");\r\n                ret_fraction = 0;\r\n            }\r\nI think when the test runs into estimated row count of 0, we will hit the piece of code above and will see the println printed.\r\n\r\nRun the program as follows\r\njava  org.apache.derbyTesting.functionTests.tests.lang.MamtaJDBC  > dellater.txt\r\n\r\nThe output from the program will look as follows\r\nTesting embedded\r\nfinished creating tables\r\nTable1 -    done inserting data\r\nTable3 - done inserting data\r\nTable2 - done inserting data\r\ndone inserting data\r\nt0.Table3_ID =0\r\nt0.Table3_ID =1\r\nt0.Table3_ID =2\r\n.....\r\n\r\nAnd hopefully at some point, we will see \"In engine code with ret_fraction<0\" in the output printed by the test program.\r\n\r\n\r\n\r\npackage org.apache.derbyTesting.functionTests.tests.lang;\r\n\r\nimport java.net.*; \r\nimport java.io.*; \r\nimport java.sql.*;\r\n\r\n/** \r\n * Client template starts its own NetworkServer and runs some SQL against it. \r\n * The SQL or JDBC API calls can be modified to reproduce issues \r\n * \r\n */\r\npublic class MamtaJDBC { \r\n\t\r\n    public static void main(String[] args) throws Exception {\r\n    \t//Make Derby use index\r\n    \tConnection conn=null;\r\n    \tStatement s;\r\n    \tPreparedStatement ps;\r\n        \tSystem.out.println(\"Testing embedded\");\r\n            Class.forName(\"org.apache.derby.jdbc.EmbeddedDriver\");\r\n            try{\r\n                conn = DriverManager.getConnection(\"jdbc:derby:c:/dellater/ClobTest3;create=true\");\r\n            }catch(Exception ex){}\r\n    \ts = conn.createStatement();\r\n        try { \r\n            s.executeUpdate(\"DROP TABLE Table2\"); \r\n        } catch (SQLException se) { \r\n            if (!se.getSQLState().equals(\"42Y55\")) \r\n                throw se; \r\n        } \r\n        try { \r\n            s.executeUpdate(\"DROP TABLE Table1\"); \r\n        } catch (SQLException se) { \r\n            if (!se.getSQLState().equals(\"42Y55\")) \r\n                throw se; \r\n        } \r\n        try { \r\n            s.executeUpdate(\"DROP TABLE Table3\"); \r\n        } catch (SQLException se) { \r\n            if (!se.getSQLState().equals(\"42Y55\")) \r\n                throw se; \r\n        }\r\n        //equivalent to Bret's table \"CORE_V1\".\"CONFIGURATION_BUNDLE\"\r\n        s.executeUpdate(\"CREATE TABLE Table1 (\"+\r\n        \t\t\"ID int PRIMARY KEY NOT NULL)\"); \r\n        //equivalent to Bret's table \"PKG_9145E_V1\".\"COSEDDROPPROFILEDSCPTABLEBUNDLE_COSEDDROPPROFILEDSCPTABLEENTRY\"\r\n        s.executeUpdate(\"CREATE TABLE Table2 (\"+\r\n        \t\t\"Table1_ID int NOT NULL,\"+\r\n        \t\t\"Table3_ID int NOT NULL,\"+\r\n        \t\t\"CONSTRAINT TABLE2_PK PRIMARY KEY \"+\r\n        \t\t\"(Table1_ID,Table3_ID))\");\r\n        //equivalent to Bret's table \"PKG_9145E_V1\".\"COS_ED_DROP_PROFILE_DSCP_QMAPPING\"\r\n        s.executeUpdate(\"CREATE TABLE Table3 (\"+\r\n        \t\t\"ID int PRIMARY KEY NOT NULL)\"); \r\n        \r\n        s.executeUpdate(\"ALTER TABLE table2 \"+\r\n        \t\t\"ADD CONSTRAINT TABLE2_FK_1 \"+\r\n        \t\t\"FOREIGN KEY (Table1_ID) \"+\r\n        \t\t\"REFERENCES TABLE1(ID)\");\r\n        s.executeUpdate(\"ALTER TABLE table2 \"+\r\n        \t\t\"ADD CONSTRAINT TABLE2_FK_2 \"+\r\n        \t\t\"FOREIGN KEY (Table3_ID) \"+\r\n        \t\t\"REFERENCES TABLE3(ID)\");\r\n        System.out.println(\"finished creating tables\");\r\n\t      int count = 1000000; \r\n\t      ps = conn.prepareStatement(\"INSERT INTO table1 VALUES (?)\");\r\n  \t      for (int i = 0; i < count; i++) { \r\n  \t    \t  ps.setInt(1,i);\r\n  \t        ps.execute();\r\n\t      } \r\n  \t      System.out.println(\"Table1 -    done inserting data\");\r\n\t      count = 8000000; \r\n\t      ps = conn.prepareStatement(\"INSERT INTO table3 VALUES (?)\");\r\n  \t      for (int i = 0; i < count; i++) { \r\n  \t    \t  ps.setInt(1,i);\r\n    \t        ps.execute();\r\n\t      } \r\n  \t      System.out.println(\"Table3 - done inserting data\");\r\n\t      count = 1000000; \r\n\t      ps = conn.prepareStatement(\"INSERT INTO table2 VALUES (?,?)\");\r\n  \t      for (int i = 0; i < count; i++) { \r\n\t  \t    \t  ps.setInt(1,i);\r\n  \t    \t  int j=0;\r\n  \t    \t  for (int k=0; k<8; k++,j++) {\r\n  \t    \t\t  ps.setInt(2,j);\r\n  \t              ps.execute();\r\n  \t    \t  }\r\n\t      } \r\n  \t      System.out.println(\"Table2 - done inserting data\");\r\n  \t      System.out.println(\"done inserting data\");\r\n\t      count = 8000000; \r\n  \t      for (int i = 0; i < count; i++) { \r\n  \t    \t  System.out.println(\"t0.Table3_ID =\"+i);\r\n  \t    \t  s.execute(\"SELECT * FROM \"+\r\n  \t    \t    \t  \"Table1 T1,\"+\r\n     \t\t\t  \"Table2 t0 \"+\r\n  \t    \t    \t  \"WHERE t1.ID = t0.Table1_ID and \"+\r\n     \t\t\t  \"t0.Table3_ID = \"+i);\r\n  \t      }\r\n  \t      System.out.println(\"done testing\");\r\n    }\r\n}","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-08-29T04:48:43.435+0000","updated":"2013-08-29T04:48:43.435+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13753553","id":"13753553","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bbergquist","name":"bbergquist","emailAddress":"brett at thebergquistfamily dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Brett Bergquist","active":true},"body":"Mamta, just confirming that what you have represents the real tables that I have. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bbergquist","name":"bbergquist","emailAddress":"brett at thebergquistfamily dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Brett Bergquist","active":true},"created":"2013-08-29T12:21:14.988+0000","updated":"2013-08-29T12:21:14.988+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13753682","id":"13753682","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Thanks for looking at the program, Brett.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-08-29T14:48:07.859+0000","updated":"2013-08-29T14:48:07.859+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13753732","id":"13753732","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"not sure exactly where you are putting your code in BTreeCostController but what you posted may not catch\r\nall the cases we are looking for.  I think there are some cases where the ret_fraction is very small such\r\nthat ret_fraction * number of rows gives back a number of rows > 0 but less than 0.5 and the code then\r\nrounds the number of rows to 0. I would suggest instrumenting the code near the end of the routine looking\r\nfor estimated_row_count < 0.5","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-08-29T15:33:26.514+0000","updated":"2013-08-29T15:33:26.514+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13753739","id":"13753739","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"also if you want to significantly improve the performance of your load I suggest turning off autocommit and  \r\ncommit every so often.  maybe every 10k or 100k inserts.\r\n\r\nI am not sure of this suggestion, but it might be worth trying 3 queries, that vary i.  Try:\r\ni = 0\r\ni = some value in the middle of the range\r\ni = largest value in range ( i think this is the one you are trying).","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-08-29T15:40:29.099+0000","updated":"2013-08-29T15:40:29.099+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13753824","id":"13753824","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bbergquist","name":"bbergquist","emailAddress":"brett at thebergquistfamily dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Brett Bergquist","active":true},"body":"I ended up doing both, returning 1 as the estimated_row_count after detecting ret_fraction == 0 and then at the bottom, I made sure that the rounding did not end up causing an estimated row count == 0.   I saw this happen in my testing even when I did the first change after the ret_fraction and saw table scans in my logging which prompted me to go back in and put in the test after rounding.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bbergquist","name":"bbergquist","emailAddress":"brett at thebergquistfamily dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Brett Bergquist","active":true},"created":"2013-08-29T17:17:17.571+0000","updated":"2013-08-29T17:17:17.571+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13755348","id":"13755348","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I had to make a change to the earlier test program since that program was inserting duplicate values in non-unique foreign key on Table2. It now inserts all unique values in foreign key corresponding to Table3 and I have been able to reproduce the problem. I have attached the repro test case as testRepro_v1.txt. The program creates threee tables as shown below\r\n        CREATE TABLE Table1 (ID int PRIMARY KEY NOT NULL);\r\n        CREATE TABLE Table2 (Table1_ID int NOT NULL, Table3_ID int NOT NULL,\r\n\t\tCONSTRAINT TABLE2_PK PRIMARY KEY (Table1_ID,Table3_ID));\r\n        CREATE TABLE Table3 (ID int PRIMARY KEY NOT NULL); \r\n\r\n        ALTER TABLE table2 ADD CONSTRAINT TABLE2_FK_1 FOREIGN KEY (Table1_ID) REFERENCES TABLE1(ID);\r\n        ALTER TABLE table2 ADD CONSTRAINT TABLE2_FK_2 FOREIGN KEY (Table3_ID) REFERENCES TABLE3(ID);\r\n\r\nThe program inserts 1million rows in Table1 and 8 million rows in both Table2 and Table3. After the data is loaded, it selects each of the 8 million rows from Table2 individually with a query like following(the constant assigned to\r\nt0.Table3_ID iterates from 0 to 8million-1).\r\nSELECT count(*) FROM \r\n\tTable1 T1,\r\n\tTable2 t0 \r\n\tWHERE t1.ID = t0.Table1_ID and \r\n\t\tt0.Table3_ID = 0;\r\n\r\nAdditionally, I have two printlns in BTreeCostController.getScanCost towards the bottom of the method. I have attached svn diff for changes in BTreeCostController.getScanCost as DERBY_6317_temp_changes_for_debugging.txt. The method will also have the changes suggested by Mike in his second patch but those changes are commented out.\r\n\t\t.....\r\n\t\t//Added this println and if statement with println. The rest of the code is unchanged\r\n        \tSystem.out.println(\"In engine estimated row count is \" + estimated_row_count);\r\n        \tif (estimated_row_count < 0.5)\r\n\t            \tSystem.out.println(\"We are going to round estimated row count to 0\");\r\n            // RESOLVE - should we make sure this number is > 0?\r\n            cost_result.setEstimatedRowCount(Math.round(estimated_row_count));\r\n        }\r\n        finally\r\n\r\nRun the test program after making the changes in BTreeCostController.getScanCost as follows.\r\njava org.apache.derbyTesting.functionTests.tests.lang.MamtaJDBC > dellater.txt\r\nIt will produce a really large dellater.txt. notepad couldn't open the file because of it's size. I did grep on the file to look for string \"We are going to round estimated row count to 0\" and found number of occurences of it. An example of the string were as follows\r\n./dellater2.txt:51892862:We are going to round estimated row count to 0\r\n./dellater2.txt:51892866:We are going to round estimated row count to 0\r\n./dellater2.txt:51892904:We are going to round estimated row count to 0\r\n./dellater2.txt:51892908:We are going to round estimated row count to 0\r\n./dellater2.txt:51892946:We are going to round estimated row count to 0\r\n./dellater2.txt:51892950:We are going to round estimated row count to 0\r\n./dellater2.txt:51892988:We are going to round estimated row count to 0\r\n./dellater2.txt:51892992:We are going to round estimated row count to 0\r\n./dellater2.txt:51893030:We are going to round estimated row count to 0\r\n./dellater2.txt:51893034:We are going to round estimated row count to 0\r\n./dellater2.txt:51893072:We are going to round estimated row count to 0\r\n.....\r\n\r\nI picked the first line from grep output above and used that line number to find the value of the constant in the SELECT query that resulted in estimated row count to be rounded to 0 and found following\r\n$ head -n 51892862 dellater2.txt | tail -n 10\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 0.9536743\r\nIn engine estimated row count is 1000005.0\r\nt0.Table3_ID =5189284\r\nIn engine estimated row count is 1000005.0\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 0.47683716\r\nWe are going to round estimated row count to 0\r\n\r\nNext, I tried that t0.Table3_ID =5189284 value directly in ij with log query plan on and could see in derby.log that we are doing table scan for the inner(right) resultset. I tried value one higher than the problem ID value and saw that we use index scan for that SELECT query.\r\n$ java -Dderby.language.logQueryPlan=true -Dij.exceptionTrace=true org.apache.derby.tools.ij\r\nij version 10.11\r\nij> connect 'jdbc:derby:clobtest3';\r\nij> SELECT count(*) FROM\r\n        Table1 T1,\r\n        Table2 t0\r\n        WHERE t1.ID = t0.Table> 1_ID and\r\n                t0.Tabl> e3_ID = 5189284 ;\r\nIn engine estimated row count is 1000005.0\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 0.47683716\r\nWe are going to round estimated row count to 0\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 0.47683716\r\nWe are going to round estimated row count to 0\r\nIn engine estimated row count is 1000005.0\r\n1\r\n-----------\r\n1\r\n\r\n1 row selected\r\nij> SELECT count(*) FROM\r\n        Table1 T1,\r\n        Table2 t0\r\n        WHERE t1.ID = t0.Table1_ID and\r\n              t0.Table3_ID = 5189285;\r\nIn engine estimated row count is 1000005.0\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 0.9536743\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 0.9536743\r\nIn engine estimated row count is 1000005.0\r\n1\r\n-----------\r\n1\r\n\r\n1 row selected\r\n\r\n\r\nI applied Mike's 2nd patch which check if estimated row count is less than <.5 and if so, it assigns value 1 to estimated row count. With that patch, I ran the 2 queries again in ij against the database and saw that we are indeed using index scan for both the queries. So, the patch definitely fixed the problem with the repro db I have created.\r\n\r\nThe test program takes over 4-5hours to load the data and run 8millions selects.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-08-31T01:56:19.259+0000","updated":"2013-08-31T01:56:19.259+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13755556","id":"13755556","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"It turns out most of the time in the test is taken in executing the selects.  For a sane classes run I got the following\r\ntimes for the load:\r\nfinished creating tables\r\nTable1 - done inserting data, num rows = 1000000\r\nTable1 -    inserting data executed in ms: 44513\r\nTable3 - done inserting data, num rows = 8000000\r\nTable3 -    inserting data executed in ms: 399121\r\nTable2 - done inserting data, num rows = 1000000\r\nTable2 -    inserting data executed in ms: 1272520\r\n\r\n\r\nso a total of around 10 minutes to load 1 million + 8 million + 1 million rows.  The load time could likely\r\nbe reduced by first creating the tables with no primary keys, constraints, or indexes and adding them after\r\nthe data has been loaded.  \r\n\r\nI was not running with all the prints, as it is likely that was also slowing down the system.\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-08-31T17:11:14.358+0000","updated":"2013-08-31T17:11:14.358+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13757977","id":"13757977","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I have been working on a junit test for this jira and for some strange reason, the problem does not reproduce yet. The test is based on the stand alone test case. I had made one optimization in the junit test case to create the indexes after the database was loaded and that is when the problem did not reproduce. Since then, I have removed the optimization so now the junit test looks similar to stand alone test case and I have fired that junit run this morning. Will post the results when the test is over. I did want to mention that the data load takes close to 45minutes with the test. Mike mentioned in his case it took only 10 minutes. I am attaching a patch for junit test DERBY_6317_junit_test_v1_diff.txt. May be Mike or some one else can see why the load in my case is taking much longer. This patch is not ready for commit. The patch has some changes to largedata suite, please ignore it. I commented out other largedata tests so I can focus on just my junit repro.\r\n\r\nI am running on Windows 7 machine with IBM jdk 1.6","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-09-04T17:10:41.281+0000","updated":"2013-09-04T17:10:41.281+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13758140","id":"13758140","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"you are right mamta i had not timed the load, just did the printouts above.  I did not notice that the Table2 load\r\nhad a loop of 1mill and an inner loop of 8.  So the num rows printed was wrong, and I missed a decimal point when\r\nI was adding the time in my head.  The Table2 load took 1272 seconds, more like 20 minutes for it + 10 minutes for Table 3 and 1 minute\r\nfor table 1.  So 34 minutes which is a lot closer to what you  were getting.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-09-04T18:34:40.993+0000","updated":"2013-09-04T18:34:40.993+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13758166","id":"13758166","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Thanks for double checking Mike. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-09-04T18:50:36.677+0000","updated":"2013-09-04T18:50:36.677+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13758169","id":"13758169","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I realized I have not posted the query plans for the index scan vs table scan cases. I will post them in next two comments for easier read.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-09-04T18:53:09.707+0000","updated":"2013-09-04T18:53:09.707+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13758172","id":"13758172","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"The following query plan is when we are doing table scan of TABLE1 instead of index scan. Note the value in SELECT for indexed column is 5189284\r\n\r\nWed Sep 04 11:47:25 PDT 2013 Thread[main,5,main] (XID = 767109), (SESSIONID = 1), SELECT count(*) FROM \r\n\tTable1 T1,\r\n\tTable2 t0 \r\n\tWHERE t1.ID = t0.Table1_ID and \r\n\t\tt0.Table3_ID = 5189284 ******* Project-Restrict ResultSet (7):\r\nNumber of opens = 1\r\nRows seen = 1\r\nRows filtered = 0\r\nrestriction = false\r\nprojection = true\r\n\tconstructor time (milliseconds) = 0\r\n\topen time (milliseconds) = 0\r\n\tnext time (milliseconds) = 0\r\n\tclose time (milliseconds) = 0\r\n\trestriction time (milliseconds) = 0\r\n\tprojection time (milliseconds) = 0\r\n\toptimizer estimated row count: 1.00\r\n\toptimizer estimated cost: 6.33\r\nSource result set:\r\n\tScalar Aggregate ResultSet:\r\n\tNumber of opens = 1\r\n\tRows input = 1\r\n\t\tconstructor time (milliseconds) = 0\r\n\t\topen time (milliseconds) = 0\r\n\t\tnext time (milliseconds) = 0\r\n\t\tclose time (milliseconds) = 0\r\n\t\toptimizer estimated row count: 0.00\r\n\t\toptimizer estimated cost: 6.33\r\n\tIndex Key Optimization = false\r\n\tSource result set:\r\n\t\tProject-Restrict ResultSet (6):\r\n\t\tNumber of opens = 1\r\n\t\tRows seen = 1\r\n\t\tRows filtered = 0\r\n\t\trestriction = false\r\n\t\tprojection = true\r\n\t\t\tconstructor time (milliseconds) = 0\r\n\t\t\topen time (milliseconds) = 0\r\n\t\t\tnext time (milliseconds) = 0\r\n\t\t\tclose time (milliseconds) = 0\r\n\t\t\trestriction time (milliseconds) = 0\r\n\t\t\tprojection time (milliseconds) = 0\r\n\t\t\toptimizer estimated row count: 0.00\r\n\t\t\toptimizer estimated cost: 6.33\r\n\t\tSource result set:\r\n\t\t\tNested Loop Join ResultSet:\r\n\t\t\tNumber of opens = 1\r\n\t\t\tRows seen from the left = 1\r\n\t\t\tRows seen from the right = 1\r\n\t\t\tRows filtered = 0\r\n\t\t\tRows returned = 1\r\n\t\t\t\tconstructor time (milliseconds) = 0\r\n\t\t\t\topen time (milliseconds) = 0\r\n\t\t\t\tnext time (milliseconds) = 0\r\n\t\t\t\tclose time (milliseconds) = 0\r\n\t\t\t\toptimizer estimated row count: 0.00\r\n\t\t\t\toptimizer estimated cost: 6.33\r\n\t\t\tLeft result set:\r\n\t\t\t\tIndex Row to Base Row ResultSet for TABLE2:\r\n\t\t\t\tNumber of opens = 1\r\n\t\t\t\tRows seen = 1\r\n\t\t\t\tColumns accessed from heap = {0, 1}\r\n\t\t\t\t\tconstructor time (milliseconds) = 0\r\n\t\t\t\t\topen time (milliseconds) = 0\r\n\t\t\t\t\tnext time (milliseconds) = 0\r\n\t\t\t\t\tclose time (milliseconds) = 0\r\n\t\t\t\t\toptimizer estimated row count: 0.00\r\n\t\t\t\t\toptimizer estimated cost: 6.33\r\n\t\t\t\t\tIndex Scan ResultSet for TABLE2 using constraint TABLE2_FK_2 at read committed isolation level using instantaneous share row locking chosen by the optimizer\r\n\t\t\t\t\tNumber of opens = 1\r\n\t\t\t\t\tRows seen = 1\r\n\t\t\t\t\tRows filtered = 0\r\n\t\t\t\t\tFetch Size = 16\r\n\t\t\t\t\t\tconstructor time (milliseconds) = 0\r\n\t\t\t\t\t\topen time (milliseconds) = 0\r\n\t\t\t\t\t\tnext time (milliseconds) = 0\r\n\t\t\t\t\t\tclose time (milliseconds) = 0\r\n\t\t\t\t\t\tnext time in milliseconds/row = 0\r\n\r\n\t\t\t\t\tscan information:\r\n\t\t\t\t\t\tBit set of columns fetched=All\r\n\t\t\t\t\t\tNumber of columns fetched=2\r\n\t\t\t\t\t\tNumber of deleted rows visited=0\r\n\t\t\t\t\t\tNumber of pages visited=4\r\n\t\t\t\t\t\tNumber of rows qualified=1\r\n\t\t\t\t\t\tNumber of rows visited=2\r\n\t\t\t\t\t\tScan type=btree\r\n\t\t\t\t\t\tTree height=-1\r\n\t\t\t\t\t\tstart position:\r\n\t\t\t\t\t\t\t>= on first 1 column(s).\r\n\t\t\t\t\t\t\tOrdered null semantics on the following columns: \r\n\t\t\t\t\t\t\t0 \r\n\t\t\t\t\t\tstop position:\r\n\t\t\t\t\t\t\t> on first 1 column(s).\r\n\t\t\t\t\t\t\tOrdered null semantics on the following columns: \r\n\t\t\t\t\t\t\t0 \r\n\t\t\t\t\t\tqualifiers:\r\n\t\t\t\t\t\t\tNone\r\n\t\t\t\t\t\toptimizer estimated row count: 0.00\r\n\t\t\t\t\t\toptimizer estimated cost: 6.33\r\n\r\n\t\t\tRight result set:\r\n\t\t\t\tTable Scan ResultSet for TABLE1 at read committed isolation level using instantaneous share row locking chosen by the optimizer\r\n\t\t\t\tNumber of opens = 1\r\n\t\t\t\tRows seen = 1\r\n\t\t\t\tRows filtered = 0\r\n\t\t\t\tFetch Size = 16\r\n\t\t\t\t\tconstructor time (milliseconds) = 0\r\n\t\t\t\t\topen time (milliseconds) = 0\r\n\t\t\t\t\tnext time (milliseconds) = 0\r\n\t\t\t\t\tclose time (milliseconds) = 0\r\n\t\t\t\t\tnext time in milliseconds/row = 0\r\n\r\n\t\t\t\tscan information:\r\n\t\t\t\t\tBit set of columns fetched=All\r\n\t\t\t\t\tNumber of columns fetched=1\r\n\t\t\t\t\tNumber of pages visited=7300\r\n\t\t\t\t\tNumber of rows qualified=1\r\n\t\t\t\t\tNumber of rows visited=1000000\r\n\t\t\t\t\tScan type=heap\r\n\t\t\t\t\tstart position:\r\n\t\t\t\t\t\tnull\r\n\t\t\t\t\tstop position:\r\n\t\t\t\t\t\tnull\r\n\t\t\t\t\tqualifiers:\r\n\t\t\t\t\t\tColumn[0][0] Id: 0\r\n\t\t\t\t\t\tOperator: =\r\n\t\t\t\t\t\tOrdered nulls: false\r\n\t\t\t\t\t\tUnknown return value: false\r\n\t\t\t\t\t\tNegate comparison result: false\r\n\t\t\t\t\toptimizer estimated row count: 0.00\r\n\t\t\t\t\toptimizer estimated cost: 0.00\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-09-04T18:55:01.953+0000","updated":"2013-09-04T18:55:01.953+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13758183","id":"13758183","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"The following query plan is when we are doing index scan of TABLE1 which is the correct behavior. Note the value in SELECT for indexed column is 5189285 (just one higher than the 5189284 where we use table scan)\r\n----------------------------------------------------------------\r\nWed Sep 04 11:55:19 PDT 2013:\r\nBooting Derby version The Apache Software Foundation - Apache Derby - 10.11.0.0 alpha - (1): instance a816c00e-0140-ea54-2a4c-00000022b220 \r\non database directory C:\\p4clients\\svnmain\\client3\\trunk\\systest\\del\\ClobTest3 with class loader sun.misc.Launcher$AppClassLoader@53745374 \r\nLoaded from file:/C:/p4clients/svnmain/client3/trunk/classes/\r\njava.vendor=IBM Corporation\r\njava.runtime.version=pwi3260sr14-20130705_01 (SR14)\r\njava.fullversion=JRE 1.6.0 IBM J9 2.4 Windows 7 x86-32 jvmwi3260sr14-20130704_155156 (JIT enabled, AOT enabled)\r\nJ9VM - 20130704_155156\r\nJIT  - r9_20130517_38390\r\nGC   - GA24_Java6_SR14_20130704_1138_B155156\r\nuser.dir=C:\\p4clients\\svnmain\\client3\\trunk\\systest\\del\r\nos.name=Windows 7\r\nos.arch=x86\r\nos.version=6.1 build 7601 Service Pack 1\r\nderby.system.home=null\r\nDatabase Class Loader started - derby.database.classpath=''\r\nWed Sep 04 11:55:24 PDT 2013 Thread[main,5,main] (XID = 767118), (SESSIONID = 1), SELECT count(*) FROM \r\n\tTable1 T1,\r\n\tTable2 t0 \r\n\tWHERE t1.ID = t0.Table1_ID and \r\n\t\tt0.Table3_ID = 5189285 ******* Project-Restrict ResultSet (7):\r\nNumber of opens = 1\r\nRows seen = 1\r\nRows filtered = 0\r\nrestriction = false\r\nprojection = true\r\n\tconstructor time (milliseconds) = 0\r\n\topen time (milliseconds) = 0\r\n\tnext time (milliseconds) = 0\r\n\tclose time (milliseconds) = 0\r\n\trestriction time (milliseconds) = 0\r\n\tprojection time (milliseconds) = 0\r\n\toptimizer estimated row count: 1.00\r\n\toptimizer estimated cost: 12.72\r\nSource result set:\r\n\tScalar Aggregate ResultSet:\r\n\tNumber of opens = 1\r\n\tRows input = 1\r\n\t\tconstructor time (milliseconds) = 0\r\n\t\topen time (milliseconds) = 0\r\n\t\tnext time (milliseconds) = 0\r\n\t\tclose time (milliseconds) = 0\r\n\t\toptimizer estimated row count: 1.00\r\n\t\toptimizer estimated cost: 12.72\r\n\tIndex Key Optimization = false\r\n\tSource result set:\r\n\t\tProject-Restrict ResultSet (6):\r\n\t\tNumber of opens = 1\r\n\t\tRows seen = 1\r\n\t\tRows filtered = 0\r\n\t\trestriction = false\r\n\t\tprojection = true\r\n\t\t\tconstructor time (milliseconds) = 0\r\n\t\t\topen time (milliseconds) = 0\r\n\t\t\tnext time (milliseconds) = 0\r\n\t\t\tclose time (milliseconds) = 0\r\n\t\t\trestriction time (milliseconds) = 0\r\n\t\t\tprojection time (milliseconds) = 0\r\n\t\t\toptimizer estimated row count: 1.00\r\n\t\t\toptimizer estimated cost: 12.72\r\n\t\tSource result set:\r\n\t\t\tNested Loop Exists Join ResultSet:\r\n\t\t\tNumber of opens = 1\r\n\t\t\tRows seen from the left = 1\r\n\t\t\tRows seen from the right = 1\r\n\t\t\tRows filtered = 0\r\n\t\t\tRows returned = 1\r\n\t\t\t\tconstructor time (milliseconds) = 0\r\n\t\t\t\topen time (milliseconds) = 0\r\n\t\t\t\tnext time (milliseconds) = 0\r\n\t\t\t\tclose time (milliseconds) = 0\r\n\t\t\t\toptimizer estimated row count: 1.00\r\n\t\t\t\toptimizer estimated cost: 12.72\r\n\t\t\tLeft result set:\r\n\t\t\t\tIndex Row to Base Row ResultSet for TABLE2:\r\n\t\t\t\tNumber of opens = 1\r\n\t\t\t\tRows seen = 1\r\n\t\t\t\tColumns accessed from heap = {0, 1}\r\n\t\t\t\t\tconstructor time (milliseconds) = 0\r\n\t\t\t\t\topen time (milliseconds) = 0\r\n\t\t\t\t\tnext time (milliseconds) = 0\r\n\t\t\t\t\tclose time (milliseconds) = 0\r\n\t\t\t\t\toptimizer estimated row count: 1.00\r\n\t\t\t\t\toptimizer estimated cost: 8.01\r\n\t\t\t\t\tIndex Scan ResultSet for TABLE2 using constraint TABLE2_FK_2 at read committed isolation level using instantaneous share row locking chosen by the optimizer\r\n\t\t\t\t\tNumber of opens = 1\r\n\t\t\t\t\tRows seen = 1\r\n\t\t\t\t\tRows filtered = 0\r\n\t\t\t\t\tFetch Size = 16\r\n\t\t\t\t\t\tconstructor time (milliseconds) = 0\r\n\t\t\t\t\t\topen time (milliseconds) = 0\r\n\t\t\t\t\t\tnext time (milliseconds) = 0\r\n\t\t\t\t\t\tclose time (milliseconds) = 0\r\n\t\t\t\t\t\tnext time in milliseconds/row = 0\r\n\r\n\t\t\t\t\tscan information:\r\n\t\t\t\t\t\tBit set of columns fetched=All\r\n\t\t\t\t\t\tNumber of columns fetched=2\r\n\t\t\t\t\t\tNumber of deleted rows visited=0\r\n\t\t\t\t\t\tNumber of pages visited=4\r\n\t\t\t\t\t\tNumber of rows qualified=1\r\n\t\t\t\t\t\tNumber of rows visited=2\r\n\t\t\t\t\t\tScan type=btree\r\n\t\t\t\t\t\tTree height=-1\r\n\t\t\t\t\t\tstart position:\r\n\t\t\t\t\t\t\t>= on first 1 column(s).\r\n\t\t\t\t\t\t\tOrdered null semantics on the following columns: \r\n\t\t\t\t\t\t\t0 \r\n\t\t\t\t\t\tstop position:\r\n\t\t\t\t\t\t\t> on first 1 column(s).\r\n\t\t\t\t\t\t\tOrdered null semantics on the following columns: \r\n\t\t\t\t\t\t\t0 \r\n\t\t\t\t\t\tqualifiers:\r\n\t\t\t\t\t\t\tNone\r\n\t\t\t\t\t\toptimizer estimated row count: 1.00\r\n\t\t\t\t\t\toptimizer estimated cost: 8.01\r\n\r\n\t\t\tRight result set:\r\n\t\t\t\tIndex Scan ResultSet for TABLE1 using constraint SQL130829215951000 at read committed isolation level using share row locking chosen by the optimizer\r\n\t\t\t\tNumber of opens = 1\r\n\t\t\t\tRows seen = 1\r\n\t\t\t\tRows filtered = 0\r\n\t\t\t\tFetch Size = 1\r\n\t\t\t\t\tconstructor time (milliseconds) = 0\r\n\t\t\t\t\topen time (milliseconds) = 0\r\n\t\t\t\t\tnext time (milliseconds) = 0\r\n\t\t\t\t\tclose time (milliseconds) = 0\r\n\t\t\t\t\tnext time in milliseconds/row = 0\r\n\r\n\t\t\t\tscan information:\r\n\t\t\t\t\tBit set of columns fetched={0}\r\n\t\t\t\t\tNumber of columns fetched=1\r\n\t\t\t\t\tNumber of deleted rows visited=0\r\n\t\t\t\t\tNumber of pages visited=3\r\n\t\t\t\t\tNumber of rows qualified=1\r\n\t\t\t\t\tNumber of rows visited=1\r\n\t\t\t\t\tScan type=btree\r\n\t\t\t\t\tTree height=3\r\n\t\t\t\t\tstart position:\r\n\t\t\t\t\t\t>= on first 1 column(s).\r\n\t\t\t\t\t\tOrdered null semantics on the following columns: \r\n\t\t\t\t\t\t0 \r\n\t\t\t\t\tstop position:\r\n\t\t\t\t\t\t> on first 1 column(s).\r\n\t\t\t\t\t\tOrdered null semantics on the following columns: \r\n\t\t\t\t\t\t0 \r\n\t\t\t\t\tqualifiers:\r\n\t\t\t\t\t\tNone\r\n\t\t\t\t\toptimizer estimated row count: 1.00\r\n\t\t\t\t\toptimizer estimated cost: 4.71\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-09-04T18:58:12.235+0000","updated":"2013-09-04T18:58:12.235+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13758192","id":"13758192","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Wanted to point out that with my repro db, out of the 8 million rows, the first row that picks table scan in following query is 5189284.\r\nSELECT count FROM\r\nTable1 T1,\r\nTable2 t0\r\nWHERE t1.ID = t0.Table1_ID and\r\nt0.Table3_ID = 5189284","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-09-04T19:01:41.885+0000","updated":"2013-09-04T19:01:41.885+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13758208","id":"13758208","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"do you have any idea how many of the values in your repro db caused issue to reproduce?  \r\n\r\nDo you see any patttern to the estimated row count?  Maybe just grepping for the key line and where\r\nestimate row count is 0.* would be interesting.  Obviously visually seeing a pattern in 5 million\r\nrows is hard.  ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-09-04T19:10:29.276+0000","updated":"2013-09-04T19:10:29.276+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13758369","id":"13758369","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I believe there are atleast 212082 rows which cause us to table scan rather than index scan.\r\n\r\nJust some additional info on the output of the stand alone repro\r\nThe output from my repro stand alone case is extremely large(3.17GB) so I did a grep on it for the problem case identification string \"We are going to round estimated row count to 0\". I redirected the grep output a file and that file is also pretty big(29.1MB). For a typical wrong query plan case, we print something like following\r\nt0.Table3_ID =6035610\r\nIn engine estimated row count is 1000005.0\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 0.47683716\r\nWe are going to round estimated row count to 0\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 8000005.0\r\nIn engine estimated row count is 0.47683716\r\nWe are going to round estimated row count to 0\r\nIn engine estimated row count is 1000005.0\r\n\r\nie \"We are going to round estimated row count to 0\" gets printed twice for every SELECT which results in table scan rather than index scan.\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-09-04T21:25:06.370+0000","updated":"2013-09-04T21:25:06.370+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13759809","id":"13759809","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Attaching patch DERBY_6317_junit_test_v2_diff.txt which has junit reproducible test for this jira. There are handful of fixtures. The longest running fixture is testDERBY_6317 since it does select on each of the 8 million rows individually and checks if we are using index scan for getting the row. Without Mike's patch, this test fixture can take about 6hrs. This test fixture will fail along with couple other test fixtures(testDERBY_6317_value1, testDERBY_6317_value2, testDERBY_6317_value3) without Mike's changes because they will detect that we are using table scan. Once Mike's patch is applied, all of the test fixtures should pass. I am running the junit test right now with Mike's changes and the test has not finished yet after 9 hours of run. I will post a comment once this test run is over. Because of the length of the time the testDERBY_6317 fixture takes, we obviously won't want this to be running as part of junit complete suite. Even without this test fixture, the test can take over an hr because it has to load 3 tables with 1million, 8million and 8million rows respectively and these tables have indexes defined on them. The indexes need to be defined before the data load in order to reproduce the problem.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-09-06T03:07:22.579+0000","updated":"2013-09-06T03:07:22.579+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13759848","id":"13759848","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"The new junit test from the earlier patch finished successfully with Mike's patch. It took close to 10hrs to finish.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-09-06T04:20:25.935+0000","updated":"2013-09-06T04:20:25.935+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13759849","id":"13759849","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"It should be noted that it makes sense that test took longer with the fix.  Without the fix the loop trying to run 8 million selects will fail\r\nand stop when it hits the first problem, at around row 5 million.  With the fix it has to run 3 million more selects.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-09-06T04:25:10.381+0000","updated":"2013-09-06T04:25:10.381+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13760324","id":"13760324","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Uploading a new patch for the junit test. I accidentally uploaded older version of the junit test with the previous patch.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-09-06T16:24:25.693+0000","updated":"2013-09-06T16:24:25.693+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13760375","id":"13760375","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Attaching another patch DERBY_6317_junit_test_v4_diff.txt which now has 3 test fixtures testing for values in SELECT which will cause Derby to use table scan without DERBY-6317 fix. It also has 3 test fixtures testing for values in SELECT which will cause Derby to use index scan even without DERBY-6317 fix. And lastly, it has the very time consuming test fixture(testDERBY_6317) which does SELECT individually for each of the 8 million rows. This test fixture passes for all 8 million rows with DERBY-6317 fix but it stops at row 5189284 without DERBY-6317 fix because that's the first row that does a table scan rather than an index scan.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-09-06T17:19:06.456+0000","updated":"2013-09-06T17:19:06.456+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13762432","id":"13762432","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jira-bot","name":"jira-bot","emailAddress":"no-reply at urd dot zones dot apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF subversion and git services","active":true},"body":"Commit 1521310 from mikem@apache.org in branch 'code/trunk'\r\n[ https://svn.apache.org/r1521310 ]\r\n\r\nDERBY-6317 Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0 \r\n\r\nThe Optimizer estimates do not handle well 0 row counts coming out of store.\r\nThese estimates end up getting multiplied by other estimates and the resulting\r\n0 costs caused the incorrect plan to be picked in the repro included with\r\nthis fix.  This fix changes store cost to always return at least a minimum\r\nof one row when asked to estimate the number of rows in an exact range of\r\nkeys from an index.  This minimum is consistent with the optimizer assumption\r\nthat an exact key match on a unique index will also return 1 row.\r\n\r\nThanks to Brett Bergquist for debugging and suggesting a fix and to mamta \r\nsatoor for providing a reproducible test case for the bug.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jira-bot","name":"jira-bot","emailAddress":"no-reply at urd dot zones dot apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF subversion and git services","active":true},"created":"2013-09-09T22:59:52.443+0000","updated":"2013-09-09T22:59:52.443+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13763097","id":"13763097","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jira-bot","name":"jira-bot","emailAddress":"no-reply at urd dot zones dot apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF subversion and git services","active":true},"body":"Commit 1521517 from mikem@apache.org in branch 'code/branches/10.10'\r\n[ https://svn.apache.org/r1521517 ]\r\n\r\nDERBY-6317 Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0\r\n\r\nbackported change #1521310 from trunk to 10.10 branch.\r\n\r\nThe Optimizer estimates do not handle well 0 row counts coming out of store.\r\nThese estimates end up getting multiplied by other estimates and the resulting\r\n0 costs caused the incorrect plan to be picked in the repro included with\r\nthis fix.  This fix changes store cost to always return at least a minimum\r\nof one row when asked to estimate the number of rows in an exact range of\r\nkeys from an index.  This minimum is consistent with the optimizer assumption\r\nthat an exact key match on a unique index will also return 1 row.\r\n\r\nThanks to Brett Bergquist for debugging and suggesting a fix and to mamta\r\nsatoor for providing a reproducible test case for the bug.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jira-bot","name":"jira-bot","emailAddress":"no-reply at urd dot zones dot apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF subversion and git services","active":true},"created":"2013-09-10T15:03:54.176+0000","updated":"2013-09-10T15:03:54.176+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13764479","id":"13764479","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jira-bot","name":"jira-bot","emailAddress":"no-reply at urd dot zones dot apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF subversion and git services","active":true},"body":"Commit 1521931 from mikem@apache.org in branch 'code/branches/10.9'\r\n[ https://svn.apache.org/r1521931 ]\r\n\r\nDERBY-6317 Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0\r\n\r\nbackported change #1521310 from trunk to 10.9 branch.\r\n\r\nThe Optimizer estimates do not handle well 0 row counts coming out of store.\r\nThese estimates end up getting multiplied by other estimates and the resulting\r\n0 costs caused the incorrect plan to be picked in the repro included with\r\nthis fix.  This fix changes store cost to always return at least a minimum\r\nof one row when asked to estimate the number of rows in an exact range of\r\nkeys from an index.  This minimum is consistent with the optimizer assumption\r\nthat an exact key match on a unique index will also return 1 row.\r\n\r\nThanks to Brett Bergquist for debugging and suggesting a fix and to mamta\r\nsatoor for providing a reproducible test case for the bug.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jira-bot","name":"jira-bot","emailAddress":"no-reply at urd dot zones dot apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF subversion and git services","active":true},"created":"2013-09-11T16:49:24.062+0000","updated":"2013-09-11T16:49:24.062+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13764898","id":"13764898","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jira-bot","name":"jira-bot","emailAddress":"no-reply at urd dot zones dot apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF subversion and git services","active":true},"body":"Commit 1522084 from mikem@apache.org in branch 'code/branches/10.8'\r\n[ https://svn.apache.org/r1522084 ]\r\n\r\nDERBY-6317 Optmizer can choose the wrong path when BTreeCostController.java returns an estimate cost and row count of 0.0\r\n\r\nbackported change #1521310 from trunk to 10.8 branch.\r\n\r\nThe Optimizer estimates do not handle well 0 row counts coming out of store.\r\nThese estimates end up getting multiplied by other estimates and the resulting\r\n0 costs caused the incorrect plan to be picked in the repro included with\r\nthis fix.  This fix changes store cost to always return at least a minimum\r\nof one row when asked to estimate the number of rows in an exact range of\r\nkeys from an index.  This minimum is consistent with the optimizer assumption\r\nthat an exact key match on a unique index will also return 1 row.\r\n\r\nThanks to Brett Bergquist for debugging and suggesting a fix and to mamta\r\nsatoor for providing a reproducible test case for the bug.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jira-bot","name":"jira-bot","emailAddress":"no-reply at urd dot zones dot apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF subversion and git services","active":true},"created":"2013-09-11T22:46:47.277+0000","updated":"2013-09-11T22:46:47.277+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/13770951","id":"13770951","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"Fixed in trunk, backported to 10.10, 10.9, 10.8.  Fix is applicable to previous releases and can be backported if anyone is interested.  I don't plan on backporting it any further right now.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-09-18T16:48:04.847+0000","updated":"2013-09-18T16:48:04.847+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12665641/comment/14284716","id":"14284716","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=myrna","name":"myrna","emailAddress":"m dot v dot lunteren at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Myrna van Lunteren","active":true},"body":"bulk change to close all issues resolved but not closed and not changed since June 1, 2014.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=myrna","name":"myrna","emailAddress":"m dot v dot lunteren at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Myrna van Lunteren","active":true},"created":"2015-01-21T00:22:55.730+0000","updated":"2015-01-21T00:22:55.730+0000"}]},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-6317/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i1nldr:"}}