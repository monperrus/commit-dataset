{"expand":"renderedFields,names,schema,transitions,operations,editmeta,changelog","id":"12396923","self":"https://issues.apache.org/jira/rest/api/latest/issue/12396923","key":"DERBY-3693","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/10594","id":"10594","key":"DERBY","name":"Derby","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=10594&avatarId=10122","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=10594&avatarId=10122","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=10594&avatarId=10122","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=10594&avatarId=10122"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10090","id":"10090","description":"DB related projects","name":"DB"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12313345","id":"12313345","description":"","name":"10.4.2.0","archived":false,"released":true,"releaseDate":"2008-09-05"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12313771","id":"12313771","description":"build: 764942, 14/Apr/09. Voted release: 28/Apr/09. Announced: 1/May/09","name":"10.5.1.1","archived":false,"released":true,"releaseDate":"2009-04-28"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12310220":"2008-05-28 00:23:33.085","customfield_12312322":null,"customfield_12312323":null,"customfield_12310420":"23792","customfield_12310222":"3_*:*_1_*:*_362942216_*|*_1_*:*_1_*:*_7395877597_*|*_5_*:*_1_*:*_0","customfield_12312320":null,"customfield_12312321":null,"customfield_12312120":null,"customfield_12312121":null,"resolutiondate":"2008-08-25T16:09:02.981+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312326":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312324":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-3693/watchers","watchCount":0,"isWatching":false},"created":"2008-05-27T20:55:23.168+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12312334":null,"customfield_12310310":"9.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12312876","id":"12312876","description":"","name":"10.3.2.1","archived":false,"released":true,"releaseDate":"2007-12-10"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12313142","id":"12313142","description":"","name":"10.3.3.0","archived":false,"released":true,"releaseDate":"2008-05-12"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12313111","id":"12313111","description":"","name":"10.4.1.3","archived":false,"released":true,"releaseDate":"2008-04-24"}],"customfield_12311120":null,"customfield_12312330":null,"issuelinks":[{"id":"12321428","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12321428","type":{"id":"12310000","name":"Duplicate","inward":"is duplicated by","outward":"duplicates","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/12310000"},"inwardIssue":{"id":"31112","key":"DERBY-177","self":"https://issues.apache.org/jira/rest/api/2/issue/31112","fields":{"summary":"Unnecessary waiting within EmbedDatabaseMetaData.getIndexInfo()","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}},{"id":"12321016","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12321016","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"inwardIssue":{"id":"31112","key":"DERBY-177","self":"https://issues.apache.org/jira/rest/api/2/issue/31112","fields":{"summary":"Unnecessary waiting within EmbedDatabaseMetaData.getIndexInfo()","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}},{"id":"12321431","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12321431","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"inwardIssue":{"id":"12402999","key":"DERBY-3850","self":"https://issues.apache.org/jira/rest/api/2/issue/12402999","fields":{"summary":"Remove unneeded workarounds for DERBY-177 and DERBY-3693","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/4","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/minor.png","name":"Minor","id":"4"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/4","id":"4","description":"An improvement or enhancement to an existing feature or task.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/improvement.png","name":"Improvement","subtask":false}}}}],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"customfield_12312337":null,"customfield_12312338":null,"updated":"2011-01-21T17:51:58.322+0000","customfield_12312335":null,"customfield_12311720":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/11407","id":"11407","name":"JDBC"}],"timeoriginalestimate":null,"description":"My code changes DB structure (create a column), then immediately after setting autocommit back to true, the code rescans the DB metadata\nDatabaseMetaData.getColumns(catalog, schemaName, tableName, null);\n\nI am sometimes getting a deadlock with these operations:\n\n2008-04-16 19:50:47.833 GMT Thread[Default RequestProcessor,1,system] (XID = 569844), (SESSIONID = 2), (DATABASE = /..../a3/.config/localdb/db), (DRDAID = null), Cleanup action starting 2008-04-16 19:50:47.833 GMT Thread[Default RequestProcessor,1,system] (XID = 569844), (SESSIONID = 2),  (DATABASE = /..../IJCProjects/a3/.config/localdb/db), (DRDAID = null), Failed Statement is: EXECUTE STATEMENT SYS.\"getColumns\" ERROR 40XL2: A lock could not be obtained within the time requested.\n\nThe lockTable dump is:\n2008-04-16 19:50:47.796 GMT\nXID       |TYPE         |MODE|LOCKCOUNT|LOCKNAME                                                 |STATE|TABLETYPE /LOCKOBJ                   |INDEXNAME / CONTAINER_ID / MODE for LATCH only)  |TABLENAME / CONGLOM_ID                |\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n*** The following row is the victim ***\n569852    |ROW          |X   |0        |(44,7)                                                |WAIT |S                      |NULL |SYSSTATEMENTS                         | \n*** The above row is the victim ***\n\nThe stacktrace of the operation causing the deadlock is \n        at org.apache.derby.iapi.error.StandardException.newException(Unknown Source)\n        at org.apache.derby.impl.services.locks.Timeout.createException(Unknown Source)\n        at org.apache.derby.impl.services.locks.Timeout.buildException(Unknown Source)\n        at org.apache.derby.impl.services.locks.ConcurrentLockSet.lockObject(Unknown Source)\n        at org.apache.derby.impl.services.locks.AbstractPool.lockObject(Unknown Source)\n        at org.apache.derby.impl.services.locks.ConcurrentPool.lockObject(Unknown Source)\n        at org.apache.derby.impl.store.raw.xact.RowLocking3.lockRecordForWrite(Unknown Source)\n        at org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\n        at org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\n        at org.apache.derby.impl.store.access.btree.index.B2IRowLocking3.lockRowOnPage(Unknown Source)\n        at org.apache.derby.impl.store.access.btree.index.B2IRowLocking3._lockScanRow(Unknown Source)\n        at org.apache.derby.impl.store.access.btree.index.B2IRowLockingRR.lockScanRow(Unknown Source)\n        at org.apache.derby.impl.store.access.btree.BTreeForwardScan.fetchRows(Unknown Source)\n        at org.apache.derby.impl.store.access.btree.BTreeScan.fetchNext(Unknown Source) \n        at org.apache.derby.impl.sql.catalog.TabInfoImpl.updateRow(Unknown Source) \n        at org.apache.derby.impl.sql.catalog.TabInfoImpl.updateRow(Unknown Source)\n        at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.updateSPS(Unknown Source )\n        at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.updateSYSSTATEMENTS(Unknown Source)\n        at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.getPreparedStatement(Unknown Source)\n        at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.getPreparedStatement(Unknown Source)\n        at org.apache.derby.impl.sql.compile.ExecSPSNode.generate(Unknown Source)\n        at org.apache.derby.impl.sql.GenericStatement.prepMinion(Unknown Source)\n        at org.apache.derby.impl.sql.GenericStatement.prepare(Unknown Source)\n        at org.apache.derby.impl.sql.GenericPreparedStatement.rePrepare(Unknown Source)\n        at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)\n        at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)\n        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)\n        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeQuery(Unknown Source) \n        at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.doGetCols(Unknown Source)\n        at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getColumns(Unknown Source)\n\nI've seen the deadlock occur during several get-metadata operations (getImportedKeys, ...), each time waiting on the SYSSTATEMENTS apparently because of internally constructed PreparedStatement. The lock eventually times out and the locked out operation completes without error.\n\nWhen the deadlock occurs, the \"real\" SQL into systables is being compiled (I traced this sql to be the value of \"getColumns\" key in org/apache/derby/impl/jdbc/metadata.properties file):\n---------%<-----------------------%<--------------\nBegin compiling prepared statement: SELECT CAST ('' AS VARCHAR(128)) AS PKTABLE_CAT, S.SCHEMANAME AS PKTABLE_SCHEM, TABLENAME AS\nPKTABLE_NAME, COLS.COLUMNNAME AS PKCOLUMN_NAME, CAST ('' AS VARCHAR(128)) AS FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, FKCOLUMN_NAME, CAST ...\n---------%<-----------------------%<--------------\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12310200":null,"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"aggregatetimeestimate":null,"customfield_12312022":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12310921":null,"customfield_12310920":"37282","summary":"Deadlocks accessing DB metadata","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=svatoun","name":"svatoun","emailAddress":"garat at volny dot cz","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Svata Dedic","active":true},"subtasks":[],"customfield_12310090":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=svatoun","name":"svatoun","emailAddress":"garat at volny dot cz","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Svata Dedic","active":true},"customfield_12310291":null,"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"environment":"Linux amd64 or Windows 32bit","customfield_12311020":null,"customfield_12310050":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"startAt":0,"maxResults":23,"total":23,"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12600322","id":"12600322","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"body":"Are are able to produce a repro program for this? I tried to make one based on your explanations, but no luck yet.\r\nFrom what you say, the problem is intermittent, so presumably more than one connection makes the\r\nmetadata queries? What isolation level are you running with? (default is read committed).\r\nIs there more information in derby.log? Did the deadlock dump only show the victim?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"created":"2008-05-28T00:23:33.085+0000","updated":"2008-05-28T00:23:33.085+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12600755","id":"12600755","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"It's just a guess, but perhaps the attached patch deadlock.diff solves the problem. Stored prepared statements (which are used for the meta-data queries) are compiled in a nested transaction so that locks on system tables can be released before the main transaction is completed. If the main transaction already has a lock on something the nested transaction also needs to lock, the nested transaction may get a lock timeout, in which case we retry the operation in the parent transaction. We don't retry if the nested transaction runs into a deadlock, which is what happens in Svata's case. I don't think it's possible that the nested transaction runs into a deadlock with the main transaction, since the main transaction isn't waiting for any locks while the nested transaction is executing, but it may perhaps happen if there are more threads involved?\r\n\r\nAnyway, I just wanted to throw out the idea. The patch has not been tested.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-05-29T12:26:43.238+0000","updated":"2008-05-29T12:26:43.238+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12600757","id":"12600757","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I removed the \"Existing Application Impact\" flag since it refers to the impact of the fix, not the bug.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-05-29T12:29:18.573+0000","updated":"2008-05-29T12:29:18.573+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12606060","id":"12606060","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=belgarat","name":"belgarat","emailAddress":"garat at volny dot cz","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Svata Dedic","active":true},"body":"Knut,\r\n\r\nI tried your patch - the conditional code activates (I put a println in there), but only after a considerable timeout elapses -- so it does not solve the issue.\r\n\r\nThere are no other threads accessing the database at the time the deadlock occurs, the thread which waits (until timeout elapses and the lock is broken) is the only one working with Derby. The connection may handed to several threads in our app, but only one of them can get and use it at any given time.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=belgarat","name":"belgarat","emailAddress":"garat at volny dot cz","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Svata Dedic","active":true},"created":"2008-06-18T19:44:01.287+0000","updated":"2008-06-18T19:44:01.287+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12606770","id":"12606770","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Attached is a small test case that reproduces the problem. It creates a deadlock between two transactions by first obtaining shared locks on the rows in SYSSTATEMENTS for getTables and getColumns in both transactions. Then one transaction tries to obtain an exclusive lock on the getTables row (because it needs to compile getTables), and the other transaction on getColumns. This results in the following error and stack trace:\r\n\r\nERROR 40001: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\nLock : ROW, SYSSTATEMENTS, (15,7)\r\n  Waiting XID : {149, X} , APP, EXECUTE STATEMENT SYS.\"getTables\"\r\n  Granted XID : {149, S} , {148, S} \r\nLock : ROW, SYSSTATEMENTS, (19,6)\r\n  Waiting XID : {148, X} , APP, EXECUTE STATEMENT SYS.\"getColumns\"\r\n  Granted XID : {148, S} , {149, S} \r\n. The selected victim is XID : 149.\r\n        at org.apache.derby.iapi.error.StandardException.newException(StandardException.java:303)\r\n        at org.apache.derby.impl.services.locks.Deadlock.buildException(Deadlock.java:361)\r\n        at org.apache.derby.impl.services.locks.ConcurrentLockSet.lockObject(ConcurrentLockSet.java:613)\r\n        at org.apache.derby.impl.services.locks.AbstractPool.lockObject(AbstractPool.java:117)\r\n        at org.apache.derby.impl.services.locks.ConcurrentPool.lockObject(ConcurrentPool.java:28)\r\n        at org.apache.derby.impl.store.raw.xact.RowLocking3.lockRecordForWrite(RowLocking3.java:248)\r\n        at org.apache.derby.impl.store.access.heap.HeapController.lockRow(HeapController.java:504)\r\n        at org.apache.derby.impl.store.access.heap.HeapController.lockRow(HeapController.java:638)\r\n        at org.apache.derby.impl.store.access.btree.index.B2IRowLocking3.lockRowOnPage(B2IRowLocking3.java:335)\r\n        at org.apache.derby.impl.store.access.btree.index.B2IRowLocking3._lockScanRow(B2IRowLocking3.java:628)\r\n        at org.apache.derby.impl.store.access.btree.index.B2IRowLockingRR.lockScanRow(B2IRowLockingRR.java:112)\r\n        at org.apache.derby.impl.store.access.btree.BTreeForwardScan.fetchRows(BTreeForwardScan.java:304)\r\n        at org.apache.derby.impl.store.access.btree.BTreeScan.fetchNext(BTreeScan.java:1809)\r\n        at org.apache.derby.impl.sql.catalog.TabInfoImpl.updateRow(TabInfoImpl.java:1085)\r\n        at org.apache.derby.impl.sql.catalog.TabInfoImpl.updateRow(TabInfoImpl.java:975)\r\n        at org.apache.derby.impl.sql.catalog.DataDictionaryImpl.updateSPS(DataDictionaryImpl.java:4042)\r\n        at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.updateSYSSTATEMENTS(SPSDescriptor.java:1104)\r\n        at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.getPreparedStatement(SPSDescriptor.java:728)\r\n        at org.apache.derby.iapi.sql.dictionary.SPSDescriptor.getPreparedStatement(SPSDescriptor.java:642)\r\n        at org.apache.derby.impl.sql.compile.ExecSPSNode.generate(ExecSPSNode.java:177)\r\n        at org.apache.derby.impl.sql.GenericStatement.prepMinion(GenericStatement.java:447)\r\n        at org.apache.derby.impl.sql.GenericStatement.prepare(GenericStatement.java:88)\r\n        at org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext.prepareInternalStatement(GenericLanguageConnectionContext.java:794)\r\n        at org.apache.derby.impl.jdbc.EmbedPreparedStatement.<init>(EmbedPreparedStatement.java:128)\r\n        at org.apache.derby.impl.jdbc.EmbedPreparedStatement20.<init>(EmbedPreparedStatement20.java:82)\r\n        at org.apache.derby.impl.jdbc.EmbedPreparedStatement30.<init>(EmbedPreparedStatement30.java:63)\r\n        at org.apache.derby.impl.jdbc.EmbedPreparedStatement40.<init>(EmbedPreparedStatement40.java:40)\r\n        at org.apache.derby.jdbc.Driver40.newEmbedPreparedStatement(Driver40.java:105)\r\n        at org.apache.derby.impl.jdbc.EmbedConnection.prepareMetaDataStatement(EmbedConnection.java:2624)\r\n        at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.prepareSPS(EmbedDatabaseMetaData.java:3657)\r\n        at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQueryUsingSystemTables(EmbedDatabaseMetaData.java:3493)\r\n        at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQuery(EmbedDatabaseMetaData.java:3542)\r\n        at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getPreparedQuery(EmbedDatabaseMetaData.java:3567)\r\n        at org.apache.derby.impl.jdbc.EmbedDatabaseMetaData.getTables(EmbedDatabaseMetaData.java:1708)\r\n        at d3693.T1(d3693.java:57)\r\n        at d3693.main(d3693.java:32)\r\n\r\n\r\nI'm not sure how this could happen in a normal application, though.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-06-20T14:13:15.362+0000","updated":"2008-06-20T14:13:15.362+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12607359","id":"12607359","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Svata, if you can reproduce this problem reliably, it would be great if you could run with derby.language.logStatementText=true and derby.locks.deadlockTrace=true and post the full contents of derby.log. Then we might see which transaction is leaving a lock and causing the timeout.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-06-23T19:38:32.750+0000","updated":"2008-06-23T19:38:32.750+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12614520","id":"12614520","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=david.capelle","name":"david.capelle","emailAddress":"david dot capelle at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"David Capelle","active":true},"body":"Hi Knut, Svata,\r\n\r\nWe have a similar problem with metadata.\r\nSince we have added a new table in our schema, we always have a deadlock .\r\nWe have noticed that if we delete a table (regardless of wich table), than deadlock does't happend anymore.  \r\nOur scenario:\r\n1. Create all the tables (including index)\r\n2. For each table, check if there are new ForeignKey to create\r\n3. Create all new foreignKeys.\r\nDealock happens in the second step. Only one thread is connected to Derby (and so one connection).\r\nI will send you our derby.log file.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=david.capelle","name":"david.capelle","emailAddress":"david dot capelle at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"David Capelle","active":true},"created":"2008-07-17T20:09:57.685+0000","updated":"2008-07-17T20:09:57.685+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12614671","id":"12614671","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Thanks David, that was a very useful piece of information! I think I (almost) see what's happening in your case.\r\n\r\nDerby periodically checks whether a compiled plan should be recompiled (configurable with the derby.language.stalePlanCheckInterval property). When it detects that the size of SYS.SYSTABLES has changed considerably since getTables() was compiled the last time (because you have added more tables), it'll recompile the plan to see if it can create a plan that is more efficient.\r\n\r\nThe recompilation happens in a nested transaction, which runs into a lock conflict with the parent transaction when it tries to store the compiled plan in SYS.SYSSTATEMENTS, and therefore it hangs for the duration specified by derby.locks.waitTimeout. This hang is DERBY-177. This is the part I don't quite understand. The parent transaction shouldn't have any locks in this case, since it hasn't performed any operations before the call to getTables(). My guess is that it still holds some locks after querying the system tables to see if a recompilation is needed.\r\n\r\nNormally, after the nested transaction times out, the timeout exception is intercepted and the recompilation is retried in the parent transaction. However, because derby.locks.deadlockTrace is set, the timeout exception has a different SQLState than what the retry logic expects (40XL2 instead of 40XL1), and the exception is not intercepted.\r\n\r\nI have attached a java class (GetTables.java) that simulates your application. It has a loop which continuously executes CREATE TABLE and getTables(). If I run the class without derby.locks.deadlockTrace, I see a hang each time getTables() is recompiled. It continues with no error after the hang. If I run with derby.locks.deadlockTrace, it fails with a timeout exception the first time getTables() is recompiled.\r\n\r\nNow, I think the patch I attached earlier (deadlock.diff) will help so that the timeout exception isn't thrown, but as Svata noted, you'll still see the hang.\r\n\r\nI see the following possible workarounds:\r\n\r\n  1) Don't run with derby.locks.deadlockTrace. You'll still see the hangs, but it won't fail. You may also want to lower derby.locks.waitTimeout to reduce the problem with the hangs.\r\n\r\n  2) Increase the value of derby.language.stalePlanCheckInterval (default 100) so that you manage to create all your tables without recompiling getTables().\r\n\r\nTo fix the issue permanently, we need to find out why the parent transaction holds locks in the system tables before it recompiles the getTables() query, and find out how we can ensure that these locks don't conflict with the nested transaction.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-07-18T09:02:18.874+0000","updated":"2008-07-18T09:02:18.874+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12614889","id":"12614889","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"It seems like the plan for the meta-data query is invalidated in the user transaction. When the plan is invalidated, SYS.SYSSTATEMENTS is updated to reflect that the plan is invalid, hence the user transaction has an exclusive lock on a row in SYS.SYSSTATEMENTS. However, the meta-data query is recompiled in a sub-transaction, and therefore it runs into a lock conflict with the user transaction. Perhaps we could get around this problem by also performing the invalidation in a sub-transaction so that the exclusive lock is released once the plan has been marked as invalid. Statements within triggers probably also suffer from the same problem.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-07-18T21:47:34.874+0000","updated":"2008-07-18T21:47:34.874+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12615074","id":"12615074","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=david.capelle","name":"david.capelle","emailAddress":"david dot capelle at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"David Capelle","active":true},"body":"Thanks a lot for your investigations, \r\nAfter lower derby.locks.waitTimeout to16 sec and derby.locks.deadlockTimeout to 15,  we still have deadlock (in derby.log file) but we don't wait more than 15 seconds, so it's acceptable.\r\nI also have tested the second workaround (derby.language.stalePlanCheckInterval). I have set it to 200. ThIs time, deadlock doesn't occur.\r\nIf I understand well, changing this last property only affect performance on metadata getTable method? \r\n \r\nBR","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=david.capelle","name":"david.capelle","emailAddress":"david dot capelle at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"David Capelle","active":true},"created":"2008-07-20T10:14:57.923+0000","updated":"2008-07-20T10:14:57.923+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12615201","id":"12615201","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Increasing derby.language.stalePlanCheckInterval could affect all statements, but I don't think it's likely that you'll notice any difference. What could be getting worse, is that it takes longer from the size of a table changes so that the chosen plan is not the most efficient one anymore, until Derby notices it and creates a new plan. On the other hand, increasing it could also improve the performance, since it'll lead to less checking of the plan at run time and less recompiling. I'd guess that in most cases the recompiling won't actually choose another plan, so doing it less frequently shouldn't hurt.\r\n\r\nThe timeout will only happen with meta-data queries and statements in triggers, though, since the execution plans for those queries are stored in the database. The execution plans for other SQL statements are stored in memory only, so there's no need to modify system tables when they are recompiled.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-07-21T10:26:51.360+0000","updated":"2008-07-21T10:26:51.360+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12617033","id":"12617033","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Invalidating the meta-data queries in a nested transaction seems to fix the problem. The attached patch (nested_transaction.diff) shows this approach, and the timeout is not seen in the repro (GetTables.java) anymore. I haven't run the regression tests or added new regression tests for this problem yet, and will probably not have time to do it in a couple of weeks, but I'm attaching the patch now for others to try and comment on.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-07-25T20:04:17.234+0000","updated":"2008-07-25T20:04:17.234+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12623683","id":"12623683","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I ran suites.All and derbyall successfully with\r\nnested_transaction.diff, but it took very long time for the tests to\r\ncomplete. I think that the problem is that the patch attempts to\r\nupdate SYSSTATEMENTS in a nested transaction every time an SPS is\r\ninvalidated, regardless of why the invalidation request was sent. In\r\nsome of those cases (like when makeInvalid() is called with action =\r\nDependencyManager.CREATE_TRIGGER) the user transaction already holds\r\nlocks on rows in SYSSTATEMENTS and the nested transaction almost\r\ndefinitely runs into a lock conflict with its parent.\r\n\r\nTo fix the reported issue without introducing hangs in other cases, we\r\ncan probably limit the use of nested transactions to the case where\r\nmakeInvalid() is called for recompile requests\r\n(INTERNAL_RECOMPILE_REQUEST and possibly USER_RECOMPILE_REQUEST)","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-08-19T14:20:00.424+0000","updated":"2008-08-19T14:20:00.424+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12624342","id":"12624342","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Here's a new version of the patch. Changes from the previous patch:\r\n\r\n  1) only invalidate in a nested transaction for INTERNAL_RECOMPILE_REQUEST\r\n\r\n  2) added regression test\r\n\r\nAlthough (1) fixed most of the internal timeouts that were seen with the previous patch, I still see one timeout in GrantRevokeDDLTest (no error, since the retry in the parent transaction succeeds), so I don't think the patch should be committed yet. The timeout apparently happens because GrantRevokeConstantAction invalidates statements with INTERNAL_RECOMPILE_REQUEST while it's probably holding a lock in SYSSTATEMENTS.\r\n\r\nThe best way to fix this problem would be if we could make the logic to prevent waiting for locks in SPSDescriptor.updateSYSSTATEMENTS() work for row locks. Currently, it only prevents waiting for table locks. See also some discussion in DERBY-177.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-08-21T11:48:54.999+0000","updated":"2008-08-21T11:48:54.999+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12624860","id":"12624860","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Here's a patch (dontWait.diff) which attacks the problem from a different angle. Instead of preventing the invalidation from obtaining a lock on the system tables in the user transaction, this patch makes the nested transaction used for recompiling the meta-data query fail immediately in case of a lock conflict. The original code also attempts this, but only for table-level locks. This patch makes all lock requests in the nested transaction time out immediately if there's a lock conflict, so that there's no hang before we retry in the user transaction.\r\n\r\nThe approach taken is this:\r\n\r\nThe CompatibilitySpace class used in the lock manager has an owner field, which normally is the transaction object. This field is however of type java.lang.Object and can theoretically be anything. In the patch, I changed this field to be of the type LockOwner, which is a new interface under iapi.services.locks. The interface has a method noWait() that returns a boolean value. The lock manager will check the return value of this method if lockObject() or zeroDurationlockObject() can't lock the object immediately, and if it is true, a timeout exception is thrown instead of waiting.\r\n\r\nIn SPSDescriptor, I set a flag in the nested transaction so that it returns true from its noWait() method. This means we'll not see the lock conflicts between the nested transaction and its parent as hangs anymore.\r\n\r\nI have successfully run the repro, the regression test that was added to DatabaseMetaDataTest, and a set of tests that had problems with the previous patches. Didn't see any problems in those tests. Will start the full regression test suite and report back.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-08-22T14:56:47.663+0000","updated":"2008-08-22T14:56:47.663+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12624864","id":"12624864","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"With the latest patch, we can probably remove the lowering of the lock timeout in some of the regression tests marked with DERBY-177. The tests affected by DERBY-177 can be found in DatabaseMetaDataTest and UpdatableResultSetTest.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-08-22T15:03:09.986+0000","updated":"2008-08-22T15:03:09.986+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12624981","id":"12624981","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"The regression tests passed on JDK 6. I'll start a test run on Java 1.4 as well, since a different code path is followed there.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-08-22T21:16:24.241+0000","updated":"2008-08-22T21:16:24.241+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12625029","id":"12625029","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"The regression tests passed on Java 1.4.2 as well, so I checked in the patch with revision 688274.\r\n\r\nI think this fix should be back-ported since the problem was reported against 10.3, and DERBY-177, which is probably the same issue, was reported against 10.0. Will do that in a couple of days if the nightly regression tests don't show any problems and no one objects to the patch.\r\n\r\nSome cleanups that should be performed before closing this issue:\r\n  - remove workaround for DERBY-177 in tests\r\n  - remove logic to prevent waiting for table locks in SPSDescriptor.updateSYSSTATEMENTS() since the new mechanism will prevent waiting for all types of locks","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-08-23T07:44:10.936+0000","updated":"2008-08-23T07:44:10.936+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12625185","id":"12625185","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"Hi Knut, thanks for working on this problem. I think your approach is excellent -- good catch\r\non figuring out that the previous implementation was only working for table-level locks.\r\n\r\nI read through dontWait.diff and it seems quite clear; the new LockOwner interface\r\nseems like a straightforward way to increase the communication between the locking\r\nservices and the higher-level client code without introducing a lot of coupling, very nice.\r\n\r\nI did feel, however, that the patch could use significantly more comments. Looking just\r\nat the patch, without referring to the detailed comments in this JIRA report, I found it\r\nhard to see when it would be appropriate to call setNoLockWait(true).\r\n\r\nIn other words, I think it would be nice if the patch could include sufficient comments\r\nthat future code which creates a nested transaction could determine when to use\r\nthis new API or not. Should *all* nested transactions use no-wait locking? If not, which\r\nones should, and why? \r\n\r\nI think that the crucial bit of missing information involves the fact(s) that:\r\n a) the nested transaction might be blocking on locks held by the parent transaction\r\n b) some callers are smart enough to know that if a lock-related problem occurs with\r\n     the nested transaction, they can re-try the work using the parent transaction\r\n\r\nIf possible, I think that some useful places for such information would be:\r\n - LockOwner.noWait: more information about why a lock owner might return true from noWait\r\n   (e.g., because its a nested transaction which might be blocking on its own parent)\r\n - Xact.setNoLockWait: more information about why a client might want to configure\r\n   a transaction to use no-wait behavior, when that is appropriate, when it won't work,\r\n   and what the caller should be prepared to do when the lock requests fail rather than waiting\r\n  (e.g., catch the failure and retry the operation on the parent xact)\r\n - SPSDescriptor.java: more information about why nested transactions which access\r\n   stored prepared statements are able to use lock-failure behavior (that is, because\r\n   the code is smart enough to catch the failure in the nested transaction and retry\r\n   the acces using the parent transaction)\r\n\r\nAgain, thanks *so* much for this fix, I think this is a big improvement. \r\n ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2008-08-24T16:47:13.136+0000","updated":"2008-08-24T16:47:13.136+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12625404","id":"12625404","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Thanks for looking at the patch, Bryan, and for providing constructive feedback, as always!\r\n\r\nI have tried to improve the comments (see the attached patch, committed with revision 688756) the following way:\r\n\r\n  - LockOwner.noWait(): Give more details and an example of when to return true.\r\n\r\n  - Transaction/TransactionController.setNoLockWait(): Added a (short) description of when/how to use it and linked it to LockOwner.noWait() with a @see javadoc tag.\r\n\r\n  - Xact/RAMTransaction.setNoLockWait(): Expanded the comments and cross references by inheriting javadoc comments from the interfaces.\r\n\r\n  - SPSDescription.getPreparedStatement(): Expanded comment right before the call to nestedTC.setNoLockWait(true). The method already has good comments from before the fix explaining the timeout/retry logic, so I tried to keep it short in order to avoid duplicating too much information.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-08-25T15:50:23.973+0000","updated":"2008-08-25T15:50:23.973+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12625410","id":"12625410","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I merged the fix to the 10.4 branch with revision 688766.\r\n\r\nI guess the issue must be marked as resolved in order to show up in the list of fixed issues in the 10.4.2 release notes, and the release candidate will be built very soon. There are still some clean-up tasks related to this issue, but since they are not needed for the fix, I think I'll resolve this issue and open a new issue for the clean-up tasks.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-08-25T15:58:51.310+0000","updated":"2008-08-25T15:58:51.310+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12625415","id":"12625415","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Filed remaining tasks as DERBY-3850. Marking this bug as resolved.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-08-25T16:09:02.962+0000","updated":"2008-08-25T16:09:02.962+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12396923/comment/12625416","id":"12625416","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"comments.diff looks excellent! Thanks for taking the time to clarify the doc. I can't think of anything else to add.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2008-08-25T16:11:36.958+0000","updated":"2008-08-25T16:11:36.958+0000"}]},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-3693/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i06qu7:"}}