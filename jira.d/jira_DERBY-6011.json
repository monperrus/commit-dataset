{"expand":"renderedFields,names,schema,transitions,operations,editmeta,changelog","id":"12623008","self":"https://issues.apache.org/jira/rest/api/latest/issue/12623008","key":"DERBY-6011","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/10594","id":"10594","key":"DERBY","name":"Derby","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=10594&avatarId=10122","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=10594&avatarId=10122","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=10594&avatarId=10122","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=10594&avatarId=10122"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10090","id":"10090","description":"DB related projects","name":"DB"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12323475","id":"12323475","description":"Head of 10.8 branch starting 2014-01-13","name":"10.8.3.3","archived":false,"released":false},{"self":"https://issues.apache.org/jira/rest/api/2/version/12323562","id":"12323562","description":"Head of 10.9 branch after releasing 10.9.1.0","name":"10.9.2.2","archived":false,"released":false},{"self":"https://issues.apache.org/jira/rest/api/2/version/12321550","id":"12321550","description":"First release on the 10.10 branch","name":"10.10.1.1","archived":false,"released":true,"releaseDate":"2013-04-15"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12310220":"2012-12-12 22:23:19.883","customfield_12312322":null,"customfield_12312323":null,"customfield_12310420":"296598","customfield_12310222":"1_*:*_1_*:*_11651557971_*|*_6_*:*_1_*:*_0","customfield_12312320":null,"customfield_12312321":null,"customfield_12312120":null,"customfield_12312121":null,"resolutiondate":"2013-04-22T07:47:10.473+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312326":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312324":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-6011/watchers","watchCount":9,"isWatching":false},"created":"2012-12-08T11:14:32.548+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12312334":null,"customfield_12310310":"5.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12315564","id":"12315564","description":"First release on the 10.7 branch.","name":"10.7.1.1","archived":false,"released":true,"releaseDate":"2010-12-14"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12317968","id":"12317968","description":"second release on the 10.8 branch","name":"10.8.2.2","archived":false,"released":true,"releaseDate":"2011-10-24"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12316344","id":"12316344","description":"First release on the 10.9 branch","name":"10.9.1.0","archived":false,"released":true,"releaseDate":"2012-06-25"}],"customfield_12311120":null,"customfield_12312330":null,"issuelinks":[{"id":"12371859","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12371859","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"outwardIssue":{"id":"12656863","key":"DERBY-6289","self":"https://issues.apache.org/jira/rest/api/2/issue/12656863","fields":{"summary":"Derby 10.8 backport issue (summer 2013)","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}},{"id":"12363020","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12363020","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"outwardIssue":{"id":"12381347","key":"DERBY-3155","self":"https://issues.apache.org/jira/rest/api/2/issue/12381347","fields":{"summary":"Support for SQL:2003 MERGE statement","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/5","description":"A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/resolved.png","name":"Resolved","id":"5","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/4","id":"4","description":"An improvement or enhancement to an existing feature or task.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/improvement.png","name":"Improvement","subtask":false}}}}],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"customfield_12312337":null,"customfield_12312338":null,"updated":"2013-07-10T22:58:14.383+0000","customfield_12312335":null,"customfield_12311720":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/11408","id":"11408","name":"SQL"}],"timeoriginalestimate":null,"description":"The Apache ManifoldCF project supports Derby as one of its underlying databases.  Simple tests, however, demonstrate that Derby is apparently deadlocking and timing out repeatedly under multi-thread conditions.  This problem is long-standing, and is not exhibited by any other database ManifoldCF supports, and makes a simple test take between 6x and 12x as long.\r\n\r\nThere is a trivial test with demonstrates the problem vs. other databases.  Please do the following (once you have java 1.6+, svn 1.7+, and ant 1.7+ available):\r\n\r\n(1) Check out https://svn.apache.org/repos/asf/manifoldcf/trunk\r\n(2) Run the following ant target to download the dependencies: \"ant make-core-deps\"\r\n(3) Run the Derby test: \"ant run-rss-tests-derby\" . Note the time required - at least 180 seconds, can be up to 360 seconds.\r\n(4) Run the equivalent HSQLDB test: \"ant run-rss-tests-HSQLDB\".  This test takes about 31 seconds to run.\r\n\r\nThe output of the Derby test can be found in the directory \"tests/rss/test-derby-output\".  Have a look at manifoldcf.log, where all long-running queries are reported.  Derby.log is also included, which shows only that during the test's cleanup phase the database is deleted before it is shutdown, which is not pertinent to the performance issue.\r\n\r\nI am available to assist with ManifoldCF, if that seems to be required.\r\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12310200":null,"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"aggregatetimeestimate":null,"customfield_12312022":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12310921":null,"customfield_12310920":"233168","summary":"Derby performs very badly (seems to deadlock and timeout) in very simple multi-threaded tests","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"subtasks":[],"customfield_12310090":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"customfield_12310291":null,"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"environment":"Lenovo laptop with SSD's, Windows 7, 64-bit, Sun JDK 1.6.xx","customfield_12311020":null,"customfield_12310050":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"startAt":0,"maxResults":60,"total":60,"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13530431","id":"13530431","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=myrna","name":"myrna","emailAddress":"m dot v dot lunteren at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Myrna van Lunteren","active":true},"body":"Hi,\r\nThanks for making this report! Especially if this is a long-standing issue...\r\n\r\nHowever, setting this up seems a little more involved than I have time for right now, and possibly the same is true for others (or someone would've replied).\r\n\r\nCould you publish at least the derby.log and other log file from one of your own runs?\r\nDo you have an excerpt of the jdbc calls that you can cut-and-paste?\r\n\r\nAnd is it possible for you to run with the debug builds of derby? Those would give line numbers with any stack traces.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=myrna","name":"myrna","emailAddress":"m dot v dot lunteren at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Myrna van Lunteren","active":true},"created":"2012-12-12T22:23:19.883+0000","updated":"2012-12-12T22:23:19.883+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13530462","id":"13530462","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"body":"Here are the output logs.  Please advise were I can get a \"debug\" version of any recent version of derby.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"created":"2012-12-12T22:55:52.303+0000","updated":"2012-12-12T22:55:52.303+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13530482","id":"13530482","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I tried the test with derby.stream.error.logSeverityLevel=0 to get more data in derby.log. Then I saw many deadlocks of this kind:\r\n\r\nERROR 40001: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\nLock : ROW, JOBQUEUE, (1,37)\r\n  Waiting XID : {726, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n  Granted XID : {721, X} \r\nLock : ROW, JOBQUEUE, (1,38)\r\n  Waiting XID : {721, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n  Granted XID : {720, X} \r\nLock : ROW, JOBQUEUE, (1,37)\r\n  Waiting XID : {720, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n. The selected victim is XID : 726.\r\n\r\nSo... Three transactions locking the same rows, but in different order, and end up in a deadlock.\r\n\r\nIt varies how many transactions that are part of the deadlock, but it looks like it's always the same query that's involved.\r\n\r\nI haven't dug any further to see how the query is used yet.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2012-12-12T23:24:34.517+0000","updated":"2012-12-12T23:24:34.517+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13530520","id":"13530520","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"body":"Is normal deadlock behavior a wait of 30-60 seconds?  because that's what I'm seeing...\r\n\r\nI can look at the transactions where this query is being fired; they are supposedly ordered by the dochash everywhere but we may have a bug there; I'll research.  Still, immediate detection of a deadlock should not cause the long-running queries we see.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"created":"2012-12-13T00:13:17.755+0000","updated":"2012-12-13T00:13:17.755+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13530544","id":"13530544","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"body":"I added code to dump the order in which FOR UPDATE queries occur within all such transactions.  Here is a sample:\r\n\r\n{code}\r\nC:\\wip\\mcf\\trunk\\tests\\rss\\test-derby-output>tail -f manifoldcf.log\r\n WARN 2012-12-12 19:34:55,191 (Startup thread) - Updating: 003B8F747BBAD5C268EB77CA597CBEE8DDA51D2C 3DFAA926101B8F5E105345E9FA8F6FF6E2503E25 99C0CD575F36553F77EB7AA75FF482E70493AA37 B431F3383185EF8B73935CC448011AA5A8A45EEF B915311D0951A301FAC8C259FA4D3945BDC80EE9 C3F374EA2B2B9B4EDEB1FBBE6911A64732C6038B E6BA898A8951E6CAAFC9339646BA0FD753F32F41 EA9515103B9821D7FF82DF135A7054DCA24A263E F04C0F1EFA841CF9CB57532577169FAD61EFD20B F9060099494ABDD229F9B31A2CECB5BB2DAF3877\r\n WARN 2012-12-12 19:34:57,751 (Worker thread '20') - Updating: 019DC959C3D2D81AA500308882553E08E2128F3A 033689A1424C66E5C15F3A553ED632D7711F18C7 0BCB5FB2AE27DBBA7743A70CB57714496A30EBBD 26278F7F152D729150F293C3109A1D9A58AD21C6 2D6080272A03EE908F9802D4EED6AC51D6C12225 77200A152ABAA4267532747B5D07589A5C1D2702 965B87D0FEE7880E6862209BD0B9538A86771879 B157D34358568EADF670474ED35AF0AB62550708 BFCF552C4D14CE9630C428D9F3C197B70308C81B F3059DC934196A6F84D6BED8277CB2E77D0AE97F\r\n WARN 2012-12-12 19:34:57,761 (Worker thread '21') - Updating: 0CDC72CE178F4A53C54B31EEAA879ED10C8ABF50 28B8DB65AFC0E07477BE019559275F5DDEB5265A 695D963FFA7E075984DD905A47399E344319BD75 6B89F81ACE4851223423E57F3B48C9440F6BDAA9 7709C357A9A72915959503F100BD9416E153EF69 814B53D19EC2EEFA286E6E607DEF5381676E5CA8 8776852699BABF0D4653840312C2FCD3CB35D196 8E2E6580C863C2AA6ACD90D4B47A78C636BE0176 8FCA17A6EEBCC7AD17C4DEA053B8531BC40E5D87 B5E611CB37699E2061FAB5359CC1CA8AEB9544E2\r\n WARN 2012-12-12 19:34:57,761 (Worker thread '27') - Updating: 06EF09998C07EE279680EFB40D8D173B953BBB41 089C4A318256A5BE24751A18C15B12534088AE53 18ECC28594B73C11C8A0E29D2647BD8C0BCFCFB0 236BC8FC47E522279D04B03F9F24173CEEBC3CC4 2B2B03FBC06D85FD6F1D9F2FD06DB135D14EAA01 5347BE04928401EFE2B95BCD9B3E79DB5BC41001 5E55A3510C77E35EABB49CF0E2DD8D69ECB3B9F7 9FC003AE98DBAC93A78F8DBD8B5E05C40941C4EF D835783891D230FFB4B620195404A682310F6B28 DE398FAFF2E0A5B14FB464C4797E22C589A3356C\r\n WARN 2012-12-12 19:34:57,761 (Worker thread '28') - Updating: 19EA2C455D02F87BD90F42697A383329C87528EB 254A4AB5D1225F9BA950D6C57163F75C6CFFFFC0 28326FC3D745333CDDBEC3773E287852070A181E 2E01C7863900BB12317EE44ECF2DD3AFEE91521E 307883028721A1CCB7022E5836F453083E799960 53823AB0FF908EB8FFD3132DC4FC5B98E299B9A6 6F37A1F53B5788CFBD34CCFF6C3BE39F164CA220 949A65754EADE71A345AA79A0F3873210F161F73 9F2B2BBDFE7CCC8C96978AD7C264AD8037F2CC15 C565A81AB0F3F726FDAD117F4107A417D473ED90\r\n WARN 2012-12-12 19:34:57,761 (Worker thread '25') - Updating: 42B481A0A216F2427C32510AF60BC454003C404E 5ED258F4A057352BEA7FF004C99547F180A29569 7BED6B0D45CCD9AA2AD2104877581EE58DE422E9 84AB9FA028CC720613F52B5CB9A6892D17D3E245 BBA0A8216C1BDD1DF9C13D5375D0C02EB3F95DB2 C79FE39946B6928EB7205F7CFFA47A729CF0B661 CD824F7566B50CE109580D962E6E763C01332397 DD57F6FE90BB3E32B7FAD7F828CFAF8D935EB348 F86948D55405C4C116C6976E4F8459A0EE841D0D FEFBC683A56504DB7D418ADDBFF37FD53B275500\r\n WARN 2012-12-12 19:34:57,761 (Worker thread '26') - Updating: 05A24080B87E69BADDA0A18B3FFD15C7585AFDEE 06115678F7341BDA326CEC24B8EBC61068045500 1AEFEDD366A61686F0A8A8D26BC6EEC121020F57 27C2A7B08CB174D797E49A24970E51DAEEF10910 5C7F49ACB75FD2859A6149C56E465A018C7CAF9B 8CC7F639CB3459F917AC446A987D4F277A8E3ABB C839461E3EEE75420D5C50993023BD4FD89071D1 CABCC5DB287F47FDA363E88B8E1ADA75181FC44A FC14D78A477B160EA8B26170F8B4BD923C408930 FD0918C5F881ED4E548718557888491B4628CD93\r\n WARN 2012-12-12 19:34:57,761 (Worker thread '23') - Updating: 1CFD6C6B4D826A408EC0150A6DD29AB5C3109980 30453368183133EB1C15E7332107069CC05F8CF4 5CD048722B14CDE3F9C290F76456DDF0B2651A50 81B9643732699B6430014FADCE9D912B6FEC837E 8CDFBD16CA436568AC69DF33D4B3C30BD0F3E969 D3A1BD538E7B70A47408B34A6FB9FE729C302CD6 D6A92EE29556CB6DA708C7A62BC81487D9C0154A D9186FE82FF92AC4E015B65D629F917811D460AF E37AA6500F9169EB4584F8393D4ED7C6B4C0C24F FD0753B3F8FF1B5207856BAB18A4E95BC5D565BC\r\n WARN 2012-12-12 19:34:57,761 (Worker thread '24') - Updating: 2E95CCE9E2C1B45DE9E072AFDF887C8B71942E85 2F34184B314A85CB5FC9F7790BD7D6A60D71358B 47D7D7541742A4BF73AF2EA982B816D91D31618E 9802024F3BE53EA74EC6AEC988BA83DFD324C0BA 996569CB471D39FB4447813FE7EE9388671CCD57 ACA10747868899A55ADC9B639743BFFE13CCCD8D B976865B4C25BE2BDDC32772D7323161F289B625 BA96F4D762F9D3BC38C74469437ECA6BAD426EAF BC41C066F89F359F8E4F79C54D076884435A9A5B D0E19E1769871A98F620C22B58F6FE9F9ACAC440\r\n WARN 2012-12-12 19:34:57,771 (Worker thread '22') - Updating: 0F87592E9B7A46E5ED62CD24494494340CDF9017 2C25CD30BBA30CF206A2E1F1E790C3177D08DAA3 2FF4E8863AC478B3907842D9641B2A709CF12B08 35EA4158F31C1DC82CEA37E623043A6F7E3FF6D3 40A0F27E071B00D03EC1CE6E87072D4B9833B87B 4A5D5C909F7C2AEF31F4F5F609693FD9E93F6234 6821DBDCD0EE1790139249BD5672164DE564744D AE7B06C816DD8B0695C3B72346DD44B50031365A E66A1117DB7BF457C99C3BEA212D7C6060C6A57F EE095CD6ABFF89126C03C619C3B68A25D966C00F\r\n WARN 2012-12-12 19:34:57,771 (Worker thread '29') - Updating: 0593EFDEBC69F8EF57E3BBC6C028889F9EF149C5 08CB4439D7F6F61999FD30D1D25EF47ACA663528 14582338E03D44F26A15F010C2AFCE2922C784DD 1D8B8022946E5D57D01627C5063790EE9AC2AD00 683E03E53C5E3436A630BDDBAC9DCE9020A2F1D3 BDE5FD21AD2B122E979766D9AD52BC245E9C0240 E08DBEC97CE8CC5504331D358B94BF66F1939923 E6E2608BF4A29EAABEAB7D62F3E4013577AADC76 E9A9AC4471D155B51487B6715FD95A551EC0BB2C EFA897EB9FE6ECCC05DBC9F89E90E520C60EAED1\r\n{code}\r\n\r\nIt appears they all are ordered, as stipulated.  So there is no reason for a deadlock to develop, at least among the set of queries as you provided above.\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"created":"2012-12-13T00:42:36.475+0000","updated":"2012-12-13T00:42:36.475+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13531131","id":"13531131","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=myrna","name":"myrna","emailAddress":"m dot v dot lunteren at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Myrna van Lunteren","active":true},"body":"That timeframe for the timeout/deadlocks sounds like the default settings; the default deadlock timeout period is 20 seconds, and the default timeout is 60. There are properties to adjust these, see the Reference Manual (latest alpha: http://db.apache.org/derby/docs/dev/ref/) especially derby.locks.deadlockTimeout and derby.locks.waitTimeout. \r\nRegarding debug versions - for each derby release there is a db-derby-<version>-lib-debug.zip and db-derby-<version>.tar.gz file that holds just the debug jar files. We also call these the 'sane' jars. See for instance the 10.9.1.0 release page: http://db.apache.org/derby/releases/release-10.9.1.0.cgi under 'distributions'.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=myrna","name":"myrna","emailAddress":"m dot v dot lunteren at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Myrna van Lunteren","active":true},"created":"2012-12-13T16:05:33.138+0000","updated":"2012-12-13T16:05:33.138+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13531160","id":"13531160","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"body":"This parameter we attempt to set:\r\n\r\n  static\r\n  {\r\n    System.setProperty(\"derby.locks.waitTimeout\",\"-1\");\r\n  }\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"created":"2012-12-13T16:37:43.073+0000","updated":"2012-12-13T16:37:43.073+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13531219","id":"13531219","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Setting derby.locks.waitTimeout to -1 makes Derby wait indefinitely on locks if there is no deadlock. derby.locks.deadlockTimeout determines how long Derby should wait for a lock before it checks if there is a deadlock. So if you want deadlocks to be detected and resolved immediately, the latter property should be set to 0. (I think. The reference manual is silent on what 0 or negative deadlock timeout means, but that's how I read the code comments anyway.)","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2012-12-13T17:30:37.270+0000","updated":"2012-12-13T17:30:37.270+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13531280","id":"13531280","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"body":"Adding derby.locks.deadlockTimeout=0 cuts the time from 10x worse than other databases down to only 3x worse.  However, even with that setting, there is still quite a lot of long-running queries in the log:\r\n\r\n{code}\r\n WARN 2012-12-09 18:59:22,869 (Worker thread '10') - Found a long-running query (52511 ms): [SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE]\r\n WARN 2012-12-09 18:59:22,869 (Worker thread '10') -   Parameter 0: '033689A1424C66E5C15F3A553ED632D7711F18C7'\r\n WARN 2012-12-09 18:59:22,869 (Worker thread '10') -   Parameter 1: '1355097490879'\r\n WARN 2012-12-09 18:59:22,949 (main) - Found a long-running query (52071 ms): [SELECT jobid,CAST(COUNT(dochash) AS bigint) AS doccount FROM jobqueue t1 WHERE EXISTS(SELECT 'x' FROM jobs t0 WHERE t0.id=t1.jobid AND id=?) GROUP BY jobid]\r\n WARN 2012-12-09 18:59:22,949 (main) -   Parameter 0: '1355097490879'\r\n WARN 2012-12-09 18:59:22,949 (Worker thread '0') - Found a long-running query (30291 ms): [SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE]\r\n WARN 2012-12-09 18:59:22,949 (Worker thread '0') -   Parameter 0: '42B481A0A216F2427C32510AF60BC454003C404E'\r\n WARN 2012-12-09 18:59:22,949 (Worker thread '0') -   Parameter 1: '1355097490879'\r\n WARN 2012-12-09 18:59:22,949 (Finisher thread) - Found a long-running query (45233 ms): [SELECT id FROM jobqueue WHERE jobid=? AND status IN (?,?,?,?,?,?) FETCH NEXT 1 ROWS ONLY]\r\n WARN 2012-12-09 18:59:22,949 (Finisher thread) -   Parameter 0: '1355097490879'\r\n WARN 2012-12-09 18:59:22,949 (Finisher thread) -   Parameter 1: 'A'\r\n WARN 2012-12-09 18:59:22,949 (Finisher thread) -   Parameter 2: 'a'\r\n WARN 2012-12-09 18:59:22,949 (Finisher thread) -   Parameter 3: 'P'\r\n WARN 2012-12-09 18:59:22,949 (Finisher thread) -   Parameter 4: 'F'\r\n WARN 2012-12-09 18:59:22,949 (Finisher thread) -   Parameter 5: 'f'\r\n WARN 2012-12-09 18:59:22,949 (Finisher thread) -   Parameter 6: 'G'\r\n WARN 2012-12-09 18:59:22,969 (Stuffer thread) - Found a long-running query (51101 ms): [SELECT t0.id,t0.jobid,t0.dochash,t0.docid,t0.status,t0.failtime,t0.failcount,t0.priorityset FROM jobqueue t0 WHERE t0.status IN (?,?) AND t0.checkaction=? AND t0.checktime<=? AND EXISTS(SELECT 'x' FROM jobs t1 WHERE t1.status IN (?,?) AND t1.id=t0.jobid AND t1.priority=?) AND NOT EXISTS(SELECT 'x' FROM jobqueue t2 WHERE t2.dochash=t0.dochash AND t2.status IN (?,?,?,?,?,?) AND t2.jobid!=t0.jobid) AND NOT EXISTS(SELECT 'x' FROM prereqevents t3,events t4 WHERE t0.id=t3.owner AND t3.eventname=t4.name) ORDER BY t0.docpriority ASC,t0.status ASC,t0.checkaction ASC,t0.checktime ASC FETCH NEXT 120 ROWS ONLY]\r\n WARN 2012-12-09 18:59:22,969 (Stuffer thread) -   Parameter 0: 'P'\r\n WARN 2012-12-09 18:59:22,969 (Stuffer thread) -   Parameter 1: 'G'\r\n WARN 2012-12-09 18:59:22,969 (Stuffer thread) -   Parameter 2: 'R'\r\n WARN 2012-12-09 18:59:22,969 (Stuffer thread) -   Parameter 3: '1355097511858'\r\n WARN 2012-12-09 18:59:22,969 (Stuffer thread) -   Parameter 4: 'A'\r\n WARN 2012-12-09 18:59:22,969 (Stuffer thread) -   Parameter 5: 'a'\r\n WARN 2012-12-09 18:59:22,969 (Stuffer thread) -   Parameter 6: '5'\r\n WARN 2012-12-09 18:59:22,969 (Stuffer thread) -   Parameter 7: 'A'\r\n WARN 2012-12-09 18:59:22,969 (Stuffer thread) -   Parameter 8: 'F'\r\n WARN 2012-12-09 18:59:22,969 (Stuffer thread) -   Parameter 9: 'a'\r\n WARN 2012-12-09 18:59:22,969 (Stuffer thread) -   Parameter 10: 'f'\r\n WARN 2012-12-09 18:59:22,969 (Stuffer thread) -   Parameter 11: 'D'\r\n WARN 2012-12-09 18:59:22,969 (Stuffer thread) -   Parameter 12: 'd'\r\n WARN 2012-12-09 19:00:03,021 (Worker thread '6') - Found a long-running query (40052 ms): [SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE]\r\n WARN 2012-12-09 19:00:03,021 (Worker thread '6') -   Parameter 0: '089C4A318256A5BE24751A18C15B12534088AE53'\r\n WARN 2012-12-09 19:00:03,021 (Worker thread '6') -   Parameter 1: '1355097490879'\r\n WARN 2012-12-09 19:00:03,091 (main) - Found a long-running query (40142 ms): [SELECT jobid,CAST(COUNT(dochash) AS bigint) AS doccount FROM jobqueue t1 WHERE status IN (?,?,?,?,?,?) AND EXISTS(SELECT 'x' FROM jobs t0 WHERE t0.id=t1.jobid AND id=?) GROUP BY jobid]\r\n WARN 2012-12-09 19:00:03,091 (main) -   Parameter 0: 'A'\r\n WARN 2012-12-09 19:00:03,091 (main) -   Parameter 1: 'a'\r\n WARN 2012-12-09 19:00:03,091 (main) -   Parameter 2: 'P'\r\n WARN 2012-12-09 19:00:03,091 (main) -   Parameter 3: 'F'\r\n WARN 2012-12-09 19:00:03,091 (main) -   Parameter 4: 'f'\r\n WARN 2012-12-09 19:00:03,091 (main) -   Parameter 5: 'G'\r\n WARN 2012-12-09 19:00:03,091 (main) -   Parameter 6: '1355097490879'\r\n WARN 2012-12-09 19:00:03,091 (Finisher thread) - Found a long-running query (30124 ms): [SELECT id FROM jobqueue WHERE jobid=? AND status IN (?,?,?,?,?,?) FETCH NEXT 1 ROWS ONLY]\r\n WARN 2012-12-09 19:00:03,091 (Finisher thread) -   Parameter 0: '1355097490879'\r\n WARN 2012-12-09 19:00:03,091 (Finisher thread) -   Parameter 1: 'A'\r\n WARN 2012-12-09 19:00:03,091 (Finisher thread) -   Parameter 2: 'a'\r\n WARN 2012-12-09 19:00:03,091 (Finisher thread) -   Parameter 3: 'P'\r\n WARN 2012-12-09 19:00:03,091 (Finisher thread) -   Parameter 4: 'F'\r\n WARN 2012-12-09 19:00:03,091 (Finisher thread) -   Parameter 5: 'f'\r\n WARN 2012-12-09 19:00:03,091 (Finisher thread) -   Parameter 6: 'G'\r\n WARN 2012-12-09 19:00:03,111 (Worker thread '8') - Found a long-running query (39502 ms): [SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE]\r\n WARN 2012-12-09 19:00:03,111 (Worker thread '8') -   Parameter 0: '05A24080B87E69BADDA0A18B3FFD15C7585AFDEE'\r\n WARN 2012-12-09 19:00:03,111 (Worker thread '8') -   Parameter 1: '1355097490879'\r\n WARN 2012-12-09 19:00:03,111 (Stuffer thread) - Found a long-running query (40112 ms): [SELECT docpriority,jobid,dochash,docid FROM jobqueue t0 WHERE status IN (?,?) AND checkaction=? AND checktime<=? AND EXISTS(SELECT 'x' FROM jobs t1 WHERE t1.status IN (?,?) AND t1.id=t0.jobid)  ORDER BY docpriority ASC,status ASC,checkaction ASC,checktime ASC FETCH NEXT 1 ROWS ONLY]\r\n WARN 2012-12-09 19:00:03,111 (Stuffer thread) -   Parameter 0: 'P'\r\n WARN 2012-12-09 19:00:03,111 (Stuffer thread) -   Parameter 1: 'G'\r\n WARN 2012-12-09 19:00:03,111 (Stuffer thread) -   Parameter 2: 'R'\r\n WARN 2012-12-09 19:00:03,111 (Stuffer thread) -   Parameter 3: '1355097511858'\r\n WARN 2012-12-09 19:00:03,111 (Stuffer thread) -   Parameter 4: 'A'\r\n WARN 2012-12-09 19:00:03,111 (Stuffer thread) -   Parameter 5: 'a'\r\n WARN 2012-12-09 19:00:43,138 (Worker thread '8') - Found a long-running query (40007 ms): [SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE]\r\n WARN 2012-12-09 19:00:43,138 (Worker thread '8') -   Parameter 0: '06115678F7341BDA326CEC24B8EBC61068045500'\r\n WARN 2012-12-09 19:00:43,138 (Worker thread '8') -   Parameter 1: '1355097490879'\r\n WARN 2012-12-09 19:00:43,218 (main) - Found a long-running query (40127 ms): [SELECT jobid,CAST(COUNT(dochash) AS bigint) AS doccount FROM jobqueue t1 WHERE status IN (?,?,?,?,?) AND EXISTS(SELECT 'x' FROM jobs t0 WHERE t0.id=t1.jobid AND id=?) GROUP BY jobid]\r\n WARN 2012-12-09 19:00:43,218 (main) -   Parameter 0: 'C'\r\n WARN 2012-12-09 19:00:43,218 (main) -   Parameter 1: 'Z'\r\n WARN 2012-12-09 19:00:43,218 (main) -   Parameter 2: 'F'\r\n WARN 2012-12-09 19:00:43,218 (main) -   Parameter 3: 'f'\r\n WARN 2012-12-09 19:00:43,218 (main) -   Parameter 4: 'G'\r\n WARN 2012-12-09 19:00:43,218 (main) -   Parameter 5: '1355097490879'\r\n WARN 2012-12-09 19:00:43,218 (Worker thread '1') - Found a long-running query (39417 ms): [SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE]\r\n WARN 2012-12-09 19:00:43,218 (Worker thread '1') -   Parameter 0: '0593EFDEBC69F8EF57E3BBC6C028889F9EF149C5'\r\n WARN 2012-12-09 19:00:43,218 (Worker thread '1') -   Parameter 1: '1355097490879'\r\n WARN 2012-12-09 19:00:43,218 (Worker thread '12') - Found a long-running query (48812 ms): [SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE]\r\n WARN 2012-12-09 19:00:43,218 (Worker thread '12') -   Parameter 0: '0F87592E9B7A46E5ED62CD24494494340CDF9017'\r\n WARN 2012-12-09 19:00:43,218 (Worker thread '12') -   Parameter 1: '1355097490879'\r\n WARN 2012-12-09 19:00:43,218 (Worker thread '9') - Found a long-running query (32241 ms): [SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE]\r\n WARN 2012-12-09 19:00:43,218 (Worker thread '9') -   Parameter 0: '0CDC72CE178F4A53C54B31EEAA879ED10C8ABF50'\r\n WARN 2012-12-09 19:00:43,218 (Worker thread '9') -   Parameter 1: '1355097490879'\r\n WARN 2012-12-09 19:00:43,218 (Finisher thread) - Found a long-running query (30112 ms): [SELECT id FROM jobqueue WHERE jobid=? AND status IN (?,?,?,?,?,?) FETCH NEXT 1 ROWS ONLY]\r\n WARN 2012-12-09 19:00:43,218 (Finisher thread) -   Parameter 0: '1355097490879'\r\n WARN 2012-12-09 19:00:43,218 (Finisher thread) -   Parameter 1: 'A'\r\n WARN 2012-12-09 19:00:43,218 (Finisher thread) -   Parameter 2: 'a'\r\n WARN 2012-12-09 19:00:43,218 (Finisher thread) -   Parameter 3: 'P'\r\n WARN 2012-12-09 19:00:43,218 (Finisher thread) -   Parameter 4: 'F'\r\n WARN 2012-12-09 19:00:43,218 (Finisher thread) -   Parameter 5: 'f'\r\n WARN 2012-12-09 19:00:43,218 (Finisher thread) -   Parameter 6: 'G'\r\n WARN 2012-12-09 19:01:03,308 (Worker thread '0') - Found a long-running query (40889 ms): [SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE]\r\n WARN 2012-12-09 19:01:03,308 (Worker thread '0') -   Parameter 0: '42B481A0A216F2427C32510AF60BC454003C404E'\r\n WARN 2012-12-09 19:01:03,308 (Worker thread '0') -   Parameter 1: '1355097490879'\r\n WARN 2012-12-09 19:01:03,448 (Worker thread '2') - Found a long-running query (32970 ms): [SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE]\r\n WARN 2012-12-09 19:01:03,448 (Worker thread '2') -   Parameter 0: '19EA2C455D02F87BD90F42697A383329C87528EB'\r\n WARN 2012-12-09 19:01:03,448 (Worker thread '2') -   Parameter 1: '1355097490879'\r\n WARN 2012-12-09 19:01:03,458 (Stuffer thread) - Found a long-running query (60227 ms): [SELECT t0.id,t0.jobid,t0.dochash,t0.docid,t0.status,t0.failtime,t0.failcount,t0.priorityset FROM jobqueue t0 WHERE t0.status IN (?,?) AND t0.checkaction=? AND t0.checktime<=? AND EXISTS(SELECT 'x' FROM jobs t1 WHERE t1.status IN (?,?) AND t1.id=t0.jobid AND t1.priority=?) AND NOT EXISTS(SELECT 'x' FROM jobqueue t2 WHERE t2.dochash=t0.dochash AND t2.status IN (?,?,?,?,?,?) AND t2.jobid!=t0.jobid) AND NOT EXISTS(SELECT 'x' FROM prereqevents t3,events t4 WHERE t0.id=t3.owner AND t3.eventname=t4.name) ORDER BY t0.docpriority ASC,t0.status ASC,t0.checkaction ASC,t0.checktime ASC FETCH NEXT 120 ROWS ONLY]\r\n WARN 2012-12-09 19:01:03,458 (Stuffer thread) -   Parameter 0: 'P'\r\n WARN 2012-12-09 19:01:03,458 (Stuffer thread) -   Parameter 1: 'G'\r\n WARN 2012-12-09 19:01:03,458 (Stuffer thread) -   Parameter 2: 'R'\r\n WARN 2012-12-09 19:01:03,458 (Stuffer thread) -   Parameter 3: '1355097603111'\r\n WARN 2012-12-09 19:01:03,458 (Stuffer thread) -   Parameter 4: 'A'\r\n WARN 2012-12-09 19:01:03,458 (Stuffer thread) -   Parameter 5: 'a'\r\n WARN 2012-12-09 19:01:03,458 (Stuffer thread) -   Parameter 6: '5'\r\n WARN 2012-12-09 19:01:03,458 (Stuffer thread) -   Parameter 7: 'A'\r\n WARN 2012-12-09 19:01:03,458 (Stuffer thread) -   Parameter 8: 'F'\r\n WARN 2012-12-09 19:01:03,458 (Stuffer thread) -   Parameter 9: 'a'\r\n WARN 2012-12-09 19:01:03,458 (Stuffer thread) -   Parameter 10: 'f'\r\n WARN 2012-12-09 19:01:03,458 (Stuffer thread) -   Parameter 11: 'D'\r\n WARN 2012-12-09 19:01:03,458 (Stuffer thread) -   Parameter 12: 'd'\r\n{code}\r\n\r\nCan you explain this?\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"created":"2012-12-13T18:25:55.553+0000","updated":"2012-12-13T18:25:55.553+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13542038","id":"13542038","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"body":"Any further comment on this ticket?\r\n\r\nFWIW, the situation as I understand it is:\r\n\r\n- Derby is reporting a deadlock on a transaction that locks records always in a specific order, so there should be no deadlock occurring in the first place AFAICT\r\n- Even with the given test that uses only runt database tables of max size 100 rows, and with derby.locks.deadlockTimeout=0, I see huge waits of 50 seconds or so on some queries\r\n- All other supported databases perform fine on this test with *no* reported deadlocks (or deadlock-derived failbacks/retries)\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"created":"2013-01-02T07:14:58.871+0000","updated":"2013-01-02T07:14:58.871+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13545362","id":"13545362","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"body":"I instrumented our Derby and HSQLDB database drivers to dump to standard out any time a deadlock exception was thrown.  For HSQLDB on the identical task (ant run-rss-tests-HSQLDB), no deadlock exceptions whatsoever were thrown.  For derby, here is the output:\r\n\r\n{code}\r\n\r\nmcf-test-build.run-derby:\r\n    [mkdir] Created dir: C:\\wip\\mcf\\trunk\\tests\\rss\\test-derby-output\r\n    [junit] Testsuite: org.apache.manifoldcf.rss_tests.RSSSimpleCrawlDerbyIT\r\n    [junit] Configuration file successfully read\r\n    [junit] 36 [main] INFO org.eclipse.jetty.server.Server - jetty-7.5.4.v20111024\r\n    [junit] 120 [main] INFO org.eclipse.jetty.webapp.WebInfConfiguration - Extract jar:file:/C:/wip/mcf/trunk/framework/build/war-proprietary/mcf-crawler-ui.war!/ to C:\\Users\\Karl\\AppData\\Local\\Temp\\jetty-0.0.0.0-8346-mcf-crawler-ui.war-_mcf-crawler-ui-any-\\webapp\r\n    [junit] 1951 [main] INFO org.eclipse.jetty.server.handler.ContextHandler - started o.e.j.w.WebAppContext{/mcf-crawler-ui,file:/C:/Users/Karl/AppData/Local/Temp/jetty-0.0.0.0-8346-mcf-crawler-ui.war-_mcf-crawler-ui-any-/webapp/},../../../framework/build/war-proprietary/mcf-crawler-ui.war\r\n    [junit] 2161 [main] INFO org.eclipse.jetty.webapp.WebInfConfiguration - Extract jar:file:/C:/wip/mcf/trunk/framework/build/war-proprietary/mcf-authority-service.war!/ to C:\\Users\\Karl\\AppData\\Local\\Temp\\jetty-0.0.0.0-8346-mcf-authority-service.war-_mcf-authority-service-any-\\webapp\r\n    [junit] 3752 [main] INFO org.eclipse.jetty.server.handler.ContextHandler - started o.e.j.w.WebAppContext{/mcf-authority-service,file:/C:/Users/Karl/AppData/Local/Temp/jetty-0.0.0.0-8346-mcf-authority-service.war-_mcf-authority-service-any-/webapp/},../../../framework/build/war-proprietary/mcf-authority-service.war\r\n    [junit] 3786 [main] INFO org.eclipse.jetty.webapp.WebInfConfiguration - Extract jar:file:/C:/wip/mcf/trunk/framework/build/war-proprietary/mcf-api-service.war!/ to C:\\Users\\Karl\\AppData\\Local\\Temp\\jetty-0.0.0.0-8346-mcf-api-service.war-_mcf-api-service-any-\\webapp\r\n    [junit] 5611 [main] INFO org.eclipse.jetty.server.handler.ContextHandler - started o.e.j.w.WebAppContext{/mcf-api-service,file:/C:/Users/Karl/AppData/Local/Temp/jetty-0.0.0.0-8346-mcf-api-service.war-_mcf-api-service-any-/webapp/},../../../framework/build/war-proprietary/mcf-api-service.war\r\n    [junit] 5625 [main] INFO org.eclipse.jetty.server.AbstractConnector - Started SelectChannelConnector@0.0.0.0:8346 STARTING\r\n    [junit] 5652 [main] INFO org.eclipse.jetty.server.Server - jetty-7.5.4.v20111024\r\n    [junit] 5652 [main] INFO org.eclipse.jetty.server.handler.ContextHandler - started o.e.j.s.ServletContextHandler{/rss,null}\r\n    [junit] 5694 [main] INFO org.eclipse.jetty.server.AbstractConnector - Started SelectChannelConnector@0.0.0.0:8189 STARTING\r\n    [junit] java.lang.Exception: Deadlock\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.reinterpretException(DBInterfaceDerby.java:816)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:976)\r\n    [junit] \tat org.apache.manifoldcf.crawler.jobs.JobManager.addDocuments(JobManager.java:4085)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.processDocumentReferences(WorkerThread.java:1932)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.flush(WorkerThread.java:1863)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread.run(WorkerThread.java:554)\r\n    [junit] Caused by: org.apache.manifoldcf.core.interfaces.ManifoldCFException: Database exception: SQLException getting resultset (40001): A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,17)\r\n    [junit]   Waiting XID : {715, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {714, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,18)\r\n    [junit]   Waiting XID : {714, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {715, X} \r\n    [junit] . The selected victim is XID : 715.\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeViaThread(Database.java:717)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeUncachedQuery(Database.java:745)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$QueryCacheExecutor.create(Database.java:1430)\r\n    [junit] \tat org.apache.manifoldcf.core.cachemanager.CacheManager.findObjectsAndExecute(CacheManager.java:144)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeQuery(Database.java:186)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:972)\r\n    [junit] \t... 4 more\r\n    [junit] Caused by: java.sql.SQLTransactionRollbackException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,17)\r\n    [junit]   Waiting XID : {715, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {714, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,18)\r\n    [junit]   Waiting XID : {714, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {715, X} \r\n    [junit] . The selected victim is XID : 715.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.closeOnTransactionError(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.movePosition(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.next(Unknown Source)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.getData(Database.java:948)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.execute(Database.java:866)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$ExecuteQueryThread.run(Database.java:677)\r\n    [junit] Caused by: java.sql.SQLException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,17)\r\n    [junit]   Waiting XID : {715, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {714, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,18)\r\n    [junit]   Waiting XID : {714, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {715, X} \r\n    [junit] . The selected victim is XID : 715.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)\r\n    [junit] \t... 12 more\r\n    [junit] Caused by: ERROR 40001: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,17)\r\n    [junit]   Waiting XID : {715, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {714, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,18)\r\n    [junit]   Waiting XID : {714, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {715, X} \r\n    [junit] . The selected victim is XID : 715.\r\n    [junit] \tat org.apache.derby.iapi.error.StandardException.newException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.Deadlock.buildException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentLockSet.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.AbstractPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.raw.xact.RowLocking2.lockRecordForRead(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3.lockRowOnPage(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3._lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLockingRR.lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeForwardScan.fetchRows(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeScan.fetchNext(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.TableScanResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow(Unknown Source)\r\n    [junit] \t... 5 more\r\n    [junit] java.lang.Exception: Deadlock\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.reinterpretException(DBInterfaceDerby.java:816)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:976)\r\n    [junit] \tat org.apache.manifoldcf.crawler.jobs.JobManager.addDocuments(JobManager.java:4085)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.processDocumentReferences(WorkerThread.java:1932)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.flush(WorkerThread.java:1863)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread.run(WorkerThread.java:554)\r\n    [junit] Caused by: org.apache.manifoldcf.core.interfaces.ManifoldCFException: Database exception: SQLException getting resultset (40001): A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {719, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {722, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {724, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {721, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 719.\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeViaThread(Database.java:717)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeUncachedQuery(Database.java:745)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$QueryCacheExecutor.create(Database.java:1430)\r\n    [junit] \tat org.apache.manifoldcf.core.cachemanager.CacheManager.findObjectsAndExecute(CacheManager.java:144)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeQuery(Database.java:186)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:972)\r\n    [junit] \t... 4 more\r\n    [junit] Caused by: java.sql.SQLTransactionRollbackException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {719, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {722, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {724, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {721, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 719.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.closeOnTransactionError(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.movePosition(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.next(Unknown Source)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.getData(Database.java:948)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.execute(Database.java:866)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$ExecuteQueryThread.run(Database.java:677)\r\n    [junit] Caused by: java.sql.SQLException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {719, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {722, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {724, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {721, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 719.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)\r\n    [junit] \t... 12 more\r\n    [junit] Caused by: ERROR 40001: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {719, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {722, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {724, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {721, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 719.\r\n    [junit] \tat org.apache.derby.iapi.error.StandardException.newException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.Deadlock.buildException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentLockSet.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.AbstractPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.raw.xact.RowLocking2.lockRecordForRead(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3.lockRowOnPage(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3._lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLockingRR.lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeForwardScan.fetchRows(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeScan.fetchNext(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.TableScanResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow(Unknown Source)\r\n    [junit] \t... 5 more\r\n    [junit] java.lang.Exception: Deadlock\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.reinterpretException(DBInterfaceDerby.java:816)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:976)\r\n    [junit] \tat org.apache.manifoldcf.crawler.jobs.JobManager.addDocuments(JobManager.java:4085)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.processDocumentReferences(WorkerThread.java:1932)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.flush(WorkerThread.java:1863)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread.run(WorkerThread.java:554)\r\n    [junit] Caused by: org.apache.manifoldcf.core.interfaces.ManifoldCFException: Database exception: SQLException getting resultset (40001): A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {721, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {722, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {724, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 721.\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeViaThread(Database.java:717)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeUncachedQuery(Database.java:745)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$QueryCacheExecutor.create(Database.java:1430)\r\n    [junit] \tat org.apache.manifoldcf.core.cachemanager.CacheManager.findObjectsAndExecute(CacheManager.java:144)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeQuery(Database.java:186)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:972)\r\n    [junit] \t... 4 more\r\n    [junit] Caused by: java.sql.SQLTransactionRollbackException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {721, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {722, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {724, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 721.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.closeOnTransactionError(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.movePosition(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.next(Unknown Source)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.getData(Database.java:948)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.execute(Database.java:866)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$ExecuteQueryThread.run(Database.java:677)\r\n    [junit] Caused by: java.sql.SQLException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {721, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {722, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {724, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 721.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)\r\n    [junit] \t... 12 more\r\n    [junit] Caused by: ERROR 40001: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {721, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {722, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {724, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 721.\r\n    [junit] \tat org.apache.derby.iapi.error.StandardException.newException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.Deadlock.buildException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentLockSet.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.AbstractPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.raw.xact.RowLocking2.lockRecordForRead(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3.lockRowOnPage(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3._lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLockingRR.lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeForwardScan.fetchRows(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeScan.fetchNext(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.TableScanResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow(Unknown Source)\r\n    [junit] \t... 5 more\r\n    [junit] java.lang.Exception: Deadlock\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.reinterpretException(DBInterfaceDerby.java:816)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:976)\r\n    [junit] \tat org.apache.manifoldcf.crawler.jobs.JobManager.addDocuments(JobManager.java:4085)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.processDocumentReferences(WorkerThread.java:1932)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.flush(WorkerThread.java:1863)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread.run(WorkerThread.java:554)\r\n    [junit] Caused by: org.apache.manifoldcf.core.interfaces.ManifoldCFException: Database exception: SQLException getting resultset (40001): A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {724, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {722, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 724.\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeViaThread(Database.java:717)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeUncachedQuery(Database.java:745)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$QueryCacheExecutor.create(Database.java:1430)\r\n    [junit] \tat org.apache.manifoldcf.core.cachemanager.CacheManager.findObjectsAndExecute(CacheManager.java:144)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeQuery(Database.java:186)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:972)\r\n    [junit] \t... 4 more\r\n    [junit] Caused by: java.sql.SQLTransactionRollbackException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {724, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {722, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 724.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.closeOnTransactionError(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.movePosition(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.next(Unknown Source)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.getData(Database.java:948)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.execute(Database.java:866)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$ExecuteQueryThread.run(Database.java:677)\r\n    [junit] Caused by: java.sql.SQLException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {724, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {722, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 724.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)\r\n    [junit] \t... 12 more\r\n    [junit] Caused by: ERROR 40001: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {724, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {722, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 724.\r\n    [junit] \tat org.apache.derby.iapi.error.StandardException.newException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.Deadlock.buildException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentLockSet.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.AbstractPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.raw.xact.RowLocking2.lockRecordForRead(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3.lockRowOnPage(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3._lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLockingRR.lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeForwardScan.fetchRows(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeScan.fetchNext(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.TableScanResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow(Unknown Source)\r\n    [junit] \t... 5 more\r\n    [junit] java.lang.Exception: Deadlock\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.reinterpretException(DBInterfaceDerby.java:816)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:976)\r\n    [junit] \tat org.apache.manifoldcf.crawler.jobs.JobManager.addDocuments(JobManager.java:4085)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.processDocumentReferences(WorkerThread.java:1932)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.flush(WorkerThread.java:1863)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread.run(WorkerThread.java:554)\r\n    [junit] Caused by: org.apache.manifoldcf.core.interfaces.ManifoldCFException: Database exception: SQLException getting resultset (40001): A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {722, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 722.\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeViaThread(Database.java:717)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeUncachedQuery(Database.java:745)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$QueryCacheExecutor.create(Database.java:1430)\r\n    [junit] \tat org.apache.manifoldcf.core.cachemanager.CacheManager.findObjectsAndExecute(CacheManager.java:144)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeQuery(Database.java:186)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:972)\r\n    [junit] \t... 4 more\r\n    [junit] Caused by: java.sql.SQLTransactionRollbackException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {722, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 722.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.closeOnTransactionError(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.movePosition(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.next(Unknown Source)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.getData(Database.java:948)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.execute(Database.java:866)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$ExecuteQueryThread.run(Database.java:677)\r\n    [junit] Caused by: java.sql.SQLException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {722, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 722.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)\r\n    [junit] \t... 12 more\r\n    [junit] Caused by: ERROR 40001: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {722, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 722.\r\n    [junit] \tat org.apache.derby.iapi.error.StandardException.newException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.Deadlock.buildException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentLockSet.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.AbstractPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.raw.xact.RowLocking2.lockRecordForRead(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3.lockRowOnPage(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3._lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLockingRR.lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeForwardScan.fetchRows(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeScan.fetchNext(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.TableScanResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow(Unknown Source)\r\n    [junit] \t... 5 more\r\n    [junit] java.lang.Exception: Deadlock\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.reinterpretException(DBInterfaceDerby.java:816)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:976)\r\n    [junit] \tat org.apache.manifoldcf.crawler.jobs.JobManager.addDocuments(JobManager.java:4085)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.processDocumentReferences(WorkerThread.java:1932)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.flush(WorkerThread.java:1863)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread.run(WorkerThread.java:554)\r\n    [junit] Caused by: org.apache.manifoldcf.core.interfaces.ManifoldCFException: Database exception: SQLException getting resultset (40001): A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 723.\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeViaThread(Database.java:717)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeUncachedQuery(Database.java:745)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$QueryCacheExecutor.create(Database.java:1430)\r\n    [junit] \tat org.apache.manifoldcf.core.cachemanager.CacheManager.findObjectsAndExecute(CacheManager.java:144)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeQuery(Database.java:186)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:972)\r\n    [junit] \t... 4 more\r\n    [junit] Caused by: java.sql.SQLTransactionRollbackException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 723.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.closeOnTransactionError(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.movePosition(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.next(Unknown Source)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.getData(Database.java:948)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.execute(Database.java:866)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$ExecuteQueryThread.run(Database.java:677)\r\n    [junit] Caused by: java.sql.SQLException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 723.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)\r\n    [junit] \t... 12 more\r\n    [junit] Caused by: ERROR 40001: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {723, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 723.\r\n    [junit] \tat org.apache.derby.iapi.error.StandardException.newException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.Deadlock.buildException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentLockSet.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.AbstractPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.raw.xact.RowLocking2.lockRecordForRead(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3.lockRowOnPage(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3._lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLockingRR.lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeForwardScan.fetchRows(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeScan.fetchNext(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.TableScanResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow(Unknown Source)\r\n    [junit] \t... 5 more\r\n    [junit] java.lang.Exception: Deadlock\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.reinterpretException(DBInterfaceDerby.java:816)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:976)\r\n    [junit] \tat org.apache.manifoldcf.crawler.jobs.JobManager.addDocuments(JobManager.java:4085)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.processDocumentReferences(WorkerThread.java:1932)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.flush(WorkerThread.java:1863)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread.run(WorkerThread.java:554)\r\n    [junit] Caused by: org.apache.manifoldcf.core.interfaces.ManifoldCFException: Database exception: SQLException getting resultset (40001): A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 725.\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeViaThread(Database.java:717)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeUncachedQuery(Database.java:745)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$QueryCacheExecutor.create(Database.java:1430)\r\n    [junit] \tat org.apache.manifoldcf.core.cachemanager.CacheManager.findObjectsAndExecute(CacheManager.java:144)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeQuery(Database.java:186)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:972)\r\n    [junit] \t... 4 more\r\n    [junit] Caused by: java.sql.SQLTransactionRollbackException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 725.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.closeOnTransactionError(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.movePosition(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.next(Unknown Source)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.getData(Database.java:948)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.execute(Database.java:866)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$ExecuteQueryThread.run(Database.java:677)\r\n    [junit] Caused by: java.sql.SQLException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 725.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)\r\n    [junit] \t... 12 more\r\n    [junit] Caused by: ERROR 40001: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {725, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit] . The selected victim is XID : 725.\r\n    [junit] \tat org.apache.derby.iapi.error.StandardException.newException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.Deadlock.buildException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentLockSet.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.AbstractPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.raw.xact.RowLocking2.lockRecordForRead(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3.lockRowOnPage(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3._lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLockingRR.lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeForwardScan.fetchRows(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeScan.fetchNext(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.TableScanResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow(Unknown Source)\r\n    [junit] \t... 5 more\r\n    [junit] java.lang.Exception: Deadlock\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.reinterpretException(DBInterfaceDerby.java:816)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:976)\r\n    [junit] \tat org.apache.manifoldcf.crawler.jobs.JobManager.addDocuments(JobManager.java:4085)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.processDocumentReferences(WorkerThread.java:1932)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.flush(WorkerThread.java:1863)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread.run(WorkerThread.java:554)\r\n    [junit] Caused by: org.apache.manifoldcf.core.interfaces.ManifoldCFException: Database exception: SQLException getting resultset (40001): A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] . The selected victim is XID : 718.\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeViaThread(Database.java:717)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeUncachedQuery(Database.java:745)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$QueryCacheExecutor.create(Database.java:1430)\r\n    [junit] \tat org.apache.manifoldcf.core.cachemanager.CacheManager.findObjectsAndExecute(CacheManager.java:144)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeQuery(Database.java:186)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:972)\r\n    [junit] \t... 4 more\r\n    [junit] Caused by: java.sql.SQLTransactionRollbackException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] . The selected victim is XID : 718.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.closeOnTransactionError(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.movePosition(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.next(Unknown Source)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.getData(Database.java:948)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.execute(Database.java:866)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$ExecuteQueryThread.run(Database.java:677)\r\n    [junit] Caused by: java.sql.SQLException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] . The selected victim is XID : 718.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)\r\n    [junit] \t... 12 more\r\n    [junit] Caused by: ERROR 40001: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,28)\r\n    [junit]   Waiting XID : {718, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {717, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,29)\r\n    [junit]   Waiting XID : {717, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {718, X} \r\n    [junit] . The selected victim is XID : 718.\r\n    [junit] \tat org.apache.derby.iapi.error.StandardException.newException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.Deadlock.buildException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentLockSet.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.AbstractPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.raw.xact.RowLocking2.lockRecordForRead(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3.lockRowOnPage(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3._lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLockingRR.lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeForwardScan.fetchRows(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeScan.fetchNext(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.TableScanResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow(Unknown Source)\r\n    [junit] \t... 5 more\r\n    [junit] java.lang.Exception: Deadlock\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.reinterpretException(DBInterfaceDerby.java:816)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:976)\r\n    [junit] \tat org.apache.manifoldcf.crawler.jobs.JobManager.addDocuments(JobManager.java:4085)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.processDocumentReferences(WorkerThread.java:1932)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.flush(WorkerThread.java:1863)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread.run(WorkerThread.java:554)\r\n    [junit] Caused by: org.apache.manifoldcf.core.interfaces.ManifoldCFException: Database exception: SQLException getting resultset (40001): A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,51)\r\n    [junit]   Waiting XID : {759, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {762, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,50)\r\n    [junit]   Waiting XID : {762, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {759, X} \r\n    [junit] . The selected victim is XID : 759.\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeViaThread(Database.java:717)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeUncachedQuery(Database.java:745)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$QueryCacheExecutor.create(Database.java:1430)\r\n    [junit] \tat org.apache.manifoldcf.core.cachemanager.CacheManager.findObjectsAndExecute(CacheManager.java:144)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeQuery(Database.java:186)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:972)\r\n    [junit] \t... 4 more\r\n    [junit] Caused by: java.sql.SQLTransactionRollbackException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,51)\r\n    [junit]   Waiting XID : {759, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {762, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,50)\r\n    [junit]   Waiting XID : {762, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {759, X} \r\n    [junit] . The selected victim is XID : 759.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.closeOnTransactionError(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.movePosition(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.next(Unknown Source)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.getData(Database.java:948)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.execute(Database.java:866)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$ExecuteQueryThread.run(Database.java:677)\r\n    [junit] Caused by: java.sql.SQLException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,51)\r\n    [junit]   Waiting XID : {759, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {762, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,50)\r\n    [junit]   Waiting XID : {762, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {759, X} \r\n    [junit] . The selected victim is XID : 759.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)\r\n    [junit] \t... 12 more\r\n    [junit] Caused by: ERROR 40001: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,51)\r\n    [junit]   Waiting XID : {759, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {762, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,50)\r\n    [junit]   Waiting XID : {762, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {759, X} \r\n    [junit] . The selected victim is XID : 759.\r\n    [junit] \tat org.apache.derby.iapi.error.StandardException.newException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.Deadlock.buildException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentLockSet.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.AbstractPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.raw.xact.RowLocking2.lockRecordForRead(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3.lockRowOnPage(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3._lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLockingRR.lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeForwardScan.fetchRows(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeScan.fetchNext(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.TableScanResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow(Unknown Source)\r\n    [junit] \t... 5 more\r\n    [junit] java.lang.Exception: Deadlock\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.reinterpretException(DBInterfaceDerby.java:816)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:976)\r\n    [junit] \tat org.apache.manifoldcf.crawler.jobs.JobManager.addDocuments(JobManager.java:4085)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.processDocumentReferences(WorkerThread.java:1932)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread$ProcessActivity.flush(WorkerThread.java:1863)\r\n    [junit] \tat org.apache.manifoldcf.crawler.system.WorkerThread.run(WorkerThread.java:554)\r\n    [junit] Caused by: org.apache.manifoldcf.core.interfaces.ManifoldCFException: Database exception: SQLException getting resultset (40001): A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,50)\r\n    [junit]   Waiting XID : {761, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {759, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,49)\r\n    [junit]   Waiting XID : {759, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {761, X} \r\n    [junit] . The selected victim is XID : 761.\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeViaThread(Database.java:717)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeUncachedQuery(Database.java:745)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$QueryCacheExecutor.create(Database.java:1430)\r\n    [junit] \tat org.apache.manifoldcf.core.cachemanager.CacheManager.findObjectsAndExecute(CacheManager.java:144)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.executeQuery(Database.java:186)\r\n    [junit] \tat org.apache.manifoldcf.core.database.DBInterfaceDerby.performQuery(DBInterfaceDerby.java:972)\r\n    [junit] \t... 4 more\r\n    [junit] Caused by: java.sql.SQLTransactionRollbackException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,50)\r\n    [junit]   Waiting XID : {761, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {759, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,49)\r\n    [junit]   Waiting XID : {759, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {761, X} \r\n    [junit] . The selected victim is XID : 761.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.closeOnTransactionError(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.movePosition(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.EmbedResultSet.next(Unknown Source)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.getData(Database.java:948)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database.execute(Database.java:866)\r\n    [junit] \tat org.apache.manifoldcf.core.database.Database$ExecuteQueryThread.run(Database.java:677)\r\n    [junit] Caused by: java.sql.SQLException: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,50)\r\n    [junit]   Waiting XID : {761, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {759, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,49)\r\n    [junit]   Waiting XID : {759, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {761, X} \r\n    [junit] . The selected victim is XID : 761.\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.jdbc.SQLExceptionFactory40.wrapArgsForTransportAcrossDRDA(Unknown Source)\r\n    [junit] \t... 12 more\r\n    [junit] Caused by: ERROR 40001: A lock could not be obtained due to a deadlock, cycle of locks and waiters is:\r\n    [junit] Lock : ROW, JOBQUEUE, (1,50)\r\n    [junit]   Waiting XID : {761, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {759, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,49)\r\n    [junit]   Waiting XID : {759, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {761, X} \r\n    [junit] . The selected victim is XID : 761.\r\n    [junit] \tat org.apache.derby.iapi.error.StandardException.newException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.Deadlock.buildException(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentLockSet.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.AbstractPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.services.locks.ConcurrentPool.lockObject(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.raw.xact.RowLocking2.lockRecordForRead(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.heap.HeapController.lockRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3.lockRowOnPage(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLocking3._lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.index.B2IRowLockingRR.lockScanRow(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeForwardScan.fetchRows(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.store.access.btree.BTreeScan.fetchNext(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.TableScanResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.IndexRowToBaseRowResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)\r\n    [junit] \tat org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow(Unknown Source)\r\n    [junit] \t... 5 more\r\n    [junit] Crawl required 100714 milliseconds\r\n{code}\r\n\r\nSome interesting things to note.  First, there are a lot of \"deadlocks\" where the \"cycles\" make no sense to me at all.  For example, the very first deadlock:\r\n\r\n{code}\r\n    [junit] Lock : ROW, JOBQUEUE, (1,17)\r\n    [junit]   Waiting XID : {715, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {714, X} \r\n    [junit] Lock : ROW, JOBQUEUE, (1,18)\r\n    [junit]   Waiting XID : {714, U} , APP, SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n    [junit]   Granted XID : {715, X} \r\n    [junit] . The selected victim is XID : 715.\r\n{code}\r\n\r\nIt looks like the very same one-row operation is somehow grabbing two different locks in random order.  Pretty much all of the deadlocks seem to be variants of this same problem.  Does anyone have an explanation for why Derby is throwing two locks for a single row update?  and why it is throwing them in random order?\r\n\r\n\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"created":"2013-01-06T09:53:40.061+0000","updated":"2013-01-06T09:53:40.061+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13545596","id":"13545596","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"body":"The threads are grabbing locks on rows in JOBQUEUE in different order (#17, 18), hence the deadlock. Why they do, is the question to answer here. It could be the order in which the application issues the queries, or the way the Derby executes them, possibly involving indexes.\r\n\r\nSome questions: \r\n\r\nIn this query, \"SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\":\r\n\r\ndoes this select a single row or multiple rows? If it is a single row, does the same thread's transaction access multiple such rows, i.e. use multiple of these queries in the same transaction?. If they do, are those accesses guaranteed to be in the same order (say, ascending on id)?. Are there other SQL statements on JOBQUEUE that could require write locks on these row active at this time?\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"created":"2013-01-07T03:06:15.700+0000","updated":"2013-01-07T03:06:15.700+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13545736","id":"13545736","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"body":"This query selects for a single row.\r\n\r\nThis is within a SERIALIZED transaction which is capable of handling multiple rows.  As has been posted earlier in this ticket, the accesses within the transaction are always ordered by dochash, and I have verified that the ordering logic is correct.  Write accesses within the same thread/transaction are also expected, otherwise FOR UPDATE would not be needed.  Write accesses from other threads (different transactions) are also possible, otherwise how could there be deadlock?\r\n\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"created":"2013-01-07T09:56:45.084+0000","updated":"2013-01-07T09:56:45.084+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13551140","id":"13551140","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I ran the repro with derby.language.logStatementText=true to see which statements the transactions involved in the deadlock executed. The first deadlock reported involved four transactions. Each transaction executed the following three statements:\r\n\r\nSELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\nINSERT INTO jobqueue (docpriority,id,priorityset,docid,status,dochash,checktime,checkaction,jobid) VALUES (?,?,?,?,?,?,?,?,?)\r\nSELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n\r\nThe first two statements were executed with the same dochash (presumably the application first checks whether the row exists, and inserts a new row if it doesn't exist). The third statement used a different dochash and got stuck waiting for a lock.\r\n\r\nAll four transactions used different dochash values, so one wouldn't normally expect lock conflicts between them.\r\n\r\nI'm wondering, though, if the lock conflicts are caused by the use of serializable transactions. Derby supports the serializable isolation level by taking previous key locks. That is, when it reads a row using via an index, it locks not only that row, but also the row right before it in the index. Combined with some logic in the insert code, which refuses to insert a new row into an index if the position right before it is locked, the previous key lock prevents the so-called phantom reads that are not allowed in serializable transactions.\r\n\r\nSo even though the transactions access completely different sets of rows, they may end up locking some of the same rows if the isolation level is serializable and the accessed rows live near each other in the index.\r\n\r\nAt least that's a theory. I'll have to trace the locking too in order to find out if that could explain the deadlocks, or if there's something else going on.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-01-11T14:45:01.979+0000","updated":"2013-01-11T14:45:01.979+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13551156","id":"13551156","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I've linked this issue to DERBY-3155 (MERGE statement), as that feature might avoid concurrency problems like the ones seen in this issue. If MERGE gets added to Derby, the SELECT+INSERT could be done in a single operation, and serializable isolation level wouldn't be needed to protect against phantom rows between the two operations.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-01-11T15:04:55.756+0000","updated":"2013-01-11T15:04:55.756+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13551172","id":"13551172","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"If it's previous key locking, does the deadlock go away if you change the program to issue\r\n\r\n    SET ISOLATION READ COMMITTED\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2013-01-11T15:27:15.133+0000","updated":"2013-01-11T15:27:15.133+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13551206","id":"13551206","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"body":"I changed that particular transaction to use READ COMMITTED, but it still deadlocks as before.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"created":"2013-01-11T15:54:46.039+0000","updated":"2013-01-11T15:54:46.039+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13551380","id":"13551380","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"just for understanding the issue it may help to try with all transactions read committed.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-01-11T18:45:32.452+0000","updated":"2013-01-11T18:45:32.452+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13551384","id":"13551384","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"Can we get a complete lock list dump when the transaction deadlocks?  Might point to anything wierd happening if the system has more locks than we expect.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-01-11T18:47:54.775+0000","updated":"2013-01-11T18:47:54.775+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13551418","id":"13551418","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"All the deadlocks I have seen listed are happening on  page 1.  Is the dataset particularly small?  If so I often worry about the optimizer deciding not to use the index in some cases as it figures out it can get all the rows by just reading a page of the base table.  I think we have checked query plans, but sometimes they change with execution, especially now with automatic \r\nstatistics gathering.  It is usually not a problem with real world data sets of more than a page, but often shows up in test cases where the data set has been made minimal.  \r\n\r\nA quick scan of the deadlocks posted seem to all be 2 rows that are one after the other in the base table.  Need to look at the data set to understand if this relates to the rows being\r\none after the other in the index (ie. are the rows inserted in index order?).  If so, then previous key locking is likely involved.  \r\n\r\nTo debug one could see if the deadlocks still appear if we enable the trace that prints all query plans to the log on execution.  Or if there are not too many queries could use hints to force the use of the index ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-01-11T19:14:09.272+0000","updated":"2013-01-11T19:14:43.793+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13551423","id":"13551423","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"body":"The dataset is extremely small - 100 rows.  As such I doubt very much that indexes are being used, even though they are present.  Hard to see why this would impact locking.  But previous-key locking could certainly be involved.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"created":"2013-01-11T19:18:35.160+0000","updated":"2013-01-11T19:19:49.316+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13551426","id":"13551426","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"body":"How can I get a lock list dump via jdbc?\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"created":"2013-01-11T19:20:48.762+0000","updated":"2013-01-11T19:20:48.762+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13551716","id":"13551716","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"the following links describe a diagnostic table that you can do a select from.  it will work to code this select in jdbc.\r\n\r\nhttp://wiki.apache.org/db-derby/LockDebugging\r\nhttp://db.apache.org/derby/docs/10.8/devguide/cdevconcepts50894.html\r\n\r\nI think there use to be a flag to get the system to dump the whole lock table when we got a deadlock, but I can't find it.\r\nFor debugging you might just set timeout shorter than deadlock and with the derby.locks.deadlockTrace prop set you\r\nshould see all locks present when the timeout happened (which in your case should be a deadlock that just has not\r\nbeen checked for yet).","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-01-12T01:01:42.683+0000","updated":"2013-01-12T01:01:42.683+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13551718","id":"13551718","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"the reason indexes matter with locking is that in serializable mode if you use an index you will only lock rows that are in the range of the query.  But if you don't use an\r\nindex then every row in the table will be locked.  A lot of work has been done to make the optimizer to choose to use indexes in this case, but there may be problems.  The reason for \r\nall the locks is that there is no way to prevent phantoms if you are just doing a scan off all rows without an index,without locking all rows.  \r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-01-12T01:08:11.076+0000","updated":"2013-01-12T01:08:11.076+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13552583","id":"13552583","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"The queries do use an index. Unfortunately, they use the foreign key index on the JOBID column rather than the unique index on (DOCHASH,JOBID). This means\r\n\r\n    SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE\r\n\r\nwill have to go through all the rows with the same JOBID as the row it is looking for. If it had used the unique index on (DOCHASH,JOBID), it would only need to fetch a single row from the index.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-01-14T11:12:06.434+0000","updated":"2013-01-14T11:12:06.434+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13552636","id":"13552636","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"If I add an optimizer override to force the query to use the index on (DOCHASH,JOBID), the deadlock goes away. See the attached force-specific-index.diff.\r\n\r\nHowever, in some runs, I saw another query deadlocking, although not as frequently as the original deadlock without the workaround.\r\n\r\nThis is what the new deadlock cycle looks like:\r\n\r\nLock : ROW, CARRYDOWN, (1,7)\r\n  Waiting XID : {835, X} , APP, UPDATE carrydown SET isnew=? WHERE jobid=? AND parentidhash=? AND isnew IN (?,?)\r\n  Granted XID : {821, X} \r\nLock : ROW, CARRYDOWN, (1,8)\r\n  Waiting XID : {821, X} , APP, UPDATE carrydown SET isnew=? WHERE jobid=? AND parentidhash=? AND isnew IN (?,?)\r\n  Granted XID : {819, X} \r\nLock : ROW, CARRYDOWN, (1,7)\r\n  Waiting XID : {819, X} , APP, UPDATE carrydown SET isnew=? WHERE jobid=? AND parentidhash=? AND isnew IN (?,?)","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-01-14T13:02:50.204+0000","updated":"2013-01-14T13:02:50.204+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13552638","id":"13552638","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"body":"Worst comes to worst, ManifoldCF can force particular index usage for certain queries, but this is obviously not ideal.  Is there any chance Derby can choose to optimize a unique index over a non-unique one, if there is a choice?  That would seem to be a valid optimization, no?\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"created":"2013-01-14T13:10:09.925+0000","updated":"2013-01-14T13:10:09.925+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13552645","id":"13552645","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"body":"Indexes on the carrydown table are as follows:\r\n\r\n      IndexDescription uniqueIndex = new IndexDescription(true,new String[]{jobIDField,parentIDHashField,childIDHashField,dataNameField,dataValueHashField});\r\n      IndexDescription jobChildDataIndex = new IndexDescription(false,new String[]{jobIDField,childIDHashField,dataNameField});\r\n      IndexDescription newIndex = new IndexDescription(false,new String[]{newField});\r\n\r\nSo this would need to use the unique index but only partially, so multiple rows would be matched. \r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"created":"2013-01-14T13:14:21.921+0000","updated":"2013-01-14T13:14:21.921+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13552671","id":"13552671","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"For the jobqueue query, I agree that the optimizer should have picked the unique index automatically. For some reason, it thinks that it'll have to go through more rows if it uses the unique index. From the query plans:\r\n\r\nWhen using foreign key index on jobid:\r\n\r\n\t\toptimizer estimated row count: 0.60\r\n\t\toptimizer estimated cost: 118.95\r\n\r\nWhen using unique index on (dochash,jobid):\r\n\r\n\t\toptimizer estimated row count: 1.00\r\n\t\toptimizer estimated cost: 135.64\r\n\r\nSo something is off with the estimates, as clearly the more specific index on (dochash,jobid) would never return more rows than the index on jobid when both columns are specified in the scan.\r\n\r\nThe update statement that works on the carrydown table already seems to use the unique index.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-01-14T14:12:35.875+0000","updated":"2013-01-14T14:12:35.875+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13552834","id":"13552834","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I enabled optimizer tracing and ran the following script:\r\n\r\nconnect 'jdbc:derby:memory:db;create=true';\r\nCREATE TABLE jobs(endtime BIGINT,reseedinterval BIGINT,outputspec CLOB,errortext CLOB,starttime BIGINT,reseedtime BIGINT,status CHAR(1) NOT NULL,startmethod CHAR(1) NOT NULL,windowend BIGINT,connectionname VARCHAR(32) NOT NULL /*CONSTRAINT c1357832449702 REFERENCES repoconnections(connectionname) ON DELETE RESTRICT*/,type CHAR(1) NOT NULL,expirationtime BIGINT,docspec CLOB,id BIGINT NOT NULL CONSTRAINT c1357832449701 PRIMARY KEY,lasttime BIGINT NOT NULL,priority BIGINT NOT NULL,description VARCHAR(255) NOT NULL,outputname VARCHAR(32) NOT NULL /*CONSTRAINT c1357832449700 REFERENCES outputconnections(connectionname) ON DELETE RESTRICT*/,lastchecktime BIGINT,hopcountmode CHAR(1),intervaltime BIGINT);\r\nCREATE TABLE jobqueue(docpriority FLOAT,id BIGINT NOT NULL CONSTRAINT c1357832449692 PRIMARY KEY,priorityset BIGINT,docid CLOB NOT NULL,failcount BIGINT,status CHAR(1) NOT NULL,dochash VARCHAR(40) NOT NULL,isseed CHAR(1),checktime BIGINT,checkaction CHAR(1),jobid BIGINT NOT NULL CONSTRAINT c1357832449691 REFERENCES jobs(id) ON DELETE RESTRICT,failtime BIGINT);\r\nCREATE UNIQUE INDEX I1357832449682 ON jobqueue (dochash,jobid);\r\nprepare ps as 'SELECT id,status,checktime FROM jobqueue WHERE dochash=? AND jobid=? FOR UPDATE';\r\n\r\nThe optimizer trace for the two plans we're interested in looked like this:\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1233 name = SQL130114161941611 uuid = ce8780ad-013c-39a4-fecd-000002dacb70 indexable = true, key columns = {JOBID} for table 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1233 name = SQL130114161941611 uuid = ce8780ad-013c-39a4-fecd-000002dacb70 indexable = true, key columns = {JOBID} for table 0\r\nCost of conglomerate ConglomerateDescriptor: conglomerateNumber = 1233 name = SQL130114161941611 uuid = ce8780ad-013c-39a4-fecd-000002dacb70 indexable = true, key columns = {JOBID} scan for table number 0 is : \r\nLevel2CostEstimateImpl: at 2080388391, cost == 20.039500000000004, rowCount == 6.0, singleScanRowCount == 6.0\r\n\tNumber of extra first column predicates is : 0, extra first column selectivity is : 0.1\r\n\tNumber of extra start/stop predicates is : 0, extra start/stop selectivity is : 1.0\r\n\tNumber of start/stop statistics predicates is : 1, statistics start/stop selectivity is : 1.0\r\n\tNumber of extra qualifiers is : 0, extra qualifier selectivity is : 1.0\r\n\tNumber of extra non-qualifiers is : 1, extra non-qualifier selectivity is : 0.1\r\nCost including extra first column selectivity is : Level2CostEstimateImpl: at 2080388391, cost == 38.50750000000001, rowCount == 0.6000000000000001, singleScanRowCount == 0.6000000000000001 for table 0\r\nIndex does not cover query: cost including row fetch is: Level2CostEstimateImpl: at 2080388391, cost == 118.95070000000003, rowCount == 0.6000000000000001, singleScanRowCount == 0.6000000000000001 for table 0\r\nCost of 1.0 scans is: Level2CostEstimateImpl: at 2080388391, cost == 118.95070000000003, rowCount == 0.6000000000000001, singleScanRowCount == 0.6000000000000001 for table 0\r\nCost including extra non-qualifier start/stop selectivity is : Level2CostEstimateImpl: at 2080388391, cost == 118.95070000000003, rowCount == 0.6000000000000001, singleScanRowCount == 0.06000000000000001 for table 0\r\n\r\nConsidering conglomerate ConglomerateDescriptor: conglomerateNumber = 1249 name = I1357832449682 uuid = 4fe880b5-013c-39a4-fecd-000002dacb70 indexable = true, key columns = {DOCHASH, JOBID} for table 0\r\nEstimating cost of conglomerate: ConglomerateDescriptor: conglomerateNumber = 1249 name = I1357832449682 uuid = 4fe880b5-013c-39a4-fecd-000002dacb70 indexable = true, key columns = {DOCHASH, JOBID} for table 0\r\nGuaranteed to match a single row - cost is: 1.5715 for table 0\r\nLock mode set to MODE_RECORD because all start and stop positions are constant\r\nCost of 1.0 scans is: Level2CostEstimateImpl: at 2080388391, cost == 1.5715, rowCount == 1.0, singleScanRowCount == 1.0 for table 0\r\nIndex does not cover query - cost including base row fetch is: 134.072 for table 0\r\n\r\nIf I read this correctly, the optimizer estimates the predicate JOBID = ? to match 10% of the rows in the {JOBID} index, and the size of the index is estimated to 6 (it's actually empty), so that's where the expected 0.6 matching rows come from.\r\n\r\nWith the {DOCHASH,JOBID} index, on the other hand, it simply concludes that it's guaranteed to return one row (although, strictly speaking, it's only guaranteed to return at most one row, as it could return zero rows).\r\n\r\nSo when the estimated size of the table is very small, the optimizer thinks the non-unique index returns fewer rows than the unique index. Which is not correct.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-01-14T16:17:45.287+0000","updated":"2013-01-14T16:17:45.287+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13552932","id":"13552932","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"thanks for the analysis knut.  I agree that again there is a problem with edge case of very few rows.  The actual performance diff probably does not matter, but for locking would be\r\nnice if we could get the optimizer to pick the unique key index in this case.  It has been so long that I don't remember the change, but I believe we play with estimates to make\r\nsure that in this case the optmizer picks the index case.  I think performance wise if all the rows are on one page, it probably makes more sense to not use the index at all, but\r\nthat causes all sorts of locking problems so we try to avoid that.  So changes to costing to get system to choose unique index vs non-unique would be in keeping with current\r\ndesign.\r\n\r\nestimating one row from the unique index seems a reasonable guess for most queries, so I don't think we should change that.\r\n\r\nWhat would people think about changing the estimate on the non-unique index to always have a floor of either 1 row if that works or maybe 1.1 rows just to make it always bigger than\r\nthe unique index case if 1 does not work.  I have not worked in the optimizer code so not sure where or how easy that change would be.  Would that get the \"right\" indexes picked in\r\nboth of these cases? This seems like a pretty safe change to me, as it would only affect these edge case small number of row cases.\r\n\r\nFor those interested this problem is likely specific to queries with \"?\" parameters, as the optimization has to use guesses like \"10%\"  when it does not exact value in the case of\r\na non unique index or using part of the columns in a unique index.  With actual values Derby will use actual index to figure out better estimate.  ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-01-14T17:59:48.010+0000","updated":"2013-01-14T18:02:53.389+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13553053","id":"13553053","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Most likely using 1 as floor would be sufficient to make the optimizer pick the unique index. The optimizer trace above suggests that the lookup in the non-unique index will have a cost of 20.04, whereas the lookup in the unique index has cost 1.575. So if the two had the exact same estimated cost for the additional base table fetch, the unique index plan would be preferred. Presumably...\r\n\r\nFromBaseTable.estimateCost() already has code to handle something that sounds like a very similar case:\r\n\r\n\t\t\t\t/* oneRowResultSetForSomeConglom means there's a unique index, but certainly\r\n\t\t\t\t * not this one since we are here.  If store knows this non-unique index\r\n\t\t\t\t * won't return any row or just returns one row (eg., the predicate is a\r\n\t\t\t\t * comparison with constant or almost empty table), we do minor adjustment\r\n\t\t\t\t * on cost (affecting decision for covering index) and rc (decision for\r\n\t\t\t\t * non-covering). The purpose is favoring unique index. beetle 5006.\r\n\t\t\t\t */\r\n\t\t\t\tif (oneRowResultSetForSomeConglom && costEstimate.rowCount() <= 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tcostEstimate.setCost(costEstimate.getEstimatedCost() * 2,\r\n\t\t\t\t\t\t\t\t\t\t costEstimate.rowCount() + 2,\r\n\t\t\t\t\t\t\t\t\t\t costEstimate.singleScanRowCount() + 2);\r\n\t\t\t\t}\r\n\r\nMaybe we could change this code to add even more bias towards the unique index.\r\n\r\nAnother thing to consider, is whether the cost estimates give a realistic picture of the actual cost. I find it puzzling that the estimates for looking up the key in an index is somewhere between 1.5 and 20, whereas looking up the base row with the row location fetched from the index, adds more than 100 to the cost. I'd expect those two costs to be about the same size. And if they were, the difference in index lookup cost (1.5 vs 20) would have dominated the difference in base row lookups (1 vs 0.6). But with the current estimates, the base row lookup has more weight than the index lookup.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-01-14T19:56:57.627+0000","updated":"2013-01-14T19:56:57.627+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13553223","id":"13553223","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"The costing is based a some very simplistic tests run at store level on a machine from probably 10 years ago.  I don't know if the actual relative performance is valid anymore, but as an\r\nexplanation for what you are seeing I can give the following.  The cost comes from a couple of things, where #2 below is usually the reason why the cost of looking up base row is higher\r\nthan index:\r\n1) finding the beginning of the right row on the page (whether it is an index or a base page)\r\n2) copying the data out of store into the datastructure provided by language.\r\n\r\nFor #1 the rowlocation is not an actual offset on the page in the base table - it is the ID of the row, so in the worst case you may have to do some sort of sequencial scan of the offset table to \r\nfind the row.  There are hints and caches that try to optimize this.  In the index case there is a binary search to find the row.\r\n\r\nFor #2 at least at the time was a very dominent part of the cost, and at least for the estimate is linearly related to the length of the data being gotten.  With estimates necessary about the\r\nlength of the data based on datatype and I think the number of rows and the number of pages in the table - this estimate may be a problem again in a very short table or maybe does not handle allocated but not used pages very well.  In general index length is much shorter than data length.  I know there are problems with length cost estimates for blobs for instance.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-01-14T22:48:31.634+0000","updated":"2013-01-14T22:48:31.634+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13553741","id":"13553741","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"The code I mentioned in FromBaseTable.estimateCost() does not come into play here because it is only used if the row count of the non-unique index is <= 1. In this query, the estimated row count is 6 (because the 10% selectivity of the predicate hasn't been applied yet).\r\n\r\nSince we know at this point that there is a unique index, and that we have equality predicates for each column in the key, we also know that the unique index is guaranteed to return at most one row. So do we really need to check if the row count of the non-unique index is <= 1 to determine that it's reasonable to favor the unique index? The more rows we expect from the non-unique index, the more likely it is that the unique index is a better choice, I would think.\r\n\r\nI tried to change\r\n    if (oneRowResultSetForSomeConglom && costEstimate.rowCount() <= 1)\r\nto\r\n    if (oneRowResultSetForSomeConglom && costEstimate.rowCount() <= 10)\r\nor just\r\n    if (oneRowResultSetForSomeConglom)\r\n\r\nBoth of the alternatives made the test pick the unique index, and the deadlocks on the jobqueue table went away.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-01-15T12:44:48.316+0000","updated":"2013-01-15T12:44:48.316+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13554954","id":"13554954","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"In case someone wonders why the estimated row count is 6 for the empty index, that's because\r\n\r\n1) OpenBTree.getEstimatedRowCount() adjusts the row count for empty indexes from 0 to 1, with the following rationale:\r\n\r\n        // Don't return 0 rows (return 1 instead), as this often leads the \r\n        // optimizer to produce plans which don't use indexes because of the 0 \r\n        // row edge case.\r\n        //\r\n        // Eventually the plan is recompiled when rows are added, but we\r\n        // have seen multiple customer cases of deadlocks and timeouts \r\n        // because of these 0 row based plans.  \r\n\r\n2) FromBaseTable.estimateCost() adds 5 to the row count with this comment:\r\n\r\n\t\t\t/* we prefer index than table scan for concurrency reason, by a small\r\n\t\t\t * adjustment on estimated row count.  This affects optimizer's decision\r\n\t\t\t * especially when few rows are in table. beetle 5006. This makes sense\r\n\t\t\t * since the plan may stay long before we actually check and invalidate it.\r\n\t\t\t * And new rows may be inserted before we check and invalidate the plan.\r\n\t\t\t * Here we only prefer index that has start/stop key from predicates. Non-\r\n\t\t\t * constant start/stop key case is taken care of by selectivity later.\r\n\t\t\t */\r\n\r\nIf we'd skipped (2), the estimated row count would stayed at 1, and the aforementioned adjustment of the cost in FromBaseTable to prefer unique indexes would have been applied. So even though the two adjustments in FromBaseTable have the same goal, they end up canceling each other.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-01-16T11:37:10.419+0000","updated":"2013-01-16T11:37:10.419+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13555252","id":"13555252","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Attached is a patch that makes FromBaseTable.estimateCost() adjust the estimated cost of the non-unique index scan to make it more likely that the unique index scan will be picked, if we know that a unique index could be used and that we have equality predicates for all columns in the key.\r\n\r\nWithout the patch, we only did this if the non-unique index was expected to return 0 or 1 row. If the non-unique index returns more than 1 row, it should make even more sense to pick the unique index, so it sounds safe to do this unconditionally when we know definitely that the unique index doesn't return more than one row.\r\n\r\nThere's no test case in the patch, but if it sounds like an OK fix, we could add a test case that uses the script from my 14/Jan/13 17:17 comment, and check that the query plan uses the unique index.\r\n\r\nRegression tests ran cleanly with the patch. Also, the ManifoldCF test passes most times, but occasionally fails with a deadlock on another table. That's probably a different problem, though.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-01-16T17:47:09.310+0000","updated":"2013-01-16T17:47:09.310+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13555857","id":"13555857","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"body":"I don't know this code, but reading your comments and looking at code and patch, the explanation and patch seem reasonable to me.\r\n\r\nI think adding a regression tests as you suggest is a good idea, for optimizer changes it would be especially good to have more regression tests since change in one location can easily have impact elsewhere due to the nature of the problem. \r\n\r\nIt seems that this change wouldn't be harmful in a join context though, if anything it would inform the optimizer better on the branch cost.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"created":"2013-01-17T04:55:37.571+0000","updated":"2013-01-17T04:55:37.571+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13556263","id":"13556263","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"I have no objections to the proposed patch. Favoring a unique index over a non-unique\r\nindex seems like a good general principle.\r\n\r\nAre there complexities when the indexes are compound (multi-column), and contain\r\ndifferent sets of columns, and the WHERE clause specifies criteria that don't mention\r\nthe entire set of columns of any index?\r\n\r\nFor example, if there was a unique index on columns (A, B, C), and a non-unique\r\nindex on columns (B, E), and the query specifies B=7 and C=9, is it obvious that\r\nwe should then favor the unique index?\r\n\r\nIn the past, when confronted with tables that had unexpected concurrency hotspots\r\nbecause they were very small, I have used the technique (in my application) of adding\r\nlarge dummy data columns at the end of the rows, thus artificially bloating up my\r\ndata so that rows are pushed to separate pages and the optimizer is less likely to\r\nprefer scans and more likely to favor indexes.\r\n\r\nWould that application technique be beneficial here?\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2013-01-17T15:17:27.840+0000","updated":"2013-01-17T15:17:27.840+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13556270","id":"13556270","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"body":"@Bryan: The application technique is not very helpful, since ManifoldCF runs on a number of databases and we really would not want to encumber the use of other databases in order to support Derby.\r\n\r\nSecond, the ability to use an index does not work as you specify for most databases.  If an index is on (A, B, C), you can often use the index if there is a WHERE using A and B, but you can't usually use that index if the WHERE is on any columns that don't include A.  So your hypothetical situation is not valid.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"created":"2013-01-17T15:27:14.192+0000","updated":"2013-01-17T15:27:14.192+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13556601","id":"13556601","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Hi Knut, thanks for the patch. I am looking at the issue to see what existing query plans will change because of the patch. \r\n\r\nIs it correct that all the queries which are *completly* covered by an unique index will now choose that unique index? Without the patch, *only* queries with very limited data in the table would have picked a non-unique index rather than unique index? I guess what would help is little blurb about what kind of queries will be impacted by this change. Thanks for your work.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-01-17T21:14:23.303+0000","updated":"2013-01-17T21:14:23.303+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13557133","id":"13557133","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Thanks for the feedback, Dag, Bryan and Mamta.\r\n\r\n> For example, if there was a unique index on columns (A, B, C), and a non-unique\r\n> index on columns (B, E), and the query specifies B=7 and C=9, is it obvious that\r\n> we should then favor the unique index?\r\n\r\nIn that example, this particular adjustment of the cost is not performed. It is\r\ncurrently done only if\r\n\r\n1) There is a unique index on the table, and\r\n\r\n2) The query contains equality predicates for all columns in the unique index, and\r\n\r\n3) Estimated row count of the access path that's being explored (not the unique\r\nindex) has expected row count less than or equal to 1 before selectivity is\r\napplied\r\n\r\nThe example query does not satisfy requirement (2), as it doesn't have an\r\nequality predicate for column A. The patch only removes requirement (3), so it\r\nshouldn't have any effect on such a query.\r\n\r\n> In the past, when confronted with tables that had unexpected concurrency hotspots\r\n> because they were very small, I have used the technique (in my application) of adding\r\n> large dummy data columns at the end of the rows, thus artificially bloating up my\r\n> data so that rows are pushed to separate pages and the optimizer is less likely to\r\n> prefer scans and more likely to favor indexes.\r\n>\r\n> Would that application technique be beneficial here?\r\n\r\nIf the JOBQUEUE table has three or more rows at the time the query is compiled,\r\nthe unique index is chosen, so the problem can be worked around that way if the\r\napplication logic accepts it. It also looks like turning off cost-based\r\noptimization (by setting the derby.optimizer.ruleBasedOptimization property to\r\ntrue) makes it pick the unique index. But that may have other unwanted effects,\r\nand I don't think the rule-based optimizer is a documented feature.\r\n\r\n> Is it correct that all the queries which are *completly* covered by an unique\r\n> index will now choose that unique index?\r\n\r\nThis particular optimization does not take into consideration whether or not\r\nthe index is covering. The unique index in the ManifoldCF test case is in fact\r\nnot a covering index.\r\n\r\nI don't believe the patch will make all queries will pick a unique covering\r\nindex if one is available, for two reasons:\r\n\r\n1) The optimization is only applied if there are equality predicates for all\r\nindex columns, so the patch won't make a multi-row scan on a unique index any\r\nmore likely than it currently is.\r\n\r\n2) It's just an adjustment of the cost, not a guarantee that the unique index\r\nwill be picked. There could still be other factors that make the overall\r\nestimated cost for the unique index higher than some other alternative.\r\n\r\n> Without the patch, *only* queries with very limited data in the table would\r\n> have picked a non-unique index rather than unique index?\r\n\r\nYes, that's right. The intention of the current code seems to be that those\r\nqueries should have been using the unique index too. Unfortunately, another\r\noptimizer tweak (see my comment from 16/Jan/13 12:37) makes the table appear\r\nnot so empty, and the cost adjustment in favor of the unique index is not\r\napplied.\r\n\r\n> I guess what would help is little blurb about what kind of queries will be\r\n> impacted by this change.\r\n\r\nI'll see if I can come up with some kind of systematic description of the\r\nchanges we should expect.\r\n\r\nThanks.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-01-18T10:57:33.884+0000","updated":"2013-01-18T10:57:33.884+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13557374","id":"13557374","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"When we add regression tests for this jira, I think it will be good to add a regression test in upgrade suite as well showing that prior releases would pick non-unique index for the given dataset but trunk will pick unique index instead. Thanks.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-01-18T17:31:06.616+0000","updated":"2013-01-18T17:31:06.616+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13557452","id":"13557452","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"Thanks Knut, your following comments make it most clear for me.  I have a hard time reading the optimizer code and getting\r\nthat info.  Maybe you could beef up the comments in this area with your clear explanation of the code path.  \r\n\r\nIt seems clear to me that given the following that the change is a good one, is essence improving the estimate guess in the\r\nnon-unique index by taking advantage of knowledge about the unique index on the same columns.\r\n\r\nIn that example, this particular adjustment of the cost is not performed. It is\r\ncurrently done only if\r\n\r\n1) There is a unique index on the table, and\r\n\r\n2) The query contains equality predicates for all columns in the unique index, and\r\n\r\n3) Estimated row count of the access path that's being explored (not the unique\r\nindex) has expected row count less than or equal to 1 before selectivity is\r\napplied","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-01-18T18:32:37.866+0000","updated":"2013-01-18T18:32:37.866+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13557498","id":"13557498","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Knut, please correct me if my following understanding of this jira is wrong. I am also looking forward to your \"some kind of systematic description of the changes we should expect.\"\r\n\r\nThe proposed fix adjusts the estimated cost for the query plan such that unique index will be favored over non-unique index if there is equality predicate for all the index columns of the unique index. In a table with enough data, even without the proposed changes, the unique index would have weighted higher automatically because of the number of rows in the table but for edge case with very few rows, non-unique index will appear better without the proposed change. Also, if I understand the change correctly, this change will in theory impact only edge case queries where the table in question has only couple rows. The behavior of all the other queries will remain unchanged.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-01-18T19:15:07.277+0000","updated":"2013-01-18T19:15:07.277+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13558697","id":"13558697","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Thanks, Mike and Mamta. Mike's description of the problem and Mamta's description of fix agree with my understanding this code.\r\n\r\nThe set of queries that will use this particular optimizer tweak after the suggested fix (set A), are those that access a table that has a unique index, and that have equality predicates for all the columns in that index. All plans which do not use such an index to access that table, will get their cost adjusted (scan cost is multiplied by 2, scan row count before selectivity adjustment is incremented by 2).\r\n\r\nThe set of queries that will see changes in cost estimates for some plans because of the suggested fix (set B), is the subset of A where the optimizer believes one or more of the scan alternatives will have to read more than one row. This includes these two categories:\r\n\r\n  i) Queries where the row count statistics actually do indicate that multiple rows will have to be read. That is, the table contains multiple rows.\r\n\r\n  ii) Queries where the fix for beetle 5006 makes an empty or almost empty table appear not so empty. That is, if the alternatives include index scans with no constant start or stop keys, or full table scans. (Note: parameters are not considered constant start or stop keys, so \"our\" query falls into this category.)\r\n\r\nThe set of queries that will see that a different plan being picked after the fix (set C), is the subset of B where all of the following conditions apply:\r\n\r\n  i) The unique index is not covering, so that an index-to-base-row result set will be needed.\r\n\r\n  ii) One of the alternative scans is expected to return < 1 row (after selectivity has been applied).\r\n\r\n  iii) The estimated cost of reading a row from the base table is so high that the difference between reading less than 1 row and reading exactly 1 row, is greater than the difference in cost between the unique index lookup and the alternative scan.\r\n\r\nSet C should be a lot smaller than set B, as most queries are against non-empty tables. Those queries should already be using the unique index because the optimizer understands that the non-unique alternatives will have to fetch at least as many rows from the base table. The costs of the plans using non-unique scans are still adjusted, but they're already believed to be more expensive, so it doesn't change the outcome.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-01-21T11:20:32.614+0000","updated":"2013-01-21T11:20:32.614+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13558788","id":"13558788","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"The suggested fix only works if the cost we add to the non-unique index scan is sufficiently big to out-weigh the difference in cost for fetching the base row.\r\n\r\nThe fix is sufficient in the original query, as the difference in base row cost isn't  0.6 base row retrievals (non-unique index) vs 1 base row (unique index).\r\n\r\nIt does not seem to be sufficient for this similar query, though:\r\n\r\ncreate table t1(c1 int not null, c2 int not null, c3 int not null, c4 int not null, c5 blob);\r\ncreate index idx3 on t1(c1, c2, c3);\r\ncreate unique index uidx4 on t1(c1, c2, c3, c4);\r\n\r\nprepare ps as 'select * from t1 where c1 = ? and c2 = ? and c3 = ? and c4 = ?';\r\nexecute ps using 'values (1,2,3,4)';\r\n\r\nHere, we'd want the SELECT statement to use the unique index UIDX4, but the optimizer picks the non-unique index IDX3. The unique index is better because it reads fewer rows from the index (or at least no more rows than the non-unique index), fewer rows from the base table.\r\n\r\nThe reason why it ends up using the non-unique index, is that the higher number of predicates in this query makes the selectivity very low, so the estimated number of rows returned by the non-unique index is 0.01. That means the estimated cost of the base row fetch operation is 100 times higher for the unique index, where the estimated row count is 1.\r\n\r\nFor this query, Mike's suggestion of using a floor of 1.0 for the row count would probably work better. That should also help the query we looked at originally. I'll investigate and see if that's a viable alternative.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-01-21T14:21:18.350+0000","updated":"2013-01-21T14:21:18.350+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13559649","id":"13559649","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Attaching prefer-unique-index-v2.diff which implements the alternative proposal. The patch also adds a new test that verifies that the unique index is used.\r\n\r\nThe patch adjusts the cost estimate only if all of the following conditions hold:\r\n\r\n1) There is a unique index (A) on the table\r\n\r\n2) The query has equality predicates for all the columns in the unique index A\r\n\r\n3) There is another index (B) that is either non-unique or unique without satisfying 2.\r\n\r\n4) Index B is non-covering\r\n\r\n5) The expected row count when using index B is less than 1\r\n\r\nIf all of the above conditions hold, the row count for index B is changed to 1 before estimating the cost of fetching rows from the base table.\r\n\r\nAlthough using the unique index might be slightly more expensive in some cases, it is safer as it will never access more than one row, whereas the non-unique alternative could potentially access many rows.\r\n\r\nThe third, fourth and fifth select statements in the added test case were not affected by the v1 patch, but the v2 patch makes them all use a unique index.\r\n\r\nAll the regression tests passed with the patch.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-01-22T14:05:28.112+0000","updated":"2013-01-22T14:05:28.112+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13559926","id":"13559926","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Hi Knut, thanks for the new patch. The changes look good to me and the comments in the code is very helpful. I was wondering if it will be possible to add any regression test in upgrade suite to show how prior releases would favor non-unique index to unique index without the fix for DERBY-6011 and how trunk will use unique index instead. thanks.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-01-22T19:41:24.240+0000","updated":"2013-01-22T19:41:24.240+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13560524","id":"13560524","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Thanks, Mamta. The test case in the patch verifies that the unique index is chosen on trunk. Currently, you have to run it manually against an old version to see that it fails. It is certainly possible to make it run against old versions automatically in the upgrade tests to verify that they pick the inferior plan, but I'm not sure I see what value it adds. Do you have some specific concern that you want such a test to address? This issue doesn't involve the upgrade logic, as far as I can tell.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-01-23T09:50:36.505+0000","updated":"2013-01-23T09:50:36.505+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13560811","id":"13560811","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Hi Knut, my only reason for the upgrade suite regression test request was to show that the behavior has indeed changed from older release to 10.10","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2013-01-23T16:39:44.193+0000","updated":"2013-01-23T16:39:44.193+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13567033","id":"13567033","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"body":"What is the next potential release vehicle this patch could ship with?  It would be great if we could pick up a new version of Derby with this problem solved in time for ManifoldCF's April release.\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"created":"2013-01-30T22:55:17.898+0000","updated":"2013-01-30T22:55:17.898+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13571269","id":"13571269","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I've checked in the v2 patch on trunk, revision 1442554. I intend to backport it to the 10.9 branch if the nightly regression tests run stably with the fix.\r\n\r\nThere is a 10.9.2 maintenance release ( http://wiki.apache.org/db-derby/DerbyTenNineTwoRelease ) planned soon that could carry this fix, provided it gets backported to 10.9 before the release candidate is produced. The dates are still unclear, as there were some speed bumps in the process. It might come out in time.\r\n\r\nThere's also a 10.10.1 feature release ( http://wiki.apache.org/db-derby/DerbyTenTenOneRelease ) that has been suggested some time later this year, but since no one has signed up for managing the release and published a schedule yet, it's probably less likely to get out in time.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-02-05T12:41:54.603+0000","updated":"2013-02-05T12:41:54.603+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13574315","id":"13574315","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I've merged the fix to the 10.9 branch and committed revision 1443874.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-02-08T08:29:23.007+0000","updated":"2013-02-08T08:29:23.007+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13616959","id":"13616959","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"body":"Any chance the 10.9.2 release will take place before April 15th?  I'd like to include it in the ManifoldCF 1.2 release, if possible.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"created":"2013-03-29T01:34:45.081+0000","updated":"2013-03-29T01:34:45.081+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13632945","id":"13632945","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"is there any more work planned for this issue.  looks fixed in trunk, 10.10 and 10.9 to me, unless more fixes are planned.  \r\nKarl were you able to test your application with the change?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2013-04-16T16:03:10.171+0000","updated":"2013-04-16T16:03:10.171+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13632949","id":"13632949","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"body":"I did confirm that the fix worked for ManifoldCF.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kwright%40metacarta.com","name":"kwright@metacarta.com","emailAddress":"DaddyWri at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kwright%40metacarta.com&avatarId=10392","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kwright%40metacarta.com&avatarId=10392","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kwright%40metacarta.com&avatarId=10392","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kwright%40metacarta.com&avatarId=10392"},"displayName":"Karl Wright","active":true},"created":"2013-04-16T16:09:47.980+0000","updated":"2013-04-16T16:09:47.980+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13637816","id":"13637816","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Thanks for verifying the fix, Karl. I'm closing this issue, then. The fix is included in Derby 10.10.1.1, which was released last week.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-04-22T07:47:10.510+0000","updated":"2013-04-22T07:47:10.510+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13704833","id":"13704833","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"assign to myself temporarily for backport.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2013-07-10T17:57:26.306+0000","updated":"2013-07-10T17:57:26.306+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13705201","id":"13705201","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jira-bot","name":"jira-bot","emailAddress":"no-reply at urd dot zones dot apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF subversion and git services","active":true},"body":"Commit 1502044 from [~kmarsden]\r\n[ https://svn.apache.org/r1502044 ]\r\n\r\nDERBY-6011 Derby performs very badly (seems to deadlock and timeout) in very simple multi-threaded tests \r\n\r\nContributed by Knut Anders Hatlen\r\nMerge revision  1442554 from trunk to 10.8","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jira-bot","name":"jira-bot","emailAddress":"no-reply at urd dot zones dot apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF subversion and git services","active":true},"created":"2013-07-10T22:56:56.813+0000","updated":"2013-07-10T22:56:56.813+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12623008/comment/13705204","id":"13705204","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Merged back to 10.8. Reassigning Knut","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2013-07-10T22:58:14.380+0000","updated":"2013-07-10T22:58:14.380+0000"}]},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-6011/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i14aiv:"}}