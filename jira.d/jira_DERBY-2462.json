{"expand":"renderedFields,names,schema,transitions,operations,editmeta,changelog","id":"12365142","self":"https://issues.apache.org/jira/rest/api/latest/issue/12365142","key":"DERBY-2462","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/10594","id":"10594","key":"DERBY","name":"Derby","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=10594&avatarId=10122","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=10594&avatarId=10122","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=10594&avatarId=10122","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=10594&avatarId=10122"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10090","id":"10090","description":"DB related projects","name":"DB"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12312590","id":"12312590","description":"","name":"10.3.1.4","archived":false,"released":true,"releaseDate":"2007-08-10"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12310220":"2007-03-16 22:53:42.321","customfield_12312322":null,"customfield_12312323":null,"customfield_12310420":"23063","customfield_12310222":"1_*:*_1_*:*_5248144310_*|*_6_*:*_1_*:*_0_*|*_5_*:*_1_*:*_15905140699","customfield_12312320":null,"customfield_12312321":null,"customfield_12312120":null,"customfield_12312121":null,"resolutiondate":"2007-05-16T13:11:29.241+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312326":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312324":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-2462/watchers","watchCount":1,"isWatching":false},"created":"2007-03-16T19:22:24.931+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12312334":null,"customfield_12310310":"9.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/10993","id":"10993","description":"","name":"10.1.1.0","archived":false,"released":true,"releaseDate":"2005-08-03"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12310615","id":"12310615","description":"","name":"10.1.2.1","archived":false,"released":true,"releaseDate":"2005-11-18"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12311953","id":"12311953","description":"","name":"10.1.3.1","archived":false,"released":true,"releaseDate":"2006-06-30"},{"self":"https://issues.apache.org/jira/rest/api/2/version/11187","id":"11187","description":"","name":"10.2.1.6","archived":false,"released":true,"releaseDate":"2006-10-02"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12312027","id":"12312027","description":"","name":"10.2.2.0","archived":false,"released":true,"releaseDate":"2006-12-19"}],"customfield_12311120":null,"customfield_12312330":null,"issuelinks":[],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"customfield_12312337":null,"customfield_12312338":null,"updated":"2007-11-16T15:17:09.935+0000","customfield_12312335":null,"customfield_12311720":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/11412","id":"11412","name":"Store"}],"timeoriginalestimate":null,"description":"After an unrelated statement on the same connection commits, and after some number of successful calls to ResultSet.next(), a subsequent call to ResultSet.next() throws an SQLException with a message like: The heap container with container id Container(-1, 1173965368428) is closed.  This seems to be related to the hard-coded passing of false to the super in the constructor of org.apache.derby.impl.store.access.BackingStoreHashTableFromScan.\n\nSteps to reproduce:\n\n1. Execute a statement on a connection that returns a result set.\n\n2. Execute a second statement on the same connection that modifies the database and commits.\n\n3. Call next() on the first result set until the exception is thrown.\n\nNote that the number of rows that can be successfully retrieved from the result set seems to be related to the amount of data per row.  Increasing the number of columns in the result set or the length of the columns causes the exception to be taken sooner.\n\nThe attached test program demonstrates the issue.\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12310200":null,"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"aggregatetimeestimate":null,"customfield_12312022":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12310921":null,"customfield_12310920":"39764","summary":"org.apache.derby.impl.store.access.BackingStoreHashTableFromScan does not honor ResultSet holdability","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=clary2137","name":"clary2137","emailAddress":"jclary at actuate dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jeff Clary","active":true},"subtasks":[],"customfield_12310090":null,"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=clary2137","name":"clary2137","emailAddress":"jclary at actuate dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jeff Clary","active":true},"customfield_12310291":null,"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"environment":"Test under Windows Vista, Java 1.4.2_13","customfield_12311020":null,"customfield_12310050":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"startAt":0,"maxResults":13,"total":13,"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12365142/comment/12481780","id":"12481780","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"body":"The spilling of the hash table to disk was added in DERBY-106 in svn\r\n157861. I checked the issue comments, the code changes and the tests,\r\nbut I did not find a clue to why false is passed (for keepAfterCommit) to super from\r\nBackingStoreHashTableFromScan.  \r\n\r\nI see the test for insensitive result sets (which also relies on\r\nspilling the hash table to disk) uses holdability=true, but the test\r\nfor join and distinct only tests the non-holdable case.\r\n\r\nSo it would seem holdability is not meant to work (or was postponed?)\r\nfor the join and distinct cases. Does anyone know the status of this? (The\r\ncontributor is not active in the community any longer).\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"created":"2007-03-16T22:53:42.321+0000","updated":"2007-03-16T22:53:42.321+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12365142/comment/12481785","id":"12481785","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"body":"Thanks for making the JIRA issue, Jeff!\r\nI upload a preliminary patch (DERBY-2462-1.*) which works for your repro\r\nprogram and which passes the regression tests (derbyall and suites.All)\r\non Solaris 10/x86, SUN JDK1.6.\r\nIt apparently fixes the hashed join case of spilling with holdability true; \r\nbut I have not  added extra tests yet. \r\n\r\nThe patch should probably not be committed until someone more familiar with\r\nthis part of the code has looked at this.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"created":"2007-03-16T23:15:30.007+0000","updated":"2007-03-16T23:15:30.007+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12365142/comment/12481794","id":"12481794","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"body":"See also discussion in thread in derby-dev:\r\nhttp://www.nabble.com/Possible-problem-in-org.apache.derby.impl.store.access.BackingStoreHashTableFromScan-tf3414777.html\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"created":"2007-03-17T00:22:54.738+0000","updated":"2007-03-17T00:22:54.738+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12365142/comment/12482304","id":"12482304","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"body":"Dag said:\r\n\r\n> I see the test for insensitive result sets (which also relies on\r\n> spilling the hash table to disk) uses holdability=true, but the test\r\n> for join and DISTINCT only tests the non-holdable case. \r\n\r\nChecking the test SpillHash.java (from DERBY-106) further, I see that\r\nnone of the cases actually do run with holdability: Apparently the\r\ncase for insensitive result sets does, but I got misled by the fact\r\nthat the test relies on the metadata method\r\nsupportsOpenCursorsAcrossCommit() which always returns false for\r\nDerby, as it turns out, since we do not support holdability for XA. So\r\nthe test chooses to run without holdability.\r\n\r\nWhen enabling holdability in the test cases in SpillHash.java, I see\r\nthe following:\r\n \r\n - hash join fails with the same error as reported in this issue, \r\n - scroll insensitive result sets work (to be expected, has other\r\n   tests).\r\n - DISTINCT fails with an exception NoSuchElementException in \r\n   DiskHashTable#nextElement.\r\n\r\nMy first patch fixes the hash join case, but not the DISTINCT case,\r\nbecause this accesses the spilled rows in the hash tabledifferently;\r\nit uses a heap scan which fails (the hash join case accesses the\r\nspiiled rows via a btree lookup of the hash key) since the scan is\r\nclosed due to the commit, and not reopened. I am working on a patch\r\nwhich fixes this as well.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"created":"2007-03-20T03:51:45.492+0000","updated":"2007-03-20T03:51:45.492+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12365142/comment/12482990","id":"12482990","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"body":"This patch, DERBY-2462-2.{stat,diff} supercedes DERBY-2462-1.  It does\r\nthe following:\r\n\r\n   - modifies the test lang/SpillHash.java to run the test cases both\r\n     with and without holdability set for the three tests of the disk\r\n     spill of the backing store hash table:\r\n\r\n        * hash join result set \r\n        * distinct result set\r\n        * scollable insensitive result set\r\n\r\n     The changed test will reveal the same problem as the repro\r\n     provided for this issue (if applied before the rest of this\r\n     patch), as well as a failure of the distinct result set test case. \r\n\r\n   - modifies BackingStoreHashTableFromScan to use the holdable\r\n     mode of the disk hash table if applicable to the query.\r\n     This change was encessary to make the hash join test case\r\n     of SpillHash.java work with holdability.\r\n   \r\n   - modifies DiskHashtable.java to enable its enumerator class\r\n     ElementEnum to survives a commit. It uses a scan of the row\r\n     conglomerate (heap). Under holdability, the scan gets closed at\r\n     commit time, and ElementEnum#nextElement would fail. The patch\r\n     reopens the scan if appropriate (under holdability).  In addition\r\n     to the change in BackingStoreHashTableFromScan, this change was\r\n     necessary to make the distinct test case of SpillHash.java work\r\n     with holdability.\r\n\r\n     I would especially appreciate if someone familiar with this area\r\n     of the code could take a look at this part of the patch; the\r\n     method I use for salvaging the scan is to save the row location\r\n     after each nextElement, and use that to reopen the scan at the\r\n     right position after a commit. I did not find a way to check\r\n     if the scan was closed before attempting a fetch; I just catch\r\n     the exception and check for SQLState.AM_SCAN_NOT_POSITIONED, in\r\n     which I reopen the scan (only under holdability). I seems a bit of a\r\n     hack; there may be a better way.\r\n\r\nThe patch fixes the repro, I ran derbyall and suites.All with no\r\nerrors on JDK1.6 under Solaris 10/x86. It is ready for review.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"created":"2007-03-22T02:21:56.322+0000","updated":"2007-03-22T02:21:56.322+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12365142/comment/12490462","id":"12490462","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"I am not familiar with this area of code so I cannot make any definitive comments on whether or not the changes are correct nor on if there may be a better way.  I did look at the patch, though, and had the following two questions.  These are both minor and somewhat theoretical, so I don't think either should block commit of the patch.  Just my proverbial two cents...\r\n\r\n1) The interaction of the various ScanController interfaces and implementations has me completely confused (which has nothing to do with your changes) but I did notice one interface called ScanManager, which extends ScanController, that defines a \"closeForEndTransaction(boolean)\" method:\r\n\r\n  http://db.apache.org/derby/javadoc/engine/org/apache/derby/iapi/store/access/conglomerate/ScanManager.html\r\n\r\nI also noticed that most of the Scan implementations apparently implement the ScanManager class.  At least, that's what I gather from the above javadoc page; I tried to verify that by looking at the actual code but got lost in no time.  In any event, I was wondering if that method could somehow be used to indicate that a ScanController has been closed as the result of a commit.  Then instead of catching an exception in DiskHashtable, you could try something like:\r\n\r\n     try\r\n     {\r\n        // DERBY-2462: if holdable and scan got closed due\r\n        // to commit, we need to reopen where we left off\r\n        if (scan.closedByCommit() && keepAfterCommit)\r\n        {\r\n            scan = openRowConglomerate(tc, rowConglomerateId);\r\n            scan.positionAtRowLocation(rowloc);\r\n        }\r\n        scan.fetch(row);\r\n        \r\nwhere \"scan.closedByCommit()\" would return true if the scan was closed by a ScanManager.closeForEndTransaction() call.\r\n\r\nAs I said, that's just a theoretical.  I don't know if it's actually possible to get something like that working, but since I noticed the method I thought I'd ask.\r\n\r\nIf that type of check is not possible then it seems like we should at least be able to add an \"isClosed()\" or \"isPositioned()\" method to the ScanController that could be used instead of catching the exception.  Is there something in particular that would make such an aproach infeasible?\r\n\r\n2) The patch includes the following diff in DiskHashtable:\r\n\r\n +    // DERBY-2462: if holdable and scan got closed due\r\n +    // to commit, we need to reopen where we left off\r\n +    if (keepAfterCommit && (SQLState.AM_SCAN_NOT_POSITIONED.\r\n +            substring(0,5).\r\n +            equals(e.getSQLState()))) {\r\n +        scan = openRowConglomerate(tc, rowConglomerateId);\r\n +        scan.positionAtRowLocation(rowloc);\r\n\r\nIt looks like we first make a call to reopen the scan, then we call \"positionAtRowLocation()\".  But the javadoc for the latter method (see ScanController.java) seems to indicate that the reopen happens automatically:\r\n\r\n    /**\r\n     * Positions the scan at row location and locks the row. \r\n     * If the scan is not opened, it will be reopened if this is a holdable \r\n     * scan and there has not been any operations which causes RowLocations \r\n     * to be invalidated.\r\n\r\nIs this javadoc correct?  If so, then is it necessary to explicitly call \"openRowConglomerate()\" in the above diff, or could we get by without it?\r\n\r\nAlso, the javadoc mentions that \"positionAtRowLocation()\" locks the row.  The javadoc for ScanController.fetch() doesn't mention anything about locking the row, but I'm assuming it happens anyway...is that correct? (excuse my ignorance here). Can you confirm that row locking occurs as expected with these changes?  I have no reason to believe otherwise, just thought I'd ask.\r\n\r\nIt's worth repeating here that I am not familiar with this area of code and thus this feedback could be of little-to-no-value, so please keep that in mind.  If any committer out there (including you) wishes to commit these changes as they are, I would not complain.\r\n\r\nOn a more concrete level, I verified that the new lang/SpillHash.java test runs cleanly with your changes and fails with error XSCH6 without them, as expected.  So thanks for fixing that test up.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2007-04-20T22:05:05.950+0000","updated":"2007-04-20T22:05:05.950+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12365142/comment/12491073","id":"12491073","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"body":"Thanks for the review, Army! \r\n\r\nI attach a new version of the patch, DERBY-2462-3.* which supercedes\r\nearlier versions. I address your comments explicitly below. Relative\r\nto the previous version (*-2.diff), this patch:\r\n\r\n1) opens the heap scan in DiskHashtable#ElementEnum's constructor with\r\n   hold=true if we have holdability. Required for item 3) below to\r\n   work.\r\n\r\n2) avoids having to catch the not positioned exception in\r\n   DiskHashtable#nextElement, when the scan has been closed, by using\r\n   the new method ScanController#isPositioned.\r\n\r\n3) removes the call to openRowConglomerate, now relying on\r\n   positionAtRowLocation to do the reopening when required under\r\n   holdability. \r\n\r\n4) checks the result of positionAtRowLocation to verify that it\r\n   worked, else throw an exception \"24000\" NO_CURRENT_ROW. It can fail\r\n   if the row location has been invalidated by compress. Pretty\r\n   unlikely, but one never knows..\r\n\r\n5) removes the exit() calls from the SpillHash.java test to make it\r\n   runnable with -Duseprocess=false\r\n\r\n6) some small cleanup in DiskHashtable.\r\n\r\nRegression tests ran cleanly on Sun 1.4 Solaris 10/x86.\r\n\r\n\r\nAnswers to Army's review comments:\r\n\r\n> 1) The interaction of the various ScanController interfaces and\r\n> implementations has me completely confused (which has nothing to do\r\n\r\nyou are not alone... ;)\r\n\r\n> If that type of check is not possible then it seems like we should\r\n> at least be able to add an \"isClosed()\" or \"isPositioned()\" method\r\n> to the ScanController that could be used instead of catching the\r\n> exception. Is there something in particular that would make such an\r\n> aproach infeasible?\r\n\r\nYes, I thought of something like this too. I finally added a method\r\nScanController#isPositioned, and implemented it for heap and btree\r\nscans (only used by the former, though).\r\n\r\n> It looks like we first make a call to reopen the scan, then we call\r\n> \"positionAtRowLocation()\". But the javadoc for the latter method\r\n> (see ScanController.java) seems to indicate that the reopen happens\r\n> automatically:\r\n> \r\n>     /**\r\n>      * Positions the scan at row location and locks the row.\r\n>      * If the scan is not opened, it will be reopened if this is a holdable\r\n>      * scan and there has not been any operations which causes RowLocations\r\n>      * to be invalidated.\r\n> \r\n> Is this javadoc correct? If so, then is it necessary to explicitly\r\n> call \"openRowConglomerate()\" in the above diff, or could we get by\r\n> without it?\r\n\r\nYes, no and yes. Much cleaner, thanks. See item 1) and 3) above.\r\n\r\n> Also, the javadoc mentions that \"positionAtRowLocation()\" locks the\r\n> row. The javadoc for ScanController.fetch() doesn't mention anything\r\n> about locking the row, but I'm assuming it happens anyway...is that\r\n> correct? (excuse my ignorance here). Can you confirm that row\r\n> locking occurs as expected with these changes? I have no reason to\r\n> believe otherwise, just thought I'd ask.\r\n\r\nYes, locking is performed as a consequence of calling\r\npositionAtRowLocation, see HeapScan#positionAtRowLocation which calls\r\nreopenScanByRecordHandleAndSetLocks. \r\n\r\n> It's worth repeating here that I am not familiar with this area of\r\n> code and thus this feedback could be of little-to-no-value, so\r\n> please keep that in mind. \r\n\r\nI very much appreciate your feedback; I am also unfamiliar with this\r\narea of the code, and an extra set of eyes is always useful! The patch\r\nis cleaner now, I think. Thanks again! :)\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"created":"2007-04-23T21:30:36.631+0000","updated":"2007-04-23T21:30:36.631+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12365142/comment/12491102","id":"12491102","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"Thank you for considering my feedback, Dag.  The v3 patch is indeed cleaner now.\r\n\r\nTwo follow-up questions that occur to me:\r\n\r\n1) The new \"isPositioned()\" method checks to see if the current scan_state is \"SCAN_INPROGRESS\".  This works well enough for the case we're trying to address--i.e. the scan was closed due to a commit and is therefore no longer \"in progress\".\r\n\r\n  My question is: are there any scenarios in which we could get to the new code when the scan was closed for some reason *other* than a commit?  If this is possible, will attempting to re-open the scan in such a scenario cause problems?\r\n\r\n  I don't know enough about the lifetime of a scan to give any examples of when or if this could happen, but given the generality of the isPositioned() method I thought I'd bring it up.\r\n\r\n  I did notice that one of the possible scan states is (pulled from BTreeScan):\r\n\r\n  *     SCAN_HOLD_INPROGRESS -\r\n  *                 The scan has been opened and held open across a commit,\r\n  *                 at the last commit the state was in SCAN_INPROGRESS.\r\n  *                 The transaction which opened the scan has committed,\r\n  *                 but the scan was opened with the \"hold\" option true.\r\n  *                 At commit the locks were released and the \"current\"\r\n  *                 position is remembered.  In this state only two calls\r\n  *                 are valid, either next() or close().  When next() is\r\n  *                 called the scan is reopened, the underlying container\r\n  *                 is opened thus associating all new locks with the current\r\n  *                 transaction, and the scan continues at the \"next\" row.\r\n\r\n  To see what would happen I changed \"isPositioned()\" method to:\r\n\r\n     public boolean isPositioned() throws StandardException\r\n     {\r\n         return scan_state == SCAN_HOLD_INPROGRESS;\r\n     }\r\n\r\n  and then dropped the negation from the check in DiskHashtable:\r\n\r\n     if (keepAfterCommit && scan.isPositioned()) {\r\n         // automatically reopens scan:\r\n         if (!scan.positionAtRowLocation(rowloc)) {\r\n             // Will not happen unless compress of this table\r\n             // has invalidated the row location. Possible?\r\n             throw StandardException.\r\n                 newException(SQLState.NO_CURRENT_ROW);\r\n         }\r\n     }\r\n\r\n  I then ran lang/SpillHash.java and the test still passed. The good thing about this approach is that we will only execute the \"reopen\" logic if we know for a fact that the \"scan has been opened and held open across a commit\"--which is exactly what we want.  Also, if we rename \"isPositioned()\" to something more appropriate, the \"if\" statement in DiskHashtable becomes more intuitive:\r\n\r\n     if (scan.heldAcrossCommit()) {\r\n         // automatically reopens scan:\r\n         if (!scan.positionAtRowLocation(rowloc)) {\r\n\r\n  Note that you wouldn't need to include \"keepAfterCommit\" anymore because the scan state can only be \"HOLD_INPROGRESS\" if the scan was opened with \"hold\" set to true, which (I think?) can only happen if \"keepAfterCommit\" is true.\r\n\r\n2) I noticed that the lang/SpillHash.java test checks to make sure that the scan is still available after a commit if holdOverCommit is true.  This is good because that's the whole point of DERBY-2462.  I was wondering, though,  if it would be worth it to check that the correct *error* is thrown if a call to \"next()\" is made after a commit when holdOverCommit is *false*.  Or is that already tested somewhere else?\r\n\r\nThanks for your patience with my ramblings...","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2007-04-23T23:54:18.624+0000","updated":"2007-04-23T23:54:18.624+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12365142/comment/12491481","id":"12491481","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"body":"Thanks for your continued help with this one, Army!\r\n\r\n> 1) ...\r\n>   My question is: are there any scenarios in which we could get to\r\n> the new code when the scan was closed for some reason *other* than a\r\n> commit? If this is possible, will attempting to re-open the scan in\r\n> such a scenario cause problems?\r\n\r\nI don't believe so, but let me try an analysis:\r\n\r\nThe states of the scan (heap, I omit btree here for simplicity\r\nalthough i believe it is similar) is one of\r\n\r\n    {SCAN_INIT,\r\n     SCAN_INPROGRESS,\r\n     SCAN_DONE,\r\n     SCAN_HOLD_INIT,\r\n     SCAN_HOLD_INPROGRESS}\r\n\r\n Btw, the comment at the top of GenericScanController (used for heap\r\n scan along with subclass HeapScan) omits the *_HOLD_* states, so it\r\n is out of date..\r\n\r\n* The constructor of DiskHashTable#ElementEnum opens the scan.  This\r\n  moves the scan state to SCAN_INIT if successful. If not, it is\r\n  silently swallowed (not good!), and the enumeration will have zero\r\n  elements (hasMore==false).\r\n\r\n* Next, the constructor performs a scan.next() which sets the boolean\r\n  state variable \"hasMore\". When this is true, the scan state will be\r\n  SCAN_INPROGRESS, when its is false, there are no more data and the\r\n  scan state will be SCAN_DONE. So when the constructor of ElementEnum\r\n  returns, the scan state (if no error occurred) will be one of\r\n  {SCAN_INPROGRESS, SCAN_DONE}.\r\n\r\n  If we have holdability: The state SCAN_HOLD_INIT can only happen if\r\n  a commit happens *before* an initial next() is performed, so that\r\n  state can not happen for this scan. Also, I believe there are no\r\n  state transitions possible back to SCAN_INIT or SCAN_HOLD_INIT once\r\n  a next() is performed and {SCAN_INPROGRESS, SCAN_DONE} is reached (I\r\n  did some inspection).\r\n\r\n* Now, when ElementEnum#nextElement() is attempted, there are four cases\r\n  cases: \r\n     n1) holdability and no commit has happened \r\n     n2) holdability and a commit happened\r\n     n3) no holdability and  no commit has happened \r\n     n4) no holdability and a commit happened\r\n  \r\n  n1) Scan state should be either \r\n      SCAN_INPROGRESS (and hasMore == true) or \r\n      SCAN_DONE (and hasMore == false).\r\n\r\n      If hasMore == false, NoSuchElementException is thrown.  \r\n      If hasMore == true, state should be SCAN_INPROGRESS,\r\n      isPositioned() returns true and the fetch will succeed. Also a\r\n      new next() is performed which moves the state to one of\r\n      {SCAN_INPROGRESS, SCAN_DONE}.\r\n\r\n  n2) Scan state should be either \r\n      SCAN_HOLD_INPROGRESS¹ (and hasMore == true) or \r\n      SCAN_DONE (and hasMore == false).\r\n\r\n      If hasMore == false, NoSuchElementException is thrown. This\r\n      would not normally happen, since nextElement would not be\r\n      called, cf, hasMoreElements().\r\n\r\n      If hasMore == true, state should be SCAN_HOLD_INPROGRESS: Our\r\n      predicate \"(keepAfterCommit && !scan.isPositioned()\" == true and\r\n      we reopen scan before doing the fetch, which should succeed.  A\r\n      new next() is performed which moves the state to one of\r\n      {SCAN_INPROGRESS, SCAN_DONE}.\r\n\r\n      ¹see GenericScanController#closeForEndTransaction().\r\n\r\n  n3) Similar to n1, except isPositioned() is not called.\r\n\r\n  n4) Scan state should be SCAN_DONE,\r\n      cf. GenericScanController#closeForEndTransaction.\r\n  \r\n      In this case, nextElement is never called; the fact that the\r\n      result set is closed is caught at a higher level, e.g. in\r\n      BasicNoPutResultSetImpl#getNextRow() for the DISTINCT case\r\n      (SQLState.LANG_RESULT_SET_NOT_OPEN, ca line 463).\r\n\r\n      Even if it were reached, no attempt to reopen it would be\r\n      performed (not held), and scan.fetch would throw\r\n      SQLState.AM_SCAN_NOT_POSITIONED, which is OK.\r\n\r\n* There is a public method setScanState(state) in\r\n  GenericScanController which could conceivably be used to effect\r\n  other state transitions, but I checked, and it is only used by\r\n  HeapScan#positionAtRowLocation to transition from\r\n  SCAN_HOLD_INPROGRESS back to SCAN_INPROGRESS (and for a similar\r\n  purpose by HeapCompressScan).\r\n\r\n* Now, for your question, would it better (safer) to explicitly test\r\n  for SCAN_HOLD_INPROGRESS with a method called, say,\r\n  heldAcrossCommit? I believe my analysis above shows that when the\r\n  call to isPositioned is performed, there are only two possible\r\n  states the scan can be in: SCAN_HOLD_INPROGRESS or SCAN_INPROGRESS,\r\n  so they are equally safe (as the code stands right now, anyway).\r\n\r\n  Now, whether there is, or were to be, some *other* way of closing\r\n  the scan (moving it to SCAN_DONE without also closing the result\r\n  set), I don't know, but if it were, positionAtRowLocation will\r\n  actually try to reopen the scan (not sure if this is good or not ;),\r\n  however scan.fetch() would fail with\r\n  SQLState.AM_SCAN_NOT_POSITIONED. If we use your approach, we would\r\n  not attempt to reopen in such a case, which may be safer.\r\n\r\n  I agree heldAcrossCommit has the benefit of avoiding the test for\r\n  holdability as you indicate, which does make for easier reading of\r\n  the logic. I think I went for is isPositioned from a vague feeling\r\n  this was potentially more generally useful..\r\n\r\n  Maybe a (even more) generally useful method could be:\r\n  \r\n    public boolean isHeldAfterCommit() throws StandardException\r\n    {\r\n        return (scan_state == SCAN_HOLD_INIT ||\r\n                scan_state == SCAN_HOLD_INPROGRESS);\r\n    }\r\n\r\n  that is, if this returns true, the scan can always be reopened\r\n  (although in the case at hand, only the second state tested for may\r\n  occur as shown above).\r\n\r\n  What do you think?\r\n\r\n\r\n> 2) .... I was wondering, though, if it would be worth it to check\r\n> that the correct *error* is thrown if a call to \"next()\" is made\r\n> after a commit when holdOverCommit is *false*. Or is that already\r\n> tested somewhere else?\r\n\r\nAs I mentioned above, the error is caught higher up in language layer\r\n(open result set or not), so I belive this is (or should be ;-) tested\r\nfor elsewhere. I manually modified the test to verify that for all\r\nthree variants (join, distinct and cursor), this happened. If you this\r\nit is still advisable, I can add those tests cases to SpillHash.\r\n\r\nIf you agree, I will make a version of the patch with the new\r\nisHeldAfterCommit outlined above.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"created":"2007-04-24T23:14:54.682+0000","updated":"2007-04-24T23:14:54.682+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12365142/comment/12491683","id":"12491683","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"Thank you _very_ much for the detailed analysis, Dag.   I feel better about the \"safety\" of your v3 changes after reading your previous comment.\r\n\r\n>  Maybe a (even more) generally useful method could be:\r\n>  \r\n>    public boolean isHeldAfterCommit() throws StandardException\r\n>    {\r\n>        return (scan_state == SCAN_HOLD_INIT ||\r\n>                scan_state == SCAN_HOLD_INPROGRESS);\r\n>    } \r\n>\r\n>  that is, if this returns true, the scan can always be reopened\r\n>  (although in the case at hand, only the second state tested for may\r\n>  occur as shown above).\r\n>\r\n>  What do you think?\r\n\r\n+1, I like this idea even better.  Thank you for the suggestion and for your willingness to implement it.\r\n\r\n> I manually modified the test to verify that for all three variants (join, distinct and cursor),\r\n> this happened. If you this it is still advisable, I can add those tests cases to SpillHash.\r\n\r\nIf it's not too much work I think this would be good.  I'm sure there are tests elsewhere to check the general concept of cursor holdability across commits, but it might be nice to have a test case for the specific scenario of a spilled DiskHashtable.\r\n\r\n> If you agree, I will make a version of the patch with the new isHeldAfterCommit outlined above.\r\n\r\nSounds great.  Thanks again for your continued work with this, and for your prompt consideration of my feedback.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2007-04-25T16:12:45.916+0000","updated":"2007-04-25T16:12:45.916+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12365142/comment/12492080","id":"12492080","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"body":"This patch (DERBY-2462-4.*) supercedes earlier versions.\r\n\r\nAs agreed,\r\n\r\n- it replaces ScanController#isPositioned with with isHeldAfterCommit\r\n  and uses that in DiskHashTable#ElementNum#NextElement.\r\n- it adds negative tests to SpillHash.java for the non-holdable cases\r\n\r\nRan regression tests successfully again (Sun JDK 1.4 and 1.6), Solaris\r\n10/x86 modulo upgrade tests which failed as mentioned on derby-dev\r\n(unrelated I believe).\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"created":"2007-04-26T18:05:47.385+0000","updated":"2007-04-26T18:05:47.385+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12365142/comment/12492093","id":"12492093","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"body":"Latest patch (version 4) incorporates all previous feedback and I have no other comments to make.  I applied the patch and ran lang/SpillHash.java with no problems.  I also ran the repro attached to this issue after applying the patch, and it ran cleanly.\r\n\r\n+1 to commit.\r\n\r\nThank you for your persistence with this issue, Dag.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=army","name":"army","emailAddress":"qozinx at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"A B","active":true},"created":"2007-04-26T18:53:08.227+0000","updated":"2007-04-26T18:53:08.227+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12365142/comment/12496286","id":"12496286","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"body":"Refreshed the patch and ran derbyall and suites.All ok again, modulo\r\none seemingly intermittent error in ReleaseCompileLocksTest. I don't\r\nthis is related to this patch.  Committed as svn 538572.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"created":"2007-05-16T13:09:26.137+0000","updated":"2007-05-16T13:09:26.137+0000"}]},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-2462/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i0765r:"}}