{"expand":"renderedFields,names,schema,transitions,operations,editmeta,changelog","id":"12414691","self":"https://issues.apache.org/jira/rest/api/latest/issue/12414691","key":"DERBY-4055","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/10594","id":"10594","key":"DERBY","name":"Derby","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=10594&avatarId=10122","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=10594&avatarId=10122","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=10594&avatarId=10122","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=10594&avatarId=10122"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10090","id":"10090","description":"DB related projects","name":"DB"}},"fixVersions":[],"aggregatetimespent":null,"resolution":null,"customfield_12310220":"2009-02-14 00:29:45.894","customfield_12312322":null,"customfield_12312323":null,"customfield_12310420":"23997","customfield_12310222":null,"customfield_12312320":null,"customfield_12312321":null,"customfield_12312120":null,"customfield_12312121":null,"resolutiondate":null,"workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312326":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312324":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-4055/watchers","watchCount":2,"isWatching":false},"created":"2009-02-12T19:41:30.432+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"labels":["derby_triage10_11"],"customfield_12312333":null,"customfield_12312334":null,"customfield_12310310":"1.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12311953","id":"12311953","description":"","name":"10.1.3.1","archived":false,"released":true,"releaseDate":"2006-06-30"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12312027","id":"12312027","description":"","name":"10.2.2.0","archived":false,"released":true,"releaseDate":"2006-12-19"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12313142","id":"12313142","description":"","name":"10.3.3.0","archived":false,"released":true,"releaseDate":"2008-05-12"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12313345","id":"12313345","description":"","name":"10.4.2.0","archived":false,"released":true,"releaseDate":"2008-09-05"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12313771","id":"12313771","description":"build: 764942, 14/Apr/09. Voted release: 28/Apr/09. Announced: 1/May/09","name":"10.5.1.1","archived":false,"released":true,"releaseDate":"2009-04-28"}],"customfield_12311120":null,"customfield_12312330":null,"issuelinks":[{"id":"12323416","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12323416","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"inwardIssue":{"id":"12414163","key":"DERBY-4050","self":"https://issues.apache.org/jira/rest/api/2/issue/12414163","fields":{"summary":"Multithreaded clob update causes growth in table that does not get reclaimed","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}},{"id":"12341280","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12341280","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"inwardIssue":{"id":"12515565","key":"DERBY-5356","self":"https://issues.apache.org/jira/rest/api/2/issue/12515565","fields":{"summary":"Tracking  for Derby space reclamation issues ","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"New"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/3","id":"3","description":"A task that needs to be done.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/task.png","name":"Task","subtask":false}}}},{"id":"12355408","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12355408","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"inwardIssue":{"id":"12599854","key":"DERBY-5876","self":"https://issues.apache.org/jira/rest/api/2/issue/12599854","fields":{"summary":"Overhaul table compression code","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"New"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/3","id":"3","description":"A task that needs to be done.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/task.png","name":"Task","subtask":false}}}}],"customfield_12312339":null,"assignee":null,"customfield_12312337":null,"customfield_12312338":null,"updated":"2013-07-03T15:26:43.285+0000","customfield_12312335":null,"customfield_12311720":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"New"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/11412","id":"11412","name":"Store"}],"timeoriginalestimate":null,"description":"In a multithreaded clob update where the same row is being updated, space will not be reclaimed.  The offending code is in ReclaimSpaceHelper:\r\n\r\n\tRecordHandle headRecord = work.getHeadRowHandle();\r\n\r\n\t\tif (!container_rlock.lockRecordForWrite(\r\n                tran, headRecord, false /* not insert */, false /* nowait */))\r\n\t\t{\r\n\t\t\t// cannot get the row lock, retry\r\n\t\t\ttran.abort();\r\n\t\t\tif (work.incrAttempts() < 3)\r\n            {\r\n\t\t\t\treturn Serviceable.REQUEUE;\r\n            }\r\n\t\t\telse\r\n            {\r\n                // If code gets here, the space will be lost forever, and\r\n                // can only be reclaimed by a full offline compress of the\r\n                // table/index.\r\n\r\n                if (SanityManager.DEBUG)\r\n                {\r\n                    if (SanityManager.DEBUG_ON(DaemonService.DaemonTrace))\r\n                    {\r\n                        SanityManager.DEBUG(\r\n                            DaemonService.DaemonTrace, \r\n                            \"  gave up after 3 tries to get row lock \" + \r\n                            work);\r\n                    }\r\n                }\r\n\t\t\t\treturn Serviceable.DONE;\r\n            }\r\n\t\t}\r\n\r\n\r\nIf we cannot get the lock after three tries we give up.  The reproduction for this issue is in the test store.ClobReclamationTest.xtestMultiThreadUpdateSingleRow().\r\n\r\n\r\nThis issue also used to reference the code below and has some references to trying to get a reproduction for that issue, but that work has moved to DERBY-4054.  Please see DERBY-4054 for work on the container lock issue.\r\n\r\nContainerHandle containerHdl = \r\n\t\t\topenContainerNW(tran, container_rlock, work.getContainerId());\r\n\r\n\t\tif (containerHdl == null)\r\n\t\t{\r\n\t\t\ttran.abort();\r\n\r\n\t\t\tif (SanityManager.DEBUG)\r\n            {\r\n                if (SanityManager.DEBUG_ON(DaemonService.DaemonTrace))\r\n                {\r\n                    SanityManager.DEBUG(\r\n                        DaemonService.DaemonTrace, \" aborted \" + work + \r\n                        \" because container is locked or dropped\");\r\n                }\r\n            }\r\n\r\n\t\t\tif (work.incrAttempts() < 3) // retry this for serveral times\r\n            {\r\n\t\t\t\treturn Serviceable.REQUEUE;\r\n            }\r\n\t\t\telse\r\n            {\r\n                // If code gets here, the space will be lost forever, and\r\n                // can only be reclaimed by a full offline compress of the\r\n                // table/index.\r\n\r\n                if (SanityManager.DEBUG)\r\n                {\r\n                    if (SanityManager.DEBUG_ON(DaemonService.DaemonTrace))\r\n                    {\r\n                        SanityManager.DEBUG(\r\n                            DaemonService.DaemonTrace, \r\n                            \"  gave up after 3 tries to get container lock \" + \r\n                            work);\r\n                    }\r\n                }\r\n\r\n\t\t\t\treturn Serviceable.DONE;\r\n            }\r\n\t\t}\t\r\n\r\n\r\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12310200":null,"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"aggregatetimeestimate":null,"customfield_12312022":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12310921":null,"customfield_12310920":"35598","summary":"Space may not be reclaimed if  row locks are not available after three retries ","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"subtasks":[],"customfield_12310090":[{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10422","value":"High Value Fix","id":"10422"},{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10427","value":"Workaround attached","id":"10427"}],"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"customfield_12310291":null,"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"environment":null,"customfield_12311020":null,"customfield_12310050":{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10052","value":"Normal","id":"10052"},"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"startAt":0,"maxResults":8,"total":8,"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12414691/comment/12673044","id":"12673044","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"With revision 743867, checked in reproduction for the case where it cannot get the row lock after three tries.\r\nenable store.ClobReclamationTest.xtestMultiThreadUpdateSingleRow()\r\nIf multiple threads are trying to update the same row, reclamation doesn't happen and with derby.debug.true=Daemon trace see in the log many instances of:\r\nDEBUG DaemonTrace OUTPUT:   gave up after 3 tries to get row lock Reclaim COLUMN_CHAIN...\r\n\r\n\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2009-02-12T20:29:02.326+0000","updated":"2009-02-12T20:29:02.326+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12414691/comment/12673134","id":"12673134","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"I noticed in the code coverage output that we do cover the case where we give  up after 3 tries to get container lock, so I put in an ASSERT and ran the store tests and found it pops with T_RawStoreFactory.unit. Attached is the derby.log with the assertion.  I am not sure how the failing   unit tests  would translate into a user case.  I'll ponder that tomorrow unless it becomes obvious to someone else in the meanwhile.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2009-02-13T03:57:47.241+0000","updated":"2009-02-13T03:57:47.241+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12414691/comment/12673325","id":"12673325","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"I looked at one of the test cases that triggered my assertion,  P703.  In this case the test drops the container before commit.\r\nif (segment != ContainerHandle.TEMPORARY_SEGMENT) {\r\n\t\t\tt_util.t_dropContainer(t, segment, cid);\t// cleanup\r\n\t\t}\r\n\r\n\t\tt.commit();\r\n\r\nSo I think that's why we give up.  I don't really see how I could emulate this in JDBC and it would be the lock case that I would want to trigger anyway.  So, I don't think this unit test gives me a clue how to reproduce the  \"  gave up after 3 tries to get container lock \" case with JDBC.\r\n\r\n\r\n\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2009-02-13T17:54:44.163+0000","updated":"2009-02-13T17:54:44.163+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12414691/comment/12673401","id":"12673401","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"For the row lock case, changing container_rlock.lockRecordForWrite to wait for the lock seemed to correct the problem, but I don't know what ramifications that might have.\r\n \r\nAlways requeuing the request  if we couldn't get the lock seemed to work only if I put a sleep in before closing the connection to give the post commit tasks a chance to catch up. I had to sleep over a minute to get 10,000 updates by each of two threads to catch up.  Even then I had a lot of free pages, so the space would ultimately get reclaimed, but  we'd still use a lot of space.  In a very active system I could also see the post commit tasks piling up and becoming a resource issue, so this solution doesn't seem like a good option.\r\n\r\nQuestions:\r\n\r\n1) Is it expected that the cleanup tasks will just be aborted if if the connection is closed or is that another bug?\r\n\r\n2) Anyone have any ideas on an acceptable approach to make sure our reclamation  gets done without causing unacceptable lock contention?\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2009-02-13T22:20:49.265+0000","updated":"2009-02-13T22:20:49.265+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12414691/comment/12673436","id":"12673436","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"Wait on the lock or bump on the retry are the only \"easy\" bug fixes I can \r\nthink of.  There are downsides to both.\r\n\r\nwait on lock:\r\nCurrently we only have a single background thread to do these kinds of tasks,\r\nit is single threaded through each task.  So if you wait on lock, then every\r\nbackground task waits until that can get finished.  Stuff like checkpoints,\r\nand other space reclamation tasks will wait.  The queue may grow and become\r\nunmanageable.\r\n\r\nbump retry:\r\nCould lead to just cpu spinning and no actual guarantee of getting the resource\r\nas it could keep getting unlucky and lose a cycle schedule when the resource\r\nis actually available.\r\n\r\nBigger feature projects could do resolve these issues.\r\n\r\n1) Enhance the background daemon schedule utility to support more than one\r\n   thread.  \r\n   o I think it is important that we don't just randomly grow the number\r\n     of background threads, as we already have complaints about the one\r\n     background thread per db.  But it would be fine to short term allocate \r\n     a thread and then destroy it.\r\n   o not sure exactly what is best, but in this case it would be nice to \r\n     be able to REQUE the post commit task to the daemon saying add it to the\r\n     WAIT allowed queue.  At that point maybe the daemon starts a new thread\r\n     for each one or maybe for each N or something else.  Maybe it is \r\n     configurable.\r\n   o There are already other problems for which this may be the solution:\r\n\r\n     1) As number of cores/cpu's grow it becomes obvious that one background\r\n        thread to N possible concurrent user thread which could each generate\r\n        work is not correct.\r\n     2) There are some tasks that are even more critical than others that could\r\n        benefit from better priority.  Things like checkpoint may want their\r\n        own thread rather than share with others.\r\n\r\n\r\n2) The problem with space being lost \"forever\" (which really means until an\r\n   offline compress, in part stems from the row format of the overflow pieces.\r\n\r\n   o we could change the overflow pieces to have back pointers to the main\r\n     head page which would make it much easier to figure out a stranded piece\r\n     during online compress.\r\n\r\n   o We could write some sort of brute force search which could come up with\r\n     the stranded pieces and call reclaim on them.  It is actually not that\r\n     hard of code to write if one doesn't worry about memory.  It would go\r\n     something like - probably many ways to optimize it. :\r\n\r\n     for (every page at raw store level)\r\n     {\r\n         if (main page)\r\n         {\r\n             for every row on page\r\n             {\r\n                 if (has an overflow piece)\r\n                     add main row handle to main hash table, and overflow handle\r\n             }\r\n         }\r\n\r\n         if (overflow page)\r\n         {\r\n             for every row on page\r\n             {\r\n                 add main row handle, and next overflow handle\r\n             }\r\n         }\r\n\r\n     }\r\n\r\n     for (every row in main hash table)\r\n     {\r\n         delete complete overflow chain from overflow hash table\r\n     }\r\n\r\n     I believe this leaves the disconnected chains in the overflow hash table,\r\n     with some graph algorithm to determine the head of the chains.\r\n\r\n     The above works for X lock on the whole table, I am not sure if row locking\r\n     works.  If you have to get X lock then an offline compress is not that much\r\n     worse which is why it never got implemented.\r\n\r\n3) This post commit work is all still really at the first implmentation level,\r\n   when most choices were what was simple and mostly work.  Not much has \r\n   happened since then.  Also in first implementation big CLOB's and BLOB's were\r\n   not even implemented so the downside of losing some stuff was not much.\r\n\r\n   As Kathey pointed out I think there are holes in a lot of the post commit\r\n   stuff where a crash can lose them.  It seems the only way to make sure we\r\n   don't lose them is to somehow store them transactionally in the db, but at\r\n   what cost?  We could implement some sort of internal table, and then store\r\n   rows with the post commit work.\r\n\r\nPersonally I think 1 and 2 are better paths than 3.  It would be interesting\r\nto know what other db's do.  I am pretter sure postgress for instance rely's\r\non scheduling a \"scrubber\" to do a lot of what we do in post commit.  I would\r\nrather see us make changes that would allow online compress table to handle\r\nthese overflow losses and then enhance the post commit deamon to better handle\r\nthem asap without ever needing the compress table.\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2009-02-14T00:29:45.894+0000","updated":"2009-02-14T00:29:45.894+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12414691/comment/12680196","id":"12680196","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"I was working with a user who found they could work around this issue with use of better indexing. They had a simultaneous update and select which were accessing different rows, but still they saw this problem occur.  Putting an index on the column from which they were doing the select avoided a table scan and thus avoided the issue.  Hopefully this will work as a workaround for others until we can get this issue fixed.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2009-03-09T16:56:23.571+0000","updated":"2009-03-09T16:58:17.734+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12414691/comment/12726871","id":"12726871","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Triaged for 10.5.2.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-07-03T10:20:45.943+0000","updated":"2009-07-03T10:20:45.943+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12414691/comment/13212437","id":"13212437","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"Triaged for 10.9, no changes.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2012-02-21T08:06:33.021+0000","updated":"2012-02-21T08:06:33.021+0000"}]},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-4055/votes","votes":1,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i06gfz:"}}