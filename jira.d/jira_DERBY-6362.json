{"expand":"renderedFields,names,schema,transitions,operations,editmeta,changelog","id":"12671742","self":"https://issues.apache.org/jira/rest/api/latest/issue/12671742","key":"DERBY-6362","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/10594","id":"10594","key":"DERBY","name":"Derby","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=10594&avatarId=10122","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=10594&avatarId=10122","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=10594&avatarId=10122","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=10594&avatarId=10122"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10090","id":"10090","description":"DB related projects","name":"DB"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12324243","id":"12324243","description":"First release on the 10.11 branch","name":"10.11.1.1","archived":false,"released":true,"releaseDate":"2014-08-26"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12310220":"2013-10-02 13:10:58.195","customfield_12312322":null,"customfield_12312323":null,"customfield_12310420":"351454","customfield_12310222":"3_*:*_1_*:*_1227107353_*|*_1_*:*_1_*:*_4326373593_*|*_5_*:*_1_*:*_0","customfield_12312320":null,"customfield_12312321":null,"customfield_12312120":null,"customfield_12312121":null,"resolutiondate":"2013-12-05T15:56:48.074+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312326":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312324":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-6362/watchers","watchCount":5,"isWatching":false},"created":"2013-10-02T09:18:47.163+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"labels":["derby_backport_reject_10_10"],"customfield_12312333":null,"customfield_12312334":null,"customfield_12310310":"5.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12321550","id":"12321550","description":"First release on the 10.10 branch","name":"10.10.1.1","archived":false,"released":true,"releaseDate":"2013-04-15"}],"customfield_12311120":null,"customfield_12312330":null,"issuelinks":[{"id":"12376231","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12376231","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"outwardIssue":{"id":"12408289","key":"DERBY-3944","self":"https://issues.apache.org/jira/rest/api/2/issue/12408289","fields":{"summary":"CHECK constraints involving user-coded functions may return different results depending on who performs the triggering INSERT/UPDATE","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}},{"id":"12386248","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12386248","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"inwardIssue":{"id":"12672316","key":"DERBY-6370","self":"https://issues.apache.org/jira/rest/api/2/issue/12672316","fields":{"summary":"dblook doesn't schema-qualify identifiers in trigger actions","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}}],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"customfield_12312337":null,"customfield_12312338":null,"updated":"2015-01-21T00:23:37.807+0000","customfield_12312335":null,"customfield_12311720":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/11408","id":"11408","name":"SQL"}],"timeoriginalestimate":null,"description":"DERBY-3944 fixed the problem with CHECK constraints invoking different routines depending on who performed the triggering INSERT or UPDATE statement.\r\n\r\nThe discussion leading up to DERBY-3944 can be found here: http://mail-archives.apache.org/mod_mbox/db-derby-dev/200811.mbox/%3C4919CD4A.5010408@sun.com%3E\r\n\r\nThree alternatives are discussed in the thread:\r\n\r\nA) The schema that holds the CHECK constraint?\r\nB) The schema that holds the table?\r\nC) The current schema when the CREATE TABLE statement was issued?\r\n\r\nThe conclusion in the thread was that option C was the correct one. However, what was implemented, was option B.\r\n\r\nI cannot find any information in DERBY-3944 about why option B ended up being chosen, so I assume that it was unintended.\r\n\r\nHere's an ij script that shows how the CHECK constraint tries to invoke the TO_HEX function in the schema of the target table (S2) instead of the schema that was the current schema at the time of CREATE TABLE:\r\n\r\nij version 10.10\r\nij> connect 'jdbc:derby:memory:db;create=true';\r\nij> create schema s1;\r\n0 rows inserted/updated/deleted\r\nij> create schema s2;\r\n0 rows inserted/updated/deleted\r\nij> create function s1.to_hex(i int) returns char(4) language java parameter style java external name 'java.lang.Integer.toHexString' no sql;\r\n0 rows inserted/updated/deleted\r\nij> set schema s1;\r\n0 rows inserted/updated/deleted\r\nij> create table s2.t(x int, constraint cc check(to_hex(x) <> '80'));\r\n0 rows inserted/updated/deleted\r\nij> insert into s2.t values 1;\r\nERROR 42Y03: 'TO_HEX' is not recognized as a function or procedure. (errorCode = 30000)\r\nij> create function s2.to_hex(i int) returns char(4) language java parameter style java external name 'java.lang.Integer.toHexString' no sql;\r\n0 rows inserted/updated/deleted\r\nij> insert into s2.t values 1;\r\n1 row inserted/updated/deleted","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12310200":null,"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"aggregatetimeestimate":null,"customfield_12312022":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12310921":null,"customfield_12310920":"351743","summary":"CHECK constraint uses wrong schema for unqualified routine invocations","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"subtasks":[],"customfield_12310090":[{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10424","value":"Repro attached","id":"10424"}],"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"customfield_12310291":null,"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"environment":null,"customfield_12311020":null,"customfield_12310050":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"startAt":0,"maxResults":26,"total":26,"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13783896","id":"13783896","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rhillegas","name":"rhillegas","emailAddress":"rhillegas at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Rick Hillegas","active":true},"body":"I see 3 messages in the email thread which Knut cited. The conclusion in the last message involves a leap of reasoning which I don't understand. The referenced part of the standard (part 2, section 4.27.2) just says that the routine's schema is determined when the check constraint is declared. It still doesn't say which of the 3 options is correct. I don't understand which part of the standard supports option C.\r\n\r\nOption C gives rise to non-deterministic behavior if the DDL is dumped via dblook and then re-run. You are not guaranteed that the CHECK constraint will be re-created from the same schema. Options A and B don't have this problem. I would be reluctant to introduce this non-determinacy.\r\n\r\nI can't reconstruct why the solution to DERBY-3944 preferred option B over A. Thanks.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rhillegas","name":"rhillegas","emailAddress":"rhillegas at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Rick Hillegas","active":true},"created":"2013-10-02T13:10:58.195+0000","updated":"2013-10-02T13:10:58.195+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13784102","id":"13784102","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I agree that the email thread doesn't get completely to the bottom of it, so more reading of the standard is needed in order to find out what's the correct behaviour.\r\n\r\nI think it is possible to make dblook have deterministic behaviour even with option C. We could make it create DDL that uses a schema qualified name for the routine, if it doesn't already.\r\n\r\nIf we conclude that option B is correct, we still need to make changes to CHECK constraint, as it currently seems to use a mix of option B and option C. See for example this ij transcript:\r\n\r\n{noformat}\r\nij version 10.10\r\nij> connect 'jdbc:derby:memory:db;create=true';\r\nij> create function bin.f(i int) returns char(32) language java parameter style java external name 'java.lang.Integer.toBinaryString' no sql;\r\n0 rows inserted/updated/deleted\r\nij> create function hex.f(i int) returns char(4) language java parameter style java external name 'java.lang.Integer.toHexString' no sql;\r\n0 rows inserted/updated/deleted\r\nij> values (hex.f(10), bin.f(10));\r\n1   |2                               \r\n-------------------------------------\r\na   |1010                            \r\n\r\n1 row selected\r\nij> set schema bin;\r\n0 rows inserted/updated/deleted\r\nij> create table hex.t(x int, constraint cc check(f(x) = 'a'));\r\n0 rows inserted/updated/deleted\r\nij> insert into hex.t(x) values 10;\r\n1 row inserted/updated/deleted\r\nij> insert into hex.t(x) values 11;\r\nERROR 23513: The check constraint 'CC' was violated while performing an INSERT or UPDATE on table '\"HEX\".\"T\"'.\r\nij> drop function hex.f;\r\n0 rows inserted/updated/deleted\r\nij> drop function bin.f;\r\nERROR X0Y25: Operation 'DROP ROUTINE' cannot be performed on object 'F' because CONSTRAINT 'CC' is dependent on that object.\r\n{noformat}\r\n\r\nHere, the constraint CC apparently uses the function HEX.F. Still, there is no error or warning when HEX.F is dropped. But if you try to drop BIN.F, which is not used in constraint CC, you get an error saying that CC depends on it.\r\n\r\nAlso, if you go back to the example in the bug description, I think that the error saying TO_HEX didn't exist should have happened at CREATE TABLE time, not when performing the INSERT.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-10-02T15:54:56.669+0000","updated":"2013-10-02T15:54:56.669+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13786521","id":"13786521","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rhillegas","name":"rhillegas","emailAddress":"rhillegas at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Rick Hillegas","active":true},"body":"Note that the SQL Standard, part 2, section 11.6 (table constraint definition), syntax rule 2 says that constraints must live in the same schema as the table they are attached to. So options A and B are the same.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rhillegas","name":"rhillegas","emailAddress":"rhillegas at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Rick Hillegas","active":true},"created":"2013-10-04T19:17:10.289+0000","updated":"2013-10-04T19:17:10.289+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13787996","id":"13787996","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I wanted to see what other databases did, so I tested it on instances of MySQL, PostgreSQL and Oracle that I had access to. Oracle doesn't allow user-defined functions in CHECK constraints, and MySQL ignores CHECK constraints, so I got no useful information from those two databases. PostgreSQL seems to be using option C.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-10-07T08:55:51.263+0000","updated":"2013-10-07T08:55:51.263+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13788013","id":"13788013","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"It seems if you create a generated column in an Oracle database, it uses option A/B.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-10-07T09:30:33.628+0000","updated":"2013-10-07T09:30:33.628+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13789244","id":"13789244","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rhillegas","name":"rhillegas","emailAddress":"rhillegas at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Rick Hillegas","active":true},"body":"I have exchanged email with some other members of the SQL committee. They have pointed me at the portions of the SQL Standard which discuss the SQL-path. It sheds some light on this discussion.\r\n\r\nThe SQL-path is introduced by part 2, section 4.29 (SQL-paths). Fully evolved, a SQL-path is a search order for schema resolution. It's akin to the search order in a Unix path or Java classpath. The CURRENT_PATH variable (implemented in some databases) shows the value of the SQL-path...\r\n\r\n    values CURRENT_PATH\r\n\r\n...much as the following Unix commands show the value of the shell's path and classpath variables:\r\n\r\n    echo $PATH\r\n    echo $CLASSPATH\r\n\r\nAccording to part 2, section 4.29 (SQL-paths), the SQL-path is used to resolve routine and type references which lack a schema qualifier and which appear in \"preparable statements\". These statements, in turn, include the standalone DDL statements like CREATE/ALTER TABLE. So SQL-path should be used to resolve unqualified routine/type references in CHECK constraints and generation clauses.\r\n\r\nThe value of SQL-path is implementation-defined. The Standard lets you change the value of SQL-path via a SET PATH command, which Derby does not implement. SET PATH is independent of the SET SCHEMA command which Derby does implement. Note that the SET SCHEMA command (part 2, section 19.6) changes how unqualified names are resolved in \"preparable statements\". However, that section does not claim that SET SCHEMA has any affect on SQL-path.\r\n\r\nThe Derby code never speaks about SQL-path. This is a part of the Standard which Derby ignores. So Derby's inconsistent treatment of SQL-path is not surprising. That said, now that we are aware of SQL-path, it would be good to make Derby's behavior consistent.\r\n\r\nFor most statements, Derby behaves as though CURRENT_PATH is a list with one value in it (CURRENT_SCHEMA). So, unqualified routine references in DML statements are resolved to CURRENT_SCHEMA. The same is true for unqualified routine references in generation clauses and unqualified type references in CREATE TABLE statements.\r\n\r\nIf we treated CHECK constraints the same way, then we would have behavior (C) described above. This seems reasonable to me. That is, it makes sense to me that we should formalize our understand of SQL-path and apply it consistently going forward. Derby's implementation of SQL-path would be simple, viz., CURRENT_PATH = CURRENT_SCHEMA.\r\n\r\nThe following script shows the current behavior of CURRENT_PATH:\r\n\r\n---------------------------------------------\r\n\r\nconnect 'jdbc:derby:memory:db;create=true';\r\n\r\ncreate schema neutralSchema;\r\n\r\ncreate schema ddlSessionSchema;\r\nset schema ddlSessionSchema;\r\n\r\ncreate type myType external name 'java.util.HashMap' language java;\r\n\r\ncreate function myCheckFunc( doubleVal double ) returns double\r\nlanguage java parameter style java deterministic no sql\r\nexternal name 'java.lang.Math.sin';\r\n\r\ncreate function myGenColFunc( doubleVal double ) returns double\r\nlanguage java parameter style java deterministic no sql\r\nexternal name 'java.lang.Math.abs';\r\n\r\n-- --------------------------------\r\n\r\ncreate schema tableSchema;\r\nset schema tableSchema;\r\n\r\ncreate type myType external name 'java.util.ArrayList' language java;\r\n\r\ncreate function myCheckFunc( doubleVal double ) returns double\r\nlanguage java parameter style java deterministic no sql\r\nexternal name 'java.lang.Math.cos';\r\n\r\ncreate function myGenColFunc( doubleVal double ) returns double\r\nlanguage java parameter style java deterministic no sql\r\nexternal name 'java.lang.Math.exp';\r\n\r\n-- --------------------------------\r\n\r\nset schema ddlSessionSchema;\r\n\r\ncreate table tableSchema.t\r\n(\r\n   a myType,\r\n   b double check ( myCheckFunc( b ) > 0 ),\r\n   c generated always as ( myGenColFunc( b ) )\r\n);\r\n\r\n-- --------------------------------\r\n\r\nset schema neutralSchema;\r\n\r\nvalues\r\n(\r\n    ddlSessionSchema.myCheckFunc( -1 ), ddlSessionSchema.myGenColFunc( -1 )\r\n);\r\nvalues\r\n(\r\n    tableSchema.myCheckFunc( -1 ), tableSchema.myGenColFunc( -1 )\r\n);\r\n\r\n-- fails because myType resolves to ddlSessionSchema.myType\r\ninsert into tableSchema.t( a ) values ( cast (null as tableSchema.myType) );\r\n\r\n--\r\n-- myCheckFunc resolves to tableSchema.myCheckFunc\r\n--\r\n-- myGenColFunc resolves to ddlSessionSchema.myGenColFunc\r\n--\r\ninsert into tableSchema.t( b ) values ( -1 );\r\nselect * from tableSchema.t;\r\n\r\n-- --------------------------------\r\n\r\nset schema ddlSessionSchema;\r\n\r\n-- behaves as though CURRENT_PATH = ddlSessionSchema\r\nvalues\r\n(\r\n    myCheckFunc( -1 ), myGenColFunc( -1 )\r\n);\r\n\r\nset schema tableSchema;\r\n\r\n-- behaves as though CURRENT_PATH = tableSchema\r\nvalues\r\n(\r\n    myCheckFunc( -1 ), myGenColFunc( -1 )\r\n);\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rhillegas","name":"rhillegas","emailAddress":"rhillegas at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Rick Hillegas","active":true},"created":"2013-10-08T14:30:37.585+0000","updated":"2013-10-08T14:30:37.585+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13789513","id":"13789513","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"body":"I think resolving to use current schema as current path is a good way forward; +1.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=dagw","name":"dagw","emailAddress":"dag dot wanvik at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=dagw&avatarId=16789","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=dagw&avatarId=16789","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=dagw&avatarId=16789","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=dagw&avatarId=16789"},"displayName":"Dag H. Wanvik","active":true},"created":"2013-10-08T18:44:51.212+0000","updated":"2013-10-08T18:45:01.686+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13790137","id":"13790137","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Thanks for digging into this, Rick. The suggested approach sounds fine to me.\r\n\r\nBy the way, views and triggers seem to use the current schema too.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-10-09T07:47:33.978+0000","updated":"2013-10-09T07:47:33.978+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13796929","id":"13796929","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"How should this behave on upgrade if an existing database has a CHECK constraint with an unqualified identifier and the the original compilation schema is different from the schema in which the constraint lives? Only use the original compilation schema in hard-upgraded databases?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-10-16T16:06:46.508+0000","updated":"2013-10-16T16:06:46.508+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13796950","id":"13796950","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rhillegas","name":"rhillegas","emailAddress":"rhillegas at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Rick Hillegas","active":true},"body":"Thanks for raising that point, Knut. Is there a way to recover the original compilation schema when the database is upgraded? Thanks.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rhillegas","name":"rhillegas","emailAddress":"rhillegas at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Rick Hillegas","active":true},"created":"2013-10-16T16:35:33.292+0000","updated":"2013-10-16T16:35:33.292+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13797035","id":"13797035","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I don't think the original compilation schema is stored currently, so we probably cannot get it for the existing constraints. So for the existing constraints that use unqualified function names, I think we only have these options on upgrade:\r\n\r\n# use the constraint's schema as compilation schema (the constraint will preserve the old behaviour on upgrade)\r\n# fail (either on upgrade or when the CHECK constraint is evaluated)\r\n# drop ambiguous constraints\r\n\r\nI think I prefer option 1.\r\n\r\nWe also need to decide what to do with new constraint definitions in soft upgrade. Since we don't have a mechanism to store the compilation schema currently, we probably have to use the constraint's schema for the constraints defined during soft upgrade. That is, preserve the old behaviour. In hard upgraded databases we could change ConstraintDescriptor to include the original compilation schema.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-10-16T17:35:47.306+0000","updated":"2013-10-16T17:35:47.306+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13797131","id":"13797131","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rhillegas","name":"rhillegas","emailAddress":"rhillegas at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Rick Hillegas","active":true},"body":"Thanks, Knut. I agree that option 1 sounds best.\r\n\r\nWhere will the compilation schema be persisted? One solution might be to re-write the CHECK condition, adding schema qualifications to all unqualified names. That would be what's stored in SYS.SYSCHECKS.CHECKDEFINITION. That might finesse the soft-downgrade issue.\r\n\r\nThanks,\r\n-Rick","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=rhillegas","name":"rhillegas","emailAddress":"rhillegas at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Rick Hillegas","active":true},"created":"2013-10-16T19:02:13.370+0000","updated":"2013-10-16T19:02:13.370+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13797198","id":"13797198","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"My first thought was to add a field to CheckConstraintDescriptor. That approach would require the addition of a new column in SYS.SYSCHECKS, which entails some upgrade work.\r\n\r\nI like the idea of rewriting the CHECK condition and making all unqualified names qualified. Such a solution might be useful for generated columns, views and triggers as well, since qualified names would make it easier to produce correct dblook output for them (see for example DERBY-6370).\r\n\r\nNot sure how easy it is to do the rewrite in a reliable way, though. It might be possible to generalize the code in DataDictionaryImpl.getTriggerActionString(), which replaces old/new transition variables and transition tables with Java method calls or VTIs in trigger actions. But I haven't looked into that.\r\n\r\nAdding a new column to the system table and pushing the compilation schema might be more robust, since the rewrite may easily miss some references if we're not careful, or if we extend the allowed syntax later. But it's not as elegant as rewriting.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-10-16T20:12:08.293+0000","updated":"2013-10-16T20:12:08.293+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13828833","id":"13828833","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I'm looking into rewriting the CHECK constraint before storing it in SYSCHECKS. It looks like all the identifiers that need to be qualified are represented by TableName nodes (even those that are not tables), so using a visitor to find them all might be feasible. Most QueryTreeNode classes don't currently apply visitors to TableName fields, so many acceptChildren() methods have to be changed or added first.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-11-21T11:04:57.711+0000","updated":"2013-11-21T11:04:57.711+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13829889","id":"13829889","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"As to the discussion about SQL-path, Derby's implicit SQL-path for function name resolution includes the SYSFUN schema. That is, if an unqualified function name cannot be found in the current schema, Derby will try to find the function in SYSFUN.\r\n\r\nCHECK constraints don't currently handle this very well. If a CHECK constraint references a function in SYSFUN without explicit schema, and later creates a function with the same name in the current schema, the constraint will incorrectly start using the new function.\r\n\r\nRewriting the CHECK constraint with qualified names before storing it SYSCHECKS will solve this problem. Storing the original compilation schema along with the constraint won't solve it, since that would not carry information about which function to resolve in the current schema and which to resolve in SYSFUN.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-11-22T11:18:49.522+0000","updated":"2013-11-22T11:18:49.522+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13832529","id":"13832529","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Fetching all the TableName nodes and using them to rewrite the CHECK constraint definition before storing it in SYSCHECKS, seems to be working. As suggested earlier, many accept methods need to be changed in order to make the visitors actually see the TableName nodes. To make it easier to separate these mechanical changes from the new rewrite logic, I've split the fix into three patches that should be applied on top of each other. The regression tests ran cleanly after each individual patch.\r\n\r\nHere's a description of the changes made by each of the patches:\r\n\r\nd6362-1a-visit-tablename.diff: This patch makes the acceptChildren() methods of all QueryTreeNode classes descend into any TableName field, including lists/arrays of TableNames. Since only a very limited subset of the language is allowed in CHECK constraints, we don't need all of these for CHECK constraints, but I found it easier to convince myself that no essential ones were forgotten if all were visited.\r\n\r\nd6362-2a-fix-tablename-offset.diff: This patch fixes a problem with qualified table names, where the begin offset was set to the beginning of the table name portion of the TableName node, whereas it should have been set to the beginning of the schema name portion. It also makes some synthetic TableName nodes have unspecified offsets (that is, -1) instead of fake offset values.\r\n\r\nd6362-3a-rewrite-checks.diff:\r\n- This patch makes CHECK constraint definitions replace unqualified names with qualified names before storing them in SYS.SYSCHECKS.\r\n- Since some of the rewrite logic is very similar to the one used to replace references to transition variables in triggers with Java method calls, the common logic was factored out into a shared visitor class (OffsetOrderVisitor, which collects all nodes of a certain type and returns them in offset order).\r\n- In order to make UDT names in CAST expressions qualified, it had to modify the parser so that it adds a reference to the original TableName node from the CastNode. Without the original TableName node, the rewrite logic wouldn't know there was a name that needed qualification.\r\n- It also adds test case.\r\n\r\nThe test case for this issue tests that type names (in casts), function names and table names are rewritten as qualified identifiers. I'm not aware of any other identifiers that could be used in CHECK constraints. Let me know if you can think of others, and I'll add tests for them.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-11-26T12:15:53.451+0000","updated":"2013-11-26T12:15:53.451+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13832590","id":"13832590","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I'm clearing the patch available flag because there's a conflict between these patches and one of the latest commit (either DERBY-3155 revision 1545343, or DERBY-532 revision 1545394). When the patch is applied on head of trunk, some CHECK constraints start failing with IndexOutOfBoundsException:\r\n\r\n{noformat}\r\nij> create table t(x varchar(100), check (x = upper(x)));\r\nERROR XJ001: Java exception: 'start 0, end -24, s.length() 14: java.lang.IndexOutOfBoundsException'.\r\n{noformat}\r\n\r\nThe error is not seen if the patches are applied on top of revision 1545179. I'll look into it.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-11-26T13:43:35.879+0000","updated":"2013-11-26T13:43:35.879+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13836120","id":"13836120","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"The failures seen when the patches are applied on head of trunk, were caused by some changes to the way column references are bound (in DERBY-3155, revision 1545343). Now column references in the CHECK constraint node tree may reference TableName nodes that originate from outside the CHECK constraint. These TableName nodes are found by the visitor during the rewriting, but since they point to tokens outside of the actual CHECK constraint, trying to replace them in the CHECK constraint text will end in index out of bounds.\r\n\r\nI'm uploading a new patch, d6362-3b.diff, that replaces the 3a patch. It should be applied on top of 1a and 2a. The only change in the updated patch is that OffsetOrderVisitor now ignores nodes whose getBeginOffset() and getEndOffset() methods return values that point to tokens outside of the particular SQL fragment that we want to rewrite.\r\n\r\nAll regression tests passed with 1a+2a+3b applied on head of trunk.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-12-01T21:14:21.431+0000","updated":"2013-12-01T21:14:21.431+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13840065","id":"13840065","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I have attached a 3c patch that supersedes the 3b patch. This patch removes a workaround that's not needed now that DERBY-6421 has been fixed.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2013-12-05T13:15:22.695+0000","updated":"2013-12-05T13:15:22.695+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13840067","id":"13840067","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jira-bot","name":"jira-bot","emailAddress":"no-reply at urd dot zones dot apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF subversion and git services","active":true},"body":"Commit 1548127 from [~knutanders] in branch 'code/trunk'\r\n[ https://svn.apache.org/r1548127 ]\r\n\r\nDERBY-6362: CHECK constraint uses wrong schema for unqualified routine invocations\r\n\r\nPart 1: Make sure visitors descend into all TableName nodes.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jira-bot","name":"jira-bot","emailAddress":"no-reply at urd dot zones dot apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF subversion and git services","active":true},"created":"2013-12-05T13:17:13.266+0000","updated":"2013-12-05T13:17:13.266+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13840069","id":"13840069","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jira-bot","name":"jira-bot","emailAddress":"no-reply at urd dot zones dot apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF subversion and git services","active":true},"body":"Commit 1548128 from [~knutanders] in branch 'code/trunk'\r\n[ https://svn.apache.org/r1548128 ]\r\n\r\nDERBY-6362: CHECK constraint uses wrong schema for unqualified routine invocations\r\n\r\nPart 2: Fix offset of qualified table names. Their begin offset\r\npointed to the beginning of the table name token, but should point to\r\nthe beginning of the schema name token if they have one.\r\n\r\nAlso leave begin and end offset unspecified (-1 implied) for some\r\nsynthetic table name nodes that previously set the offsets to 0\r\nexplicitly. This makes it easier to tell whether they are synthetic\r\nlater.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jira-bot","name":"jira-bot","emailAddress":"no-reply at urd dot zones dot apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF subversion and git services","active":true},"created":"2013-12-05T13:17:55.145+0000","updated":"2013-12-05T13:17:55.145+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13840072","id":"13840072","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jira-bot","name":"jira-bot","emailAddress":"no-reply at urd dot zones dot apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF subversion and git services","active":true},"body":"Commit 1548132 from [~knutanders] in branch 'code/trunk'\r\n[ https://svn.apache.org/r1548132 ]\r\n\r\nDERBY-6362: CHECK constraint uses wrong schema for unqualified routine invocations\r\n\r\nPart 3:\r\n\r\n- Refactor code that rewrites trigger actions so that it can be reused\r\n  for rewriting CHECK constraints.\r\n\r\n- Rewrite CHECK constraints and make all identifiers schema qualified\r\n  before storing them in the dictionary.\r\n\r\n- Make the parser preserve the TableName node for the target type in\r\n  CAST expressions for user-defined types, so that they get detected\r\n  by the rewrite logic.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jira-bot","name":"jira-bot","emailAddress":"no-reply at urd dot zones dot apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"ASF subversion and git services","active":true},"created":"2013-12-05T13:26:43.733+0000","updated":"2013-12-05T13:26:43.733+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13913295","id":"13913295","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"consider for 10.10 backport","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2014-02-26T18:42:42.805+0000","updated":"2014-02-26T18:42:42.805+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13915156","id":"13915156","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=myrna","name":"myrna","emailAddress":"m dot v dot lunteren at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Myrna van Lunteren","active":true},"body":"This is a big change. I would suggest not backporting it. Other opinions?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=myrna","name":"myrna","emailAddress":"m dot v dot lunteren at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Myrna van Lunteren","active":true},"created":"2014-02-27T22:53:34.565+0000","updated":"2014-02-27T22:53:34.565+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/13915179","id":"13915179","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"I agree on first look.  Changes look intertwined with other changes, so likely not clean backport.  \r\n+1 to leaving it fixed only in 10.11 and not backporting.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2014-02-27T23:16:07.592+0000","updated":"2014-02-27T23:16:07.592+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12671742/comment/14284832","id":"14284832","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=myrna","name":"myrna","emailAddress":"m dot v dot lunteren at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Myrna van Lunteren","active":true},"body":"bulk change to close all issues resolved but not closed and not changed since June 1, 2014.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=myrna","name":"myrna","emailAddress":"m dot v dot lunteren at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Myrna van Lunteren","active":true},"created":"2015-01-21T00:23:37.797+0000","updated":"2015-01-21T00:23:37.797+0000"}]},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-6362/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i1olhj:"}}