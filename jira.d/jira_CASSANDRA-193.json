{"expand":"renderedFields,names,schema,transitions,operations,editmeta,changelog","id":"12426050","self":"https://issues.apache.org/jira/rest/api/latest/issue/12426050","key":"CASSANDRA-193","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/2","id":"2","description":"A new feature of the product, which has yet to be developed.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png","name":"New Feature","subtask":false},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/12310865","id":"12310865","key":"CASSANDRA","name":"Cassandra","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=12310865&avatarId=12034","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12310865&avatarId=12034","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12310865&avatarId=12034","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12310865&avatarId=12034"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/11961","id":"11961","description":"Apache Cassandra related projects","name":"Cassandra"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12314040","id":"12314040","description":"","name":"0.5","archived":false,"released":true,"releaseDate":"2010-01-24"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12310220":"2009-06-19 22:03:56.632","customfield_12312322":null,"customfield_12312323":null,"customfield_12310222":"10002_*:*_4_*:*_2327527917_*|*_1_*:*_4_*:*_14777428834_*|*_5_*:*_1_*:*_0","customfield_12310420":"27427","customfield_12312320":null,"customfield_12312321":null,"customfield_12312120":null,"customfield_12312121":null,"resolutiondate":"2009-12-05T19:09:58.070+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312326":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312324":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/CASSANDRA-193/watchers","watchCount":4,"isWatching":false},"created":"2009-05-21T19:47:21.319+0000","customfield_10022":null,"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12311124":null,"customfield_12312334":null,"customfield_12310310":"26.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"customfield_12311120":null,"customfield_12312330":null,"issuelinks":[{"id":"12327542","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12327542","type":{"id":"10032","name":"Blocker","inward":"is blocked by","outward":"blocks","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10032"},"outwardIssue":{"id":"12439289","key":"CASSANDRA-520","self":"https://issues.apache.org/jira/rest/api/2/issue/12439289","fields":{"summary":"Implement Range Repairs","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/5","description":"A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/resolved.png","name":"Resolved","id":"5","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/2","id":"2","description":"A new feature of the product, which has yet to be developed.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png","name":"New Feature","subtask":false}}}},{"id":"12325323","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12325323","type":{"id":"10032","name":"Blocker","inward":"is blocked by","outward":"blocks","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10032"},"inwardIssue":{"id":"12428030","key":"CASSANDRA-234","self":"https://issues.apache.org/jira/rest/api/2/issue/12428030","fields":{"summary":"Performance regression tests","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/5","description":"A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/resolved.png","name":"Resolved","id":"5","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/2","id":"2","description":"A new feature of the product, which has yet to be developed.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png","name":"New Feature","subtask":false}}}},{"id":"12325317","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12325317","type":{"id":"10032","name":"Blocker","inward":"is blocked by","outward":"blocks","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10032"},"inwardIssue":{"id":"12428409","key":"CASSANDRA-242","self":"https://issues.apache.org/jira/rest/api/2/issue/12428409","fields":{"summary":"Implement method to \"evenly\" split a Range","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/5","description":"A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/resolved.png","name":"Resolved","id":"5","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/2","id":"2","description":"A new feature of the product, which has yet to be developed.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/newfeature.png","name":"New Feature","subtask":false}}}}],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"customfield_12312337":null,"customfield_12312338":null,"updated":"2009-12-06T12:35:08.288+0000","customfield_12312335":null,"customfield_12311720":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/5","description":"A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/resolved.png","name":"Resolved","id":"5","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/12312978","id":"12312978","name":"Core"}],"timeoriginalestimate":null,"description":"Currently cassandra supports \"read repair,\" i.e., lazy repair when a read is done.  This is better than nothing but is not sufficient for some cases (e.g. catastrophic node failure where you need to rebuild all of a node's data on a new machine).\r\n\r\nDynamo uses merkle trees here.  This is harder for Cassandra given the CF data model but I suppose we could just hash the serialized CF value.","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12312023":null,"customfield_12312024":null,"attachment":[{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12427015","id":"12427015","filename":"193-1-tree-preparation.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-12-05T01:31:23.743+0000","size":14359,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12427015/193-1-tree-preparation.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12425932","id":"12425932","filename":"193-1-tree-preparation.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-24T04:19:30.767+0000","size":14359,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12425932/193-1-tree-preparation.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12425310","id":"12425310","filename":"193-1-tree-preparation.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-18T06:23:21.945+0000","size":11917,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12425310/193-1-tree-preparation.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12424077","id":"12424077","filename":"193-1-tree-preparation.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-05T00:03:47.184+0000","size":11853,"mimeType":"text/x-diff","content":"https://issues.apache.org/jira/secure/attachment/12424077/193-1-tree-preparation.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12427016","id":"12427016","filename":"193-2-tree.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-12-05T01:31:23.798+0000","size":50574,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12427016/193-2-tree.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12425933","id":"12425933","filename":"193-2-tree.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-24T04:19:30.783+0000","size":50583,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12425933/193-2-tree.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12425311","id":"12425311","filename":"193-2-tree.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-18T06:23:21.971+0000","size":81147,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12425311/193-2-tree.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12424078","id":"12424078","filename":"193-2-tree.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-05T00:03:47.238+0000","size":80871,"mimeType":"text/x-diff","content":"https://issues.apache.org/jira/secure/attachment/12424078/193-2-tree.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12427017","id":"12427017","filename":"193-3-aes-preparation.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-12-05T01:31:23.802+0000","size":10927,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12427017/193-3-aes-preparation.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12425934","id":"12425934","filename":"193-3-aes-preparation.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-24T04:19:30.787+0000","size":10927,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12425934/193-3-aes-preparation.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12425312","id":"12425312","filename":"193-3-aes-preparation.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-18T06:23:21.974+0000","size":10927,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12425312/193-3-aes-preparation.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12424079","id":"12424079","filename":"193-3-aes-preparation.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-05T00:03:47.261+0000","size":13847,"mimeType":"text/x-diff","content":"https://issues.apache.org/jira/secure/attachment/12424079/193-3-aes-preparation.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12427018","id":"12427018","filename":"193-4-aes.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-12-05T01:31:53.787+0000","size":62293,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12427018/193-4-aes.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12425935","id":"12425935","filename":"193-4-aes.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-24T04:19:52.458+0000","size":59555,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12425935/193-4-aes.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12425313","id":"12425313","filename":"193-4-aes.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-18T06:23:48.887+0000","size":55634,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12425313/193-4-aes.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12424080","id":"12424080","filename":"193-4-aes.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-05T00:06:45.391+0000","size":27532,"mimeType":"text/x-diff","content":"https://issues.apache.org/jira/secure/attachment/12424080/193-4-aes.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12427019","id":"12427019","filename":"193-5-manual-repair.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-12-05T01:31:53.790+0000","size":9865,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12427019/193-5-manual-repair.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12425936","id":"12425936","filename":"193-5-manual-repair.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-24T04:19:52.462+0000","size":9718,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12425936/193-5-manual-repair.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12425314","id":"12425314","filename":"193-5-manual-repair.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-18T06:23:48.908+0000","size":9862,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12425314/193-5-manual-repair.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12425525","id":"12425525","filename":"193-6-inverted-filter.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-19T21:08:04.611+0000","size":27240,"mimeType":"text/x-diff","content":"https://issues.apache.org/jira/secure/attachment/12425525/193-6-inverted-filter.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12425429","id":"12425429","filename":"193-6-inverted-filter.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-19T02:02:58.067+0000","size":2536,"mimeType":"text/x-diff","content":"https://issues.apache.org/jira/secure/attachment/12425429/193-6-inverted-filter.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12426473","id":"12426473","filename":"193-6-repair-explanation-and-node-rename.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-12-01T00:08:59.507+0000","size":12904,"mimeType":"text/x-patch","content":"https://issues.apache.org/jira/secure/attachment/12426473/193-6-repair-explanation-and-node-rename.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12425697","id":"12425697","filename":"193-7-disable-caching-and-fix-minimum-token.diff","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-21T02:47:05.911+0000","size":18223,"mimeType":"text/x-diff","content":"https://issues.apache.org/jira/secure/attachment/12425697/193-7-disable-caching-and-fix-minimum-token.diff"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12425937","id":"12425937","filename":"193-breakdown.txt","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-24T04:19:52.464+0000","size":1172,"mimeType":"text/plain","content":"https://issues.apache.org/jira/secure/attachment/12425937/193-breakdown.txt"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12425430","id":"12425430","filename":"193-breakdown.txt","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-19T02:02:58.107+0000","size":1488,"mimeType":"text/plain","content":"https://issues.apache.org/jira/secure/attachment/12425430/193-breakdown.txt"},{"self":"https://issues.apache.org/jira/rest/api/2/attachment/12424697","id":"12424697","filename":"mktree-and-binary-tree.png","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-12T04:40:55.331+0000","size":81819,"mimeType":"image/png","content":"https://issues.apache.org/jira/secure/attachment/12424697/mktree-and-binary-tree.png"}],"customfield_12312340":null,"aggregatetimeestimate":null,"customfield_12312022":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12310921":null,"customfield_12310920":"91015","summary":"Proactive repair","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"subtasks":[],"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"customfield_12310291":null,"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"customfield_12311024":null,"customfield_12311420":null,"customfield_12311421":null,"environment":null,"customfield_12311020":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"startAt":0,"maxResults":58,"total":58,"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12717914","id":"12717914","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"body":"To start with the good news: one thing which may seem on the face of it to be a problem, isn't really.  That is, how do you get nodes replicating a given token range to agree where to freeze or snapshot the data set to be repaired, in the face of continuing updates?  The answer is, you don't; it doesn't matter.  If we repair a few columnfamilies that don't really need it (because one of the nodes was just a bit slower to process an update than the other), that's no big deal.  We accept that and move on.\r\n\r\nThe bad news is, I don't see a clever solution for performing broad-based repair against the Memtable/SSTable model similar to Merkle trees for Dynamo/bdb.  (Of course, that is no guarantee that none such exists. :)\r\n\r\nThere are several difficulties.  (In passing, it's worth noting that Bigtable sidesteps these issues by writing both commit logs and sstables to GFS, which takes care of durability.  Here we have to do more work in exchange for a simpler model and better performance on ordinary reads and writes.)\r\n\r\nOne difficulty lies in how data in one SSTable may be pre-empted by another.  Because of this, any hash-based \"summary\" of a row may be obsoleted by rows in another.  For some workloads, particularly ones in which most keys are updated infrequently, caching such a summary in the sstable or index file might still be useful, but it should be kept in mind that in the worst case these will just be wasted effort.\r\n\r\n(I think it would be a mistake to address this by forcing a major compaction -- combining all sstables for the columnfamily into one -- as a prerequisite to repair.  Reading and rewriting _all_ the data for _each_ repair is a significant amount of extra I/O.)\r\n\r\nAnother is that token regions do not correspond 1:1 to sstables, because each node is responsible for N token regions -- the regions for which is is the primary, secondar, tertiary, etc. repository for -- all intermingled in the SSTable files.  So any precomputation would need to be done separately N times.\r\n\r\nFinally, we can't assume that sstable or even just row key names will fit into the heap, which limits the kind of in-memory structures we can build.\r\n\r\nSo from what I do not think it is worth the complexity to attempt to cache per-row hashes or summaries of the sstable data in the sstable or index files.\r\n\r\nSo the approach I propose is simply to iterate through the key space on a per-CF basis, compute a hash, and repair if there is a mismatch.  The code to iterate keys is already there (for the compaction code) and so is the code to compute hashes and repair if a mismatch is found (for read repair).  I think it will be worth flushing the current memtable first to avoid having to take a read lock on it.\r\n\r\nEnhancements could include building a merkle tree from each batch of hashes to minimize round trips -- although unfortunately I think that is not going to be a bottleneck for Cassandra compared to the hash computation -- and fixing the compaction and hash computation code to iterate through columns in a CF rather than deserializing each ColumnFamily in its entirety.  These could definitely be split into separate tickets.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"created":"2009-06-10T04:44:28.136+0000","updated":"2009-06-10T04:44:28.136+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12719376","id":"12719376","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"body":"to be specific, for key iteration, start with ColumnFamilyStore.getKeyRange.\r\n\r\nfor the hashing, look at StorageProxy.strongRead -- first it sends a \"digest\" message to the non-primary nodes; this computes a hash, and if there is a mismatch then it does a repair step in the catch block.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"created":"2009-06-15T03:07:13.031+0000","updated":"2009-06-15T03:07:13.031+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12719386","id":"12719386","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"body":"IRC: i am considering storing the hashes for an SSTable in another SSTable, to prevent them from being recalculated\r\n\r\nIf it were useful to have the per-sstable hashes precalculated, we could keep them in the SSTable itself (with the appropriate format change).  The problem is, that we need to hash the entire row, which means merging columns from multiple sstables, which means no per-sstable hash will be useful.\r\n\r\nUnless I am missing something, in which case, hurrah! :)","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"created":"2009-06-15T04:03:29.997+0000","updated":"2009-06-15T04:03:29.997+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12722050","id":"12722050","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"> IRC: i am considering storing the hashes for an SSTable in another SSTable, to prevent them from being recalculated \r\nI've reconsidered this portion: this would waste a ton of CPU time hashing something that we may never need.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-06-19T22:03:56.632+0000","updated":"2009-06-19T22:03:56.632+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12722054","id":"12722054","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"The current plan is for an AntiEntropyService per table to maintain a Merkle Tree per column family.\r\n\r\nThe tree will be implemented as a full, randomized binary tree in memory (a ''Treap'': http://en.wikipedia.org/wiki/Treap ), where every item in the tree represents a range bounded by the dht.Tokens of its left and right neighbors. By placing a bound on the total number of nodes in the tree, we can limit the memory usage. We can compact or split ranges in the tree by removing or adding Tokens. The algorithm for deciding which ranges to compact/split will be described below.\r\n\r\nWhen a write comes in for a given table, we will place 'invalidation' operations in a queue for all affected column families. The ExecutorService for the table will read from the queue and perform the 'invalidations' as fast as it can. For a given Key/Token, if any column family tree is marked as 'invalid', the entire row needs to be read from disk and repaired (at some point in the future).\r\n\r\nAn 'invalidation' operation does a binary search in the Merkle Tree and marks the matching range as 'invalid', deleting its hash. We will also take advantage of this step to optimize the tree: A ''Treap'' stores a random priority (P) on each node, and by generating a random P' and replacing P for a node iff P' < P as we invalidate it, more frequently invalidated ranges will shift to the top of the tree.\r\n\r\nThe AEService maintaining the tree for a table will occasionally need to exchange portions of the tree with other nodes. In order to do this, subtrees that both nodes are interested in from all CF trees will have to be locked long enough to recalculate all 'invalid' children, and then the locks can flow down the tree as progressively smaller ranges are exhanged. Doing this locking efficiently is going to be interesting (aka: I haven't thought about it).\r\n\r\nImplementing the exchange between nodes is blocked by CASSANDRA-242 because in order to align the subtrees on different nodes, we need to be able to deterministically split two ranges.\r\n\r\nIn order to fill in 'invalid' ranges in the tree, the MerkleTree will provide an operation that builds a list of invalid ranges to be fetched from disk. During this step, we can also compact/split ranges. Because of our Treap maintenance, frequently invalidated ranges will be nearer to the top of the tree, and stable ranges will be closer to the bottom. By compacting the deepest N leaves and expanding the shallowest N, we can minimize the size of the ranges that are affected by invalidations in the future.\r\n\r\nGiven the list of 'invalid' ranges (and pointers directly to the tree nodes), the AEService will fetch the ranges from the current MemTable and SSTables for the CF, hash them, and store the hashes into the relevant nodes. After this operation, we can recursively calculate hashes for inner nodes.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-06-19T22:09:00.907+0000","updated":"2009-06-21T04:16:29.164+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12722055","id":"12722055","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"body":"It sounds like I could wrap my head around this if I thought hard about it for a few days like you have. :)\r\n\r\nIs there any way this can be split up into independent changes that are easily understood and reviewed?\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"created":"2009-06-19T22:11:43.073+0000","updated":"2009-06-19T22:11:43.073+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12722058","id":"12722058","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"Definitely... since the tree maintenance is implemented as a separate service, we can implement maintaining the tree first, and then think about how to exchange portions later.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-06-19T22:14:50.242+0000","updated":"2009-06-19T22:14:50.242+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12722062","id":"12722062","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"body":"That's true.  That's a logical division.\r\n\r\nI'm still a little scared by the performance implications of basically doing mini read-only compactions to keep the tree accurate.  I'm going to mark this as requiring CASSANDRA-234.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"created":"2009-06-19T22:20:53.511+0000","updated":"2009-06-19T22:20:53.511+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12722300","id":"12722300","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"body":"Note: it's difficult to tell what's changed when you edit a large comment.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"created":"2009-06-21T04:23:52.061+0000","updated":"2009-06-21T04:23:52.061+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12722860","id":"12722860","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"So after a little bit of discussion, we decided to drop the Treap idea, and go with a B+Tree instead. The Treap would have been slightly faster for invalidations because of the priority-optimization, but it would be much less memory efficient because of excess inner nodes. Also, the invalidation count can just as easily be represented as a counter on each leaf node as it could have been by the height of the leaf in the Treap.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-06-22T22:11:23.927+0000","updated":"2009-06-22T22:11:23.927+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12723089","id":"12723089","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"body":"The more I think about this the less convinced I am that the partially-invalidated live tree is going to be worth the overhead of maintaining it (and initializing it on startup).\r\n\r\nIf you instead just create a mini-merkle tree from the first N keys and exchange that with the replica nodes, then repeat for the next N, you still get a big win on network traffic (which is the main concern here) but you have no startup overhead, no complicated extra maintenance to perform on insert, better performance in the worst case and (probably) in the average case, since you are avoiding random reads in favor of (a potentially greater number of) streaming reads which assuming a constant workload profile (i.e. the same proportion of keys being overwritten) is always going to be a win for the streaming case.\r\n\r\nImplementation detail: you'd want to add an internal message [merkle startkey] where startkey is initially \"\" and after each iteration you update it to the N'th key _after_ merging any missing ones.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"created":"2009-06-23T14:33:06.196+0000","updated":"2009-06-23T14:33:06.196+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12723151","id":"12723151","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"> The more I think about this the less convinced I am that the partially-invalidated live tree is going to be worth the overhead of maintaining it (and initializing it on startup). \r\nThere is no need to initialize the tree on startup: it can be done lazily when the first tree \r\nexchange requests come in.\r\n\r\n> If you instead just create a mini-merkle tree from the first N keys and exchange that with the replica nodes, then repeat for the next N, you still get a big win on network traffic (which is the main concern here)...\r\nYes, network traffic is important, but the whole point of maintaining the tree in memory is that it prevents us from having to read entire SSTables from disk in order to do repairs (similar to BloomFilters for random lookups). Any portions of the tree that survive (which should be large portions, assuming we do invalidations correctly) mean that we can use the SSTable index to seek() past chunks of the file.\r\n\r\n> but you have no startup overhead, no complicated extra maintenance to perform on insert, better performance in the worst case and (probably) in the average case, since you are avoiding random reads in favor of (a potentially greater number of) streaming reads...\r\n * No startup overhead necessary,\r\n * B+Tree invalidations will only involve marking a leaf node invalid: aka, do a lookup and increment a counter,\r\n * There won't be any random reads... I'm not sure where you read that: in order to validate regions of the tree we will be iterating over the keys in the CF in sorted order, skipping regions that are valid.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-06-23T16:04:52.352+0000","updated":"2009-06-23T16:04:52.352+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12723154","id":"12723154","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"Ah, I see what you mean regarding the random reads. I've mostly been thinking about finding ranges to repair, rather than the actual repair steps.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-06-23T16:10:16.714+0000","updated":"2009-06-23T16:10:16.714+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12723572","id":"12723572","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"body":"If there is no tree-building phase on startup, what is the behavior after a fresh start if a Repair phase begins (either automatically or from human intervention)?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"created":"2009-06-24T14:11:12.924+0000","updated":"2009-06-24T14:11:12.924+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12723639","id":"12723639","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"> ...what is the behavior after a fresh start if a Repair phase begins?\r\nWell, you would have a single large invalid range (or some number of smaller ranges summing to the full range), which could be fetched sequentially from disk.\r\n\r\nRather than being completely lazy, (depending on how much extra load it would cause) we could hook the AEService into compactions that are happening for other reasons, so that before the compaction begins, the compactor fetches the current list of invalid ranges and fills them in based on the merged data. I'm not sure how much of a win this would be, since we probably don't want to slow down compactions, but if they aren't CPU bound, then it shouldn't hurt.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-06-24T17:14:55.505+0000","updated":"2009-06-24T17:14:55.505+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12723647","id":"12723647","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"body":"So you are basically looking at doing a bulk scan no matter what.\r\n\r\nThen the question becomes, is it worth trying to keep (partial) results of that scan in memory to avoid re-doing the work next time around.  If writes are randomly distributed across the range then ISTM the answer is a clear No, but I'm not sure how close real-world workloads would come to that.\r\n\r\nDoes it make sense to start with a non-caching version like I describe?  I think that a lot of the functionality implemented would be reusable, and it would give us a useful starting point to give us a better feel for the additional complexity your \"full\" version would entail.\r\n\r\nIncidently, I don't think we should worry about the kind of locking you mentioned.  The point of the merkle tree is to save us from exchanging 90% of keys; if we don't lock and the trees end up slightly de-synced and we exchange a few keys at the edges that we wouldn't have to with a \"perfect\" algorithm, that is a price I'm happy to pay for a much less complicated solution.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"created":"2009-06-24T17:29:48.814+0000","updated":"2009-06-24T17:29:48.814+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12723696","id":"12723696","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"> Then the question becomes, is it worth trying to keep (partial) results of that scan in memory to avoid re-doing the work next time around. If writes are randomly distributed across the range then ISTM the answer is a clear No, but I'm not sure how close real-world workloads would come to that. \r\nYou're right that the tree is basically a 'range hash cache', but I don't think that writes will be randomly distributed. Especially since we allow complex values, I think people are more likely to have 'hot' keys. Adding in the OrderPreservingPartitioner makes it even more likely to have hot ranges.\r\n\r\n> Does it make sense to start with a non-caching version like I describe?\r\nPerhaps: we could initialize a new MerkleTree at repair time, use the range hashing API I've described, and throw it away at the end of the repair. Next, we could implement maintaining/invalidating the tree between repairs. I'm not sure how much simpler this is (since the invalidation of ranges is probably the simplest part of the whole deal).\r\n\r\n> Incidently, I don't think we should worry about the kind of locking you mentioned.\r\nYou're right: since a separate thread/agent/executor is maintaining the tree, the locking should be completely unnecessary. Whenever we're performing a repair, we're not accepting invalidations, so we're looking at a snapshot of the tree.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-06-24T19:27:06.085+0000","updated":"2009-06-24T19:27:06.085+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12733076","id":"12733076","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"I'm making steady progress on this ticket. So far, the work has all been on implementing the merkle tree data structure, but I'd like to start thinking about integrating the structure soon.\r\n\r\nI've been working in the (misnamed) branch 'binary-merkle' on http://github.com/stuhood/cassandra-anti-entropy/. I may submit a patch here containing just the data structure sometime soon, but it still has a wart that I'm not happy about.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-07-19T21:38:08.859+0000","updated":"2009-07-19T21:38:08.859+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12737390","id":"12737390","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"Here is a first cut of the MerkleTree datastructure. There are a few issues that still need work:\r\n\r\n * TreeRange.validate(Iterator) will need to take an iterator over ColumnFamily (Token,hash) pairs. It currently takes an iterator over Tokens, and uses a dummy hash value,\r\n * We're still blocked by CASSANDRA-242: this patch contains a hacked implementation of Range.midpoint(Token, Token) that only works with BigIntegerToken.\r\n\r\nI'll start looking at CASSANDRA-242 for now so we can actually gets this integrated.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-07-31T01:33:26.577+0000","updated":"2009-07-31T01:33:26.577+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12759990","id":"12759990","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"I've been working on this ticket a bit more in the past few days:\r\n * Added o.a.c.service.AntiEntropyService - Maintains trees for each CF, and accepts invalidations when values change.\r\n\r\nStill TODO:\r\n * Implement TreeRequestVerbHandler/TreeResponseVerbHandler - The AEService on a first endpoint will periodically wake up and send a TreeRequest to a replica. The replica endpoint will handle the TreeRequest by validating one or all of its MerkleTrees, and responding with a TreeResponse. Handling the TreeResponse on the first endpoint will involve validating the local tree, and then comparing the two trees.\r\n   * Validation is the only part that is fuzzy here: we need to iterate over keys in each CF (essentially, a major compaction, except that we can skip processing for anything that is still valid in the tree).\r\n * Begin implementing the actual repair step - There isn't a design for this part yet: any thoughts would be appreciated. The output of the TreeRequest/TreeResponse conversation will be a list of ranges in a given CF that disagree between the two endpoints.\r\n\r\nEDIT: The code is still located at: http://github.com/stuhood/cassandra-anti-entropy/","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-09-27T05:59:25.712+0000","updated":"2009-09-27T06:00:25.172+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12759994","id":"12759994","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"More thoughts (in no particular order, and probably disagreeing with previous decisions):\r\n 1. Since Memtables are always flushed after a bounded period (I think?) it is possible to completely ignore them.\r\n 2. Due to 1, invalidating a range for every Memtable change is dumb/overkill. It would be much more efficient to only invalidate during minor compactions.\r\n 3. Again, due to 1, we only care about the data affected during a major compaction, so we can validate the tree during every major compaction.\r\n\r\nIf we hook tree validation into major compactions:\r\n * Handling TreeRequests/TreeResponses would be queued until the next major compaction,\r\n * The compactor would acquire a lock on the tree for the CF, validate it, and then handle outstanding TreeRequests/TreeResponses.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-09-27T06:47:01.212+0000","updated":"2009-09-27T06:47:01.212+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12770960","id":"12770960","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"I've split out the task of implementing the range repair into CASSANDRA-520 so that we can gain some concurrency.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-10-28T14:59:40.360+0000","updated":"2009-10-28T14:59:40.360+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12773720","id":"12773720","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"This one should finally be ready for review! The patchset:\r\n 1. Prepares to add the MerkleTree datastructure,\r\n 2. Adds the datastructure,\r\n 3. Prepares to add AntiEntropyService,\r\n 4. Adds the service.\r\n\r\nThere should only be one FIXME in the patch, which refers to CASSANDRA-520.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-05T00:06:45.432+0000","updated":"2009-11-05T00:06:45.432+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12775105","id":"12775105","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"body":"Started reviewing this patch. Here is a high-level question. From the code, the process roughly looks as the follows:\r\n1. Each node N periodically computes a Merkle tree for rows in each new SSTable generated through compaction.\r\n2. The Merkle tree is sent and registered to other nodes that share key ranges with N.\r\n3. The locally computed Merkle tree will be compared with those registered remote Merkle trees. If there is any difference, trigger a repair.\r\n\r\nSince compaction is triggered independently at each node, the rows in two compacted SSTables generated in two neighboring nodes are unlikely to match. Won't the above approach trigger too many unnecessary repairs?\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"created":"2009-11-09T20:05:45.803+0000","updated":"2009-11-09T20:05:45.803+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12775448","id":"12775448","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"body":"it's major compaction, not just \"compaction,\" right?  major compactions are never done automatically, so if we assume they are done by cron or dsh or some other similarly \"reasonably synchronous\" method it should be fine.  right?  (although it should flush first, dunno if it does.)","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"created":"2009-11-10T15:27:31.869+0000","updated":"2009-11-10T15:27:31.869+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12776519","id":"12776519","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"body":"First, thanks Stu for this big patch. This is a lot of work. Here are some review comments.\r\n1. The high level question. When should the Merkle tree be computed? The patch piggybacks the computation on a regular compaction. Even if it's moved to major compaction, it's still not enough. This is because there is an upper limit on file size. Therefore, not all sstables are necessarily read during a major compaction, which means the Merkle tree may not see all keys in a particular key range.\r\n\r\nOne approach is to explicitly iterate through keys on all sstables in a particular range, compute the Merkle tree, send the Merkle tree to replicas. Each replica then computes its own Merkle tree and do the comparison. We can trigger this process through a nodeprobe command.\r\n\r\nI spent quite some time reading through the code and I am still confused in several places. Perhaps some more text description on each main method (e.g, split, validate, difference) will help.\r\n\r\n2. It's not clear to me exactly how splitting in Merkle tree works.\r\n2.1 In MerkleTree.Node.insert, why do you increment the depth of the left child even when the node doesn't split?\r\n2.2 In the same function, if the node does split, where is the code to shrink the children list in the splitted node to half?\r\n2.3 In the same function, do you have to keep calling invalidate during insertion? It seems to me that it would be simpler if you first split the tree to what you want, then make a pass of the tree to invalidate all nodes before computing the hashes.\r\n\r\n3. I am not exactly clear on how the validator works.\r\n3.1 In Validator.add, there is comment about generating a new range. However, no code does that.\r\n3.2 In TreeRange.validateHelper, you are trying to compute the hash for a set of rows in a range. Why do you have to compute multiple hash values recursively?\r\n\r\n4. I need some text description to really follow the Differencer code.\r\n\r\n5. The Hashable class is confusing. By its name, I expect it to be really about just the hash. However, the comparator is actually on token. HashableToken is probably a better name.\r\n\r\n6. The repair logic is missing in Differencer.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"created":"2009-11-11T17:19:51.746+0000","updated":"2009-11-11T17:19:51.746+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12776600","id":"12776600","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"Thanks a lot for the review Jun! I'll respond to #1 in a separate comment, since it is a design issue that still needs a lot of discussion.\r\n\r\n> 2\r\n> 2.1 In MerkleTree.Node.insert, why do you increment the depth of the left child even when the node doesn't split?\r\nNode.insert() is only used during split operations (perhaps it is misnamed... but this is not quite a traditional B-Tree). The child to the left is the node that contains the Token we were splitting on, and whenever we split a range we increment its depth to indicate how far it is from being a complete (0,0] range. I'll add a comment to this effect.\r\n\r\n> 2.2 In the same function, if the node does split, where is the code to shrink the children list in the splitted node to half?\r\nNode.insert() uses List.subList() and List.clear() inline to take half of its neighbor's children.\r\n\r\n> 2.3 In the same function, do you have to keep calling invalidate during insertion?\r\nThe original design assumed that the tree was going to live for a while in memory, and be maintained between repair sessions, so the split operation is intended to be used on a tree that might be partially valid. We might be able to have the initial building of the tree skip this check somehow, but I don't think the 'hash == null? hash = null;' check is too intensive.\r\n\r\n> 3\r\n> 3.1 In Validator.add, there is comment about generating a new range. However, no code does that.\r\nThe \"private MerkleTree.TreeRangeIterator ranges\" variable is an iterator generated by the MerkleTree: it iterates in order over all of the ranges in the tree that have null hashes.\r\n\r\n> 3.2 In TreeRange.validateHelper [...] Why do you have to compute multiple hash values recursively?\r\nThe reasoning here is that a MerkleTree is supposed to be a sparse representation of a 'perfect/complete' binary tree. Each leaf of the perfect tree represents a hashed range, and each inner node represents a binary hash of its two children. The perfect tree is of depth \"hashdepth\", so when validateHelper() reaches the maximum/hashdepth, it is in one of the leaves of the perfect tree, and rows are hashed sequentially there. <EDIT comment=\"Ignore everything in in this tag\">If a single call to validate() starts in a TreeRange that is at depth == maxdepth, then what is stored in the MkT.Node is the value of a perfect leaf, otherwise, the MkT.Node is storing the value of a perfect inner node.</EDIT>\r\n\r\nI'll probably copy and past this exact explanation into the next revision =x\r\n\r\n> 4. I need some text description to really follow the Differencer code.\r\nI'll make sure this gets in the next revision, but basically:\r\n 1. It recurses using midpoint as long as both trees have the resolution to continue, and are not equal.\r\n 2a. If it finds a range that has only one invalid child, it adds that child range, since that is the smallest possible invalid range contained in the parent.\r\n 2b. Otherwise, if both children are invalid (and since it can't recurse deeper), the parent range is entirely invalid, and recursion keeps rolling up until 2a is met.\r\n\r\n> 5. The Hashable class is confusing.\r\nYou're right: I definitely should have worried more about overloading the word \"hash\": I'll see what I can do about this one.\r\n\r\n> 6. The repair logic is missing in Differencer.\r\nThe repair logic is the one FIXME for this ticket: CASSANDRA-520 deals with implementing the actual repair logic.\r\n\r\nThanks again for taking time out to look at this! ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-11T19:37:23.284+0000","updated":"2009-11-12T04:52:59.311+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12776601","id":"12776601","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"> 1. The high level question. When should the Merkle tree be computed?\r\nI see that you're right about major compactions not always involving all sstables: I'll make Validation dependent on all sstables being involved. At some point, we need to make a decision allowing repairs to run more frequently, but I don't think it should block this issue.\r\n\r\n> Won't the above approach trigger too many unnecessary repairs?\r\nWe definitely want to minimize the time lag between the tree being generated on one node, and then on another.\r\n\r\nAbsolutely optimal would be to have them begin generating the trees at the exact same time, immediately after a flush. I don't think that is really feasible though.\r\n\r\n> One approach is to explicitly iterate through keys on all sstables...\r\nAdding this operation seems like a good idea: effectively, it is a 'noop' major compaction (which would still need to acquire compaction locks), which doesn't actually output the merged data.\r\n\r\nGoing back to the \"triggering too many repairs\" problem: if repair was running independently of other compactions, perhaps it could choose to only \"noop-compact\" sstables that existed when the tree was generated on the other node? Rather than stopping time, or trying to perform the validation in sync, we would only repair the older data. With this approach, we might end up, for example, repairing a key (based on older sstables) that is deleted by newer sstables.\r\n\r\n----\r\n\r\nAgain, thanks for the review! I'll start incorporating these changes tonight, and think more about the possibility of repairing only older sstables.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-11T19:39:25.523+0000","updated":"2009-11-11T19:39:25.523+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12776780","id":"12776780","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"body":"2.1 Still confused. So node.depth doesn't mean the depth of the node in the tree?\r\n\r\n3.1 The ranges don't change after the iterator is generated, right? But inside the while loop in Validator.add, there is comment about adding a new range. So, are you really adding a new range there or the comment is wrong?\r\n\r\n3.2 Why is Merkle tree a binary tree? I thought it's an n-ary tree since you can specify the order of each node.\r\n\r\nSince a leaf node corresponds to a single range, why do you need a list of hashes? I thought each leaf node maintains a single hash value for rows its range and each inner node maintains a single hash that is the logical AND of the hashes of all its children. Is this not correct?\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"created":"2009-11-12T01:18:32.209+0000","updated":"2009-11-12T01:18:32.209+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12776835","id":"12776835","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"> 3.2 Why is Merkle tree a binary tree? I thought it's an n-ary tree since you\r\n> can specify the order of each node.\r\nThis MerkleTree data structure is an n-ary tree that represents a perfect binary hash tree.\r\n\r\n> Since a leaf node corresponds to a single range, why do you need a list of hashes?\r\n> I thought each leaf node maintains a single hash value for rows its range and each\r\n> inner node maintains a single hash that is the logical AND of the hashes of all its\r\n> children. Is this not correct?\r\nThat is not correct... I'm sorry, I mispoke above... I'll edit that comment and remove the bad information. It is the leaves of the perfect tree which contain sequentially hashed values, and the inner nodes of the perfect tree contain the logical AND hash of their children.\r\n\r\nI'm attaching an example. This perfect binary tree has a max depth of 2, so the maximum depth of a MkT.Hash in the MkTree representing it is 2 as well. In this case though, the MkTree has only been split twice, so it contains a single MkT.Leaf and three MkT.Hashes. Each MkT.Hash represents a node from the perfect tree, but they are not all at the same depth in the tree. MkT.Nodes will not always correspond to a node from the binary tree (because the orders are not equal), but when they do, we can cache a value in that MkT.Node.\r\n\r\nThe important thing to notice, is that if the MkTree had been split at 8 and 12 instead of 4 and 8, it would still represent the same perfect binary tree, which is why we can compare MkTrees generated by different Cassandra endpoints.\r\n\r\nThe MkTree.Hash for (8, 0] represents an inner node in the perfect tree, so in order to calculate it in the same manner no matter how a Cassandra endpoint chooses to split the MkTree, during validateHelper() we always generate a perfect tree down to the maximum hash depth, sequentially hash rows into the perfect leaves, and then calculate the logical AND back up to the range needed by validate().\r\n\r\n> 2.1 Still confused. So node.depth doesn't mean the depth of the node in the tree?\r\nAll depths in the code refer to the depth of the perfect binary tree that a Node or Hash represents. This is why MkT.Nodes can only occasionally contain hash values: it's fairly common for a N-ary tree to contain a node representing a range that isn't represented by a single node in a binary tree.\r\n\r\n> 3.1 The ranges don't change after the iterator is generated, right? But inside the\r\n> while loop in Validator.add, there is comment about adding a new range.\r\nThe comment says \"generate a new range\": it is asking for TreeRangeIterator.next(), which hides the generation of the next range that needs to be hashed, and returns it.\r\n\r\n----\r\n\r\nI hope this helps! Thanks again for checking it out.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-12T04:40:55.502+0000","updated":"2009-11-12T04:40:55.502+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12777115","id":"12777115","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"body":"Now I start to understand the code a bit better. A couple of other questions:\r\na. Why do you want to use an n-ary tree to represent a binary tree? Why can't you just implement Merkle tree as an in-complete binary tree itself? This way, there is less confusing about whether a node refers to one in the n-ary tree or the binary tree.\r\nb. Suppose + is the bit-wise AND btw 2 hash values and you compute the hash of a range as the sum of the hash of each row in the range. Then, it seems that you can compute the hash of a range directly (since now + is commutative and transitive), without a bottom-up traversal from the leaves of the complete binary tree. Wouldn't this be simpler?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"created":"2009-11-12T18:48:50.128+0000","updated":"2009-11-12T18:48:50.128+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12777137","id":"12777137","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"> a. Why do you want to use an n-ary tree to represent a binary tree?\r\nThe main reason was due to memory concerns... for 256 subranges, an order 256 B-Tree only needs 1 inner node (total 257), while a binary tree would need 127 inner nodes (total 383). Also, in order to get reasonable performance out of a binary tree over its lifetime, you would probably want to implement a self balancing tree, which isn't much simpler than a B-Tree. Finally, B-Trees are arguably faster than binary tree implementations: http://idlebox.net/2007/stx-btree/stx-btree-0.8.3/doxygen-html/speedtest.html\r\n\r\n> b. Suppose + is the bit-wise AND [...] you can compute the hash of a range directly (since now + is commutative and transitive),\r\n> without a bottom-up traversal from the leaves of the complete binary tree.\r\nAck, this was more of me glossing over details: we don't use AND or any other commutative operations in the tree, since it would be more likely to cause hash collisions (switched subtrees might compare equally).\r\n\r\nAll hashing is accomplished by a single method: Hashable.hash(byte[], byte[]), which is currently implemented using MD5.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-12T19:20:16.955+0000","updated":"2009-11-12T19:20:16.955+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12777156","id":"12777156","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"body":"Another complexity arises because you assume that the ranges in 2 different Merkle trees are different. Why can't you first build the key ranges from a sample of the keys in one node and then reuse those key ranges to build a Merkle on every replica? That would simplify both the computation and the diff of the hash values.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"created":"2009-11-12T20:08:40.663+0000","updated":"2009-11-12T20:08:40.663+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12777171","id":"12777171","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"> Another complexity arises because you assume that the ranges in 2 different Merkle trees are different.\r\nThis is another decision that arose from the idea of maintaining the tree over a longer period by invalidating ranges, and only compacting the ranges that had changed recently. The replicas would end up with divergent splits in the trees. If we go back to assuming that we never want to maintain a tree between compactions, then compact() and invalidate() could be removed, and differences() could be simplified.\r\n\r\nBut considering the fact that we are hesitant to trigger a major compaction for every repair, maintaining the tree between repairs becomes a more interesting option.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-12T20:33:03.887+0000","updated":"2009-11-12T20:33:03.887+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12777586","id":"12777586","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"body":"Now that I understood how the code really works, I don't have any big issue with the patch. Some comments below:\r\n1. To get us started, can we trigger a Merkle tree repair manually from nodeprobe. Something like the following:\r\n    trigger Merkle tree repair for a Keyspace/CF on a node from nodeprobe\r\n    the range to be fixed is (token from left node, token from this node]\r\n    each replica of this range computes Merkle tree independently, in parallel, through a full scan of all SSTables.\r\n    when done, Merkle trees are compared and repairs triggered, if necessary.\r\n4. The code needs to be better documented. You need to explain the n-ary tree, the complete binary tree and the relationship btw them. Attach the diagram you uploaded will be useful.\r\n5. You need to name variables and methods better. For example, MerkleTree.SELF and  MerkleTree.CHILD are not very intuitive. How about FullyInconsisten and PartiallyInconsistent. Ditto for ChildMatch.container().\r\n6. In MerkleTree.difference(), shouldn't you add a case that returns an empty diff when the trees are consistent?\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"created":"2009-11-13T17:58:05.313+0000","updated":"2009-11-13T17:58:05.313+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12778749","id":"12778749","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"> 1. To get us started, can we trigger a Merkle tree repair manually from nodeprobe.\r\nI got most of this working tonight: the code needed some serious cleanup in order to not duplicate effort or send trees back and forth in an infinite loop.\r\n\r\n> 4. The code needs to be better documented.\r\nNext patch should be improved in this area.\r\n\r\n> 5. You need to name variables and methods better. For example...\r\nThese were particularly bad... you're right. I've changed them.\r\n\r\n> 6. In MerkleTree.difference(), shouldn't you add a case that returns an empty diff when the trees are consistent?\r\nGood catch.\r\n\r\nI'll wrap up a new version of this patch on Tuesday before COB, I promise.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-17T07:28:34.521+0000","updated":"2009-11-17T07:28:34.521+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12779331","id":"12779331","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"Here is a rebased version of the patchset which should resolve the issues found during Jun's review.\r\n\r\nThere are significant changes in patch 4: the list of \"observers\" that were waiting for valid trees to be generated was too abstract. Instead, we keep a Cachetable of valid trees, and when an endpoint receives a tree from another node (via TreeResponse) or generates a tree locally, it tries to 'rendezvous' with trees from appropriate neighbors. See uses of AntiEntropyService.register().\r\n\r\nThere is also a new patch 5 to add a manual manual repair operation to nodeprobe, which sends out TreeRequests to all natural endpoints for the target nodes token. The nodeprobe target is the 'initiator' for the TreeRequests, so once the trees are generated on their respective nodes, they are broadcast out as TreeResponses, and they will rendezvous on the target/initiator to be differenced.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-18T06:36:04.148+0000","updated":"2009-11-18T06:36:04.148+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12779796","id":"12779796","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"Adding one more patch: I did some system level testing today and noticed a really dumb bug that slipped through unit testing. Other than that, the system tests look good. I feel good about this patchset being ready for merge.\r\n\r\n(The filter to remove the local node from the list of natural endpoints was inverted, but the Gossiper only has one endpoint in tests, which was hiding the fact that we weren't caching a generated tree locally.)","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-19T02:02:58.112+0000","updated":"2009-11-19T02:02:58.112+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12779854","id":"12779854","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"I noticed two fundamental problems with the Cachetable of trees in the current patchset. I'm going to submit a new version tomorrow.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-19T07:47:17.642+0000","updated":"2009-11-19T07:47:17.642+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12780266","id":"12780266","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"New version of patch 6 to resolve the Cachetable/rendezvous issues I noticed last night.\r\n\r\nI don't see any more bugs, but I did some testing with a table containing 10^6 keys, and a Readonly compaction took 2 minutes (!). Hopefully a little bit of profiling will expose the issue quickly, because I can understand that performance like that should prevent merging this patch. I'll try and get a new version out this evening.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-19T21:08:04.629+0000","updated":"2009-11-19T21:08:04.629+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12780443","id":"12780443","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"body":"It would be nice if the new code followed the style guide: http://wiki.apache.org/cassandra/CodeStyle","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"created":"2009-11-20T05:16:35.431+0000","updated":"2009-11-20T05:16:35.431+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12780894","id":"12780894","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"Alright, here is one final patch (7) that adds some tests for issues discovered in the last 2 days. The patchset is made up of the latest versions of patches 1 through 7.\r\n\r\nAll performance issues have been resolved: from my tests, the new default value of 64 for MerkleTree.RECOMMENDED_DEPTH is much more reasonable, and only adds 15% runtime to major compactions. The patch has been tested with all of the partitioners and stress.py.\r\n\r\nAdditionally, I fixed a bug due to the minimum token being sorted first in SSTables, while being contained in the last range of the MerkleTree. See the changes in Validator.add(row).\r\n\r\nThere was also one fundamental issue: we were using MD5 for the sequential hash of the perfect leaf nodes, but also for the binary hash of the perfect inner nodes. As Cliff of the Dynamite project warned me (ages ago) the inner nodes need to use an associative hash function if their values are going to be cached. The performance without caching is sufficient, and I didn't want to rush into picking an algorithm, so for now, caching is simply disabled, with a TODO mentioning that we should pick an algorithm.\r\n\r\nPlease take a look! I'd really like to get this in before 0.5. Thanks!","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-21T02:47:05.936+0000","updated":"2009-11-21T02:47:05.936+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12780899","id":"12780899","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"body":"\"the inner nodes need to use an associative hash function if their values are going to be cached\"\r\n\r\nhuh?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"created":"2009-11-21T03:01:35.363+0000","updated":"2009-11-21T03:01:35.363+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12780912","id":"12780912","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"EDIT: After a little more consideration, the caching bug had nothing to do with our hash function. It was a disconnect between the binary tree, and the b-tree we are using to store it. To be honest, I don't want to merge something so complex that even the person who created it still has trouble reasoning about it.\r\n\r\nI'm going to refactor the b-tree into a binary tree tomorrow.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-21T05:27:43.569+0000","updated":"2009-11-22T03:07:35.270+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12781484","id":"12781484","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"body":"While you are working on refactoring, do you think that you can do some anecdotal tests to see whether we lose any precision by simply using bitwise XOR to combine row hashes? Using XOR further simplifies how hash values for internal nodes are computed.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"created":"2009-11-23T17:17:48.694+0000","updated":"2009-11-23T17:17:48.694+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12781641","id":"12781641","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"> see whether we lose any precision by simply using bitwise XOR to combine row hashes\r\nDoing the math on this one was simpler than actually testing it: using a commutative hash function like XOR means that the number of possible inputs goes from being a Permutation of the leaves to being a Combination of the leaves (since a set of leaves in any order are equal).\r\n\r\nFor MD5 you have:\r\n(2^127)! / (2^127 - 2^16)! == number of possible permutations of 2^16 hashes of length 127\r\nAnd for XOR:\r\n(2^127)! / (2^16)! * (2^127 - 2^16)! == number of possible combinations of 2^16 hashes of length 127\r\n\r\nI wouldn't think it would be possible to notice such a small difference. Nonetheless, I think it is a moot point:\r\n\r\n> Using XOR further simplifies how hash values for internal nodes are computed.\r\nI don't think that using XOR is significantly more efficient. Because XOR is associative, it is possible to hash arbitrary sequential leaves together, which is impossible with MD5, but we never do this: all of our comparison happens on the boundaries defined by IPartitioner.midpoint(), so the tree structure containing predefined/precomputed values can contain any value required for comparison.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-23T21:46:07.332+0000","updated":"2009-11-23T21:46:57.111+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12781763","id":"12781763","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"Alright, here is a rebased version of the patchset containing only 5 patches again, which match up with the files changed in the earlier patchsets.\r\n\r\nSince the comment I made on Nov 21st, I refactored the MerkleTree structure into a binary tree, which dropped 750 lines from the patch, and made things much much clearer in general. Additionally, the MerkleTree now almost exclusively uses methods from dht.Range when searching for ranges, which removed a whole bunch special casing for the minimum token. No other files changed by more than 5-10 lines, and in general, I feel very happy to have admitted defeat on the b-tree idea.\r\n\r\nI've subjected this to system tests with all partitioners, and it passed with flying colors. Thanks!","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-24T04:19:30.791+0000","updated":"2009-11-24T04:19:30.791+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12782539","id":"12782539","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"body":"Some comments:\r\n10. AES.validator.prepare() requires buffering all keys in a node in memory. Can you push sampling into the key iterator?\r\n11. I still think using XOR to combine MD5 for each row is simpler. In MerkleTree.TreeRange.validateHelper(), you can compute the hash directly at each leaf node, instead of having to descend to hashdepth.\r\n12. Could you add some comments in MerkleTree that describe the flow of TableRepair?\r\n13. Some suggestions for notation changes : Node --> INode, Hash -- > LNode.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"created":"2009-11-25T18:12:47.881+0000","updated":"2009-11-25T18:12:47.881+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12782563","id":"12782563","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"body":"We use IFoo as a convention for denoting interfaces, so naming a class INode doesn't seem like a good idea to me.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"created":"2009-11-25T19:15:08.013+0000","updated":"2009-11-25T19:15:08.013+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12782754","id":"12782754","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"> 10. AES.validator.prepare() requires buffering all keys in a node in memory. Can you push sampling into the key iterator?\r\nIf I remember correctly, prepare() samples the SSTable indexes, which are themselves samples of the data on disk, and which are already sitting in memory: at worst, it should only create a new list, but not actually clone any keys.\r\n\r\n> 11. I still think using XOR to combine MD5 for each row is simpler. In MerkleTree.TreeRange.validateHelper(),\r\n> you can compute the hash directly at each leaf node, instead of having to descend to hashdepth.\r\nI really don't think XORing row hashes together is a good idea. Any permutation of the same set of hashes can cause a collision, and when it is row hashes that are being XOR'd, the chance of collision goes through the roof. Collisions in this context mean data won't get repaired, and will continue to not be repaired until someone writes to the affected range.\r\n\r\n> 12. Could you add some comments in MerkleTree that describe the flow of TableRepair?\r\nWill do.\r\n\r\n> 13. Some suggestions for notation changes : Node --> INode, Hash -- > LNode. \r\nBased on Jonathan's comment, maybe these should just go back to 'Inner' and 'Leaf'.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-11-26T05:47:58.917+0000","updated":"2009-11-26T05:47:58.917+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12783953","id":"12783953","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"Adding 193-6-repair-explanation[...] to address Jun's latest comments: no other changes.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-12-01T00:08:59.576+0000","updated":"2009-12-01T00:08:59.576+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12785095","id":"12785095","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"body":"10. I was referring to the following line, it basically returns all keys for a CF on a node.\r\n            List<DecoratedKey> keys = SSTableReader.getIndexedDecoratedKeysFor(cfpred, DKPRED);\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"created":"2009-12-03T00:55:47.164+0000","updated":"2009-12-03T00:55:47.164+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12785117","id":"12785117","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"body":"that's just the \"indexed\" keys (the 1/128 of keys we keep in memory to bsearch on), so I would think that would be fine","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=jbellis","name":"jbellis","emailAddress":"jbellis at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=jbellis&avatarId=18380","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jbellis&avatarId=18380","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jbellis&avatarId=18380","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jbellis&avatarId=18380"},"displayName":"Jonathan Ellis","active":true},"created":"2009-12-03T01:26:00.053+0000","updated":"2009-12-03T01:26:00.053+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12786221","id":"12786221","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"body":"The new patch looks good to me. I think this is ready to be committed unless someone objects.\r\n\r\nCould you rebase eveything to trunk? I can't seem to apply patch-6 to my local branch.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"created":"2009-12-04T22:59:44.010+0000","updated":"2009-12-04T22:59:44.010+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12786289","id":"12786289","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"Rebased: back down to only 5 patches.\r\n\r\nThanks!","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-12-05T01:31:53.795+0000","updated":"2009-12-05T01:31:53.795+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12786462","id":"12786462","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"body":"Committed. Thanks Stu.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=junrao","name":"junrao","emailAddress":"junrao at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jun Rao","active":true},"created":"2009-12-05T18:51:54.266+0000","updated":"2009-12-05T18:51:54.266+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12786463","id":"12786463","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"body":"Thanks a lot for the help Jun! Resolving.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuhood","name":"stuhood","emailAddress":"stuhood at twitter dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=stuhood&avatarId=10049","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuhood&avatarId=10049","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuhood&avatarId=10049","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuhood&avatarId=10049"},"displayName":"Stu Hood","active":true},"created":"2009-12-05T19:09:58.041+0000","updated":"2009-12-05T19:09:58.041+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12426050/comment/12786612","id":"12786612","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hudson","name":"hudson","emailAddress":"jira at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Hudson","active":true},"body":"Integrated in Cassandra #279 (See [http://hudson.zones.apache.org/hudson/job/Cassandra/279/])\r\n    add manual repair through NodeProbe; patched by Stu Hood, reviewed by junrao for \r\nadd AntiEntropyService; patched by Stu Hood, reviewed by junrao for \r\npreparation for AntiEntropyService; patched by Stu Hood, reviewed by junrao for \r\nadd Merkle tree; patched by Stu Hood, reviewed by junrao for \r\npreparation for Merkle tree; patched by Stu Hood, reviewed by junrao for \r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=hudson","name":"hudson","emailAddress":"jira at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Hudson","active":true},"created":"2009-12-06T12:35:08.287+0000","updated":"2009-12-06T12:35:08.287+0000"}]},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/CASSANDRA-193/votes","votes":1,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i0fxfr:"}}