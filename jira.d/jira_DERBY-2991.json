{"expand":"renderedFields,names,schema,transitions,operations,editmeta,changelog","id":"12375269","self":"https://issues.apache.org/jira/rest/api/latest/issue/12375269","key":"DERBY-2991","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/10594","id":"10594","key":"DERBY","name":"Derby","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=10594&avatarId=10122","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=10594&avatarId=10122","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=10594&avatarId=10122","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=10594&avatarId=10122"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10090","id":"10090","description":"DB related projects","name":"DB"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12313771","id":"12313771","description":"build: 764942, 14/Apr/09. Voted release: 28/Apr/09. Announced: 1/May/09","name":"10.5.1.1","archived":false,"released":true,"releaseDate":"2009-04-28"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12310220":"2007-08-03 12:34:53.686","customfield_12312322":null,"customfield_12312323":null,"customfield_12310420":"23364","customfield_12310222":"3_*:*_1_*:*_9875969499_*|*_1_*:*_1_*:*_41403782261_*|*_5_*:*_1_*:*_0","customfield_12312320":null,"customfield_12312321":null,"customfield_12312120":null,"customfield_12312121":null,"resolutiondate":"2009-03-18T16:32:00.350+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312326":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312324":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-2991/watchers","watchCount":10,"isWatching":false},"created":"2007-08-03T04:09:28.590+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12312334":null,"customfield_12310310":"22.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12312027","id":"12312027","description":"","name":"10.2.2.0","archived":false,"released":true,"releaseDate":"2006-12-19"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12312590","id":"12312590","description":"","name":"10.3.1.4","archived":false,"released":true,"releaseDate":"2007-08-10"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12313345","id":"12313345","description":"","name":"10.4.2.0","archived":false,"released":true,"releaseDate":"2008-09-05"}],"customfield_12311120":null,"customfield_12312330":null,"issuelinks":[{"id":"12317212","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12317212","type":{"id":"12310000","name":"Duplicate","inward":"is duplicated by","outward":"duplicates","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/12310000"},"inwardIssue":{"id":"12376342","key":"DERBY-3015","self":"https://issues.apache.org/jira/rest/api/2/issue/12376342","fields":{"summary":"Concurrent select and insert deadlock on index","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}},{"id":"12325191","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12325191","type":{"id":"12310000","name":"Duplicate","inward":"is duplicated by","outward":"duplicates","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/12310000"},"inwardIssue":{"id":"12409105","key":"DERBY-3961","self":"https://issues.apache.org/jira/rest/api/2/issue/12409105","fields":{"summary":"Deadlock detection fails for InternalTransaction","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}},{"id":"12322435","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12322435","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"inwardIssue":{"id":"12409105","key":"DERBY-3961","self":"https://issues.apache.org/jira/rest/api/2/issue/12409105","fields":{"summary":"Deadlock detection fails for InternalTransaction","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}},{"id":"12325260","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12325260","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"inwardIssue":{"id":"12427949","key":"DERBY-4273","self":"https://issues.apache.org/jira/rest/api/2/issue/12427949","fields":{"summary":"A lock could not be obtained within the time requested error in testBTreeForwardScan_fetchRows_resumeAfterWait_nonUnique_split","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}},{"id":"12323301","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12323301","type":{"id":"10001","name":"dependent","inward":"is depended upon by","outward":"depends upon","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"},"inwardIssue":{"id":"12413476","key":"DERBY-4033","self":"https://issues.apache.org/jira/rest/api/2/issue/12413476","fields":{"summary":"50 transactions timing out with no CPU usage and no deadlocks","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}}],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"customfield_12312337":null,"customfield_12312338":null,"updated":"2013-05-02T02:29:19.932+0000","customfield_12312335":null,"customfield_12311720":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/11412","id":"11412","name":"Store"}],"timeoriginalestimate":null,"description":"After doing dome research on the mailing list, it appears that the index split deadlock is a known behaviour, so I will start by describing the theoretical problem first and then follow with the details of my test case.\r\n\r\nIf you have concurrent select and insert transactions on the same table, the observed locking behaviour is as follows:\r\n - the select transaction acquires an S lock on the root block of the index and then waits for an S lock on some uncommitted row of the insert transaction\r\n - the insert transaction acquires X locks on the inserted records and if it needs to do an index split creates a sub-transaction that tries to acquire an X lock on the root block of the index\r\n\r\nIn summary: INDEX LOCK followed by ROW LOCK + ROW LOCK followed by INDEX LOCK = deadlock\r\n\r\nIn the case of my project this is an important issue (lack of concurrency after being forced to use table level locking) and I would like to contribute to the project and fix this issue (if possible). I was wondering if someone that knows the code can give me a few pointers on the implications of this issue:\r\n - Is this a limitation of the top-down algorithm used?\r\n - Would fixing it require to use a bottom up algorithm for better concurrency (which is certainly non trivial)?\r\n - Trying to break the circular locking above, I would first question why does the select transaction need to acquire (and hold) a lock on the root block of the index. Would it be possible to ensure the consistency of the select without locking the index?\r\n\r\n-----\r\n\r\nThe attached test (InsertSelectDeadlock.java) tries to simulate a typical data collection application, it consists of: \r\n - an insert thread that inserts records in batch \r\n - a select thread that 'processes' the records inserted by the other thread: 'select * from table where id > ?' \r\n\r\nThe derby log provides detail about the deadlock trace and stacktraces_during_deadlock.txt shows that the inser thread is doing an index split.\r\n\r\nThe test was run on 10.2.2.0 and 10.3.1.4 with identical behaviour.\r\n\r\nThanks,\r\n\r\nBogdan Calmac.","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12310200":null,"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"aggregatetimeestimate":null,"customfield_12312022":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12310921":null,"customfield_12310920":"37402","summary":"Index split deadlock","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bcalmac","name":"bcalmac","emailAddress":"bcalmac at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=bcalmac&avatarId=19736","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bcalmac&avatarId=19736","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bcalmac&avatarId=19736","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bcalmac&avatarId=19736"},"displayName":"Bogdan Calmac","active":true},"subtasks":[],"customfield_12310090":[{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10422","value":"High Value Fix","id":"10422"}],"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bcalmac","name":"bcalmac","emailAddress":"bcalmac at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=bcalmac&avatarId=19736","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bcalmac&avatarId=19736","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bcalmac&avatarId=19736","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bcalmac&avatarId=19736"},"displayName":"Bogdan Calmac","active":true},"customfield_12310291":null,"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"environment":"Windows XP, Java 6","customfield_12311020":null,"customfield_12310050":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"startAt":0,"maxResults":79,"total":79,"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12517433","id":"12517433","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bcalmac","name":"bcalmac","emailAddress":"bcalmac at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=bcalmac&avatarId=19736","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bcalmac&avatarId=19736","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bcalmac&avatarId=19736","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bcalmac&avatarId=19736"},"displayName":"Bogdan Calmac","active":true},"body":"The test demonstrationg the deadlock","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bcalmac","name":"bcalmac","emailAddress":"bcalmac at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=bcalmac&avatarId=19736","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bcalmac&avatarId=19736","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bcalmac&avatarId=19736","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bcalmac&avatarId=19736"},"displayName":"Bogdan Calmac","active":true},"created":"2007-08-03T04:11:07.804+0000","updated":"2007-08-03T04:11:07.804+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12517434","id":"12517434","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bcalmac","name":"bcalmac","emailAddress":"bcalmac at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=bcalmac&avatarId=19736","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bcalmac&avatarId=19736","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bcalmac&avatarId=19736","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bcalmac&avatarId=19736"},"displayName":"Bogdan Calmac","active":true},"body":"The deadlock trace","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bcalmac","name":"bcalmac","emailAddress":"bcalmac at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=bcalmac&avatarId=19736","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bcalmac&avatarId=19736","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bcalmac&avatarId=19736","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bcalmac&avatarId=19736"},"displayName":"Bogdan Calmac","active":true},"created":"2007-08-03T04:11:56.716+0000","updated":"2007-08-03T04:11:56.716+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12517435","id":"12517435","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bcalmac","name":"bcalmac","emailAddress":"bcalmac at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=bcalmac&avatarId=19736","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bcalmac&avatarId=19736","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bcalmac&avatarId=19736","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bcalmac&avatarId=19736"},"displayName":"Bogdan Calmac","active":true},"body":"The stacktrace before deadlock indicating an index split","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bcalmac","name":"bcalmac","emailAddress":"bcalmac at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=bcalmac&avatarId=19736","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bcalmac&avatarId=19736","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bcalmac&avatarId=19736","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bcalmac&avatarId=19736"},"displayName":"Bogdan Calmac","active":true},"created":"2007-08-03T04:12:52.847+0000","updated":"2007-08-03T04:12:52.847+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12517516","id":"12517516","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=johnemb","name":"johnemb","emailAddress":"johnemb at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"John H. Embretsen","active":true},"body":"This is an interesting case which reminds me (but is different from) a deadlock issue I encountered in a long-running test not so long ago. I was not able to reproduce the deadlock, but we suspect that there may be a bug in the code that creates the deadlock message about the lock cycles, see DERBY-2877 for details.\r\n\r\nThis test (InsertSelectDeadlock.java) is interesting because you get a lock timeout message rather than a deadlock message (even if you add a deadlockTimeout property with a lower value than the waitTimeout property - I've tried), although in practice this is a deadlock. \r\n\r\nAlso, even if derby.language.logStatementText is set to true (I edited the test class to do that), you don't get any more information about the offending statement which (presumably) holds an exclusive lock on the index root (1,1).\r\n\r\nHere's the relevant information extracted from the derby.log Bogdan attached:\r\n\r\nXID       |TYPE         |MODE|LOCKCOUNT|LOCKNAME|STATE|INDEXNAME          |\r\n---------------------------------------------------------------------------\r\n*** The following row is the victim ***\r\n279       |ROW          |S   |0        |(1,7)   |WAIT |NULL               |\r\n*** The above row is the victim ***\r\n269       |ROW          |X   |1        |(1,7)   |GRANT|NULL               |\r\n282       |ROW          |X   |0        |(1,1)   |WAIT |SQL070802115706620 |\r\n279       |ROW          |S   |1        |(1,1)   |GRANT|SQL070802115706620 |\r\n\r\n(I excluded things like tabletype (always T) and tablename (always TRACK_EVENT)).\r\n\r\nThe transactions above are probably:\r\n\r\nXID 279: select * from TRACK_EVENT where ID > ?\r\nXID 269: insert into TRACK_EVENT values (?,?,?,?,?,?,?,?,?,?,?,?,?,?)\r\nXID 282: [index btree split?]\r\n\r\nWe are assuming (based on the stack traces) that XID 269 has spawned another transaction, XID 282, which is trying to modify the index, but is not allowed to because XID 279 is already holding an S (Shared) lock on it. I guess derby does not recognize this as a deadlock because the index-modifying transaction has a completely different transaction number. So, in systems that don't have deadlockTrace enabled, deadlocks may be camouflaged as lock wait timeouts.\r\n\r\nI was kind of hoping that this comment would help so that more people could understand these issues, hence increasing the chances of getting them fixed (or, at the least, improving related documentation). I'm sorry for not being able to work out a solution or provide answers to Bogdan's questions at this point, but I'm hoping someone else will be assisting soon.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=johnemb","name":"johnemb","emailAddress":"johnemb at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"John H. Embretsen","active":true},"created":"2007-08-03T12:34:53.686+0000","updated":"2007-08-03T12:34:53.686+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12520535","id":"12520535","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"> - Trying to break the circular locking above, I would first question\r\n>   why does the select transaction need to acquire (and hold) a lock\r\n>   on the root block of the index.\r\n\r\nB-tree scans lock the leaf node on which they are currently positioned\r\n(in your case the root node is probably also a leaf node) so that they\r\ndon't have to reposition if they lose the latch on the page. The scan\r\nalways releases the latch on the B-tree leaf if it has to wait for a\r\nrow lock. The latch is released in order to prevent deadlocks. Since\r\nthe page is not latched while the scan waits for the row lock, the row\r\nmight have moved to another page in the index and therefore the scan\r\nwould have to start a new search to reposition on the row. The shared\r\nlock on the B-tree leaf ensures that the row is not moved off the\r\ncurrent page so that the repositioning isn't needed. Since the lock on\r\nthe leaf node is shared, it allows more concurrency than if the\r\n(exclusive) latch were kept. But since the lock on the leaf is more or\r\nless like a shared latch, there's still a possibility for deadlocks if\r\nthe B-tree needs to be restructured (like the split deadlock you're\r\nseeing).\r\n\r\n> Would it be possible to ensure the consistency of the select without\r\n> locking the index?\r\n\r\nI think so, if the select transaction had a way to reposition the scan\r\nafter it got the row lock it was waiting for. The current code just\r\nchecks the leaf page again to find the row, since it knows it can't\r\nhave moved to another page. If there weren't a lock on the index page,\r\nthe scan would need to detect that the row had moved and start a new\r\nsearch from the root node.\r\n\r\nI don't know enough about this area of the code to say whether or not\r\nit is doable, or how much work it is. Hopefully, someone more\r\nknowledgeable will chime in with more details.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2007-08-17T12:39:07.587+0000","updated":"2007-08-17T12:39:07.587+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12520891","id":"12520891","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kurti","name":"kurti","emailAddress":"apache at huwig dot de","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kurt Huwig","active":true},"body":"Happens with 10.3.1.4 as well","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kurti","name":"kurti","emailAddress":"apache at huwig dot de","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kurt Huwig","active":true},"created":"2007-08-18T20:21:35.311+0000","updated":"2007-08-18T20:21:35.311+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12520892","id":"12520892","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kurti","name":"kurti","emailAddress":"apache at huwig dot de","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kurt Huwig","active":true},"body":"Simplified testcase with only one column.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kurti","name":"kurti","emailAddress":"apache at huwig dot de","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kurt Huwig","active":true},"created":"2007-08-18T20:23:46.911+0000","updated":"2007-08-18T20:23:46.911+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12520894","id":"12520894","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kurti","name":"kurti","emailAddress":"apache at huwig dot de","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kurt Huwig","active":true},"body":"I've got the same problem nearly every day in my application, therefore I simplified the example file from the mailinglist. I did also try it with MySQL without a deadlock.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kurti","name":"kurti","emailAddress":"apache at huwig dot de","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kurt Huwig","active":true},"created":"2007-08-18T20:24:45.977+0000","updated":"2007-08-18T20:24:45.977+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12523844","id":"12523844","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=johnemb","name":"johnemb","emailAddress":"johnemb at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"John H. Embretsen","active":true},"body":"Related mailing list threads on derby-user, primo August 2007:\r\n\r\nhttp://www.nabble.com/lock-escalation-and-deadlocks-t4197785.html\r\nhttp://www.nabble.com/Concurrent-select-and-insert-deadlock-on-index-t4204088.html","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=johnemb","name":"johnemb","emailAddress":"johnemb at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"John H. Embretsen","active":true},"created":"2007-08-30T12:38:53.028+0000","updated":"2007-08-30T12:38:53.028+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12523850","id":"12523850","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bcalmac","name":"bcalmac","emailAddress":"bcalmac at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=bcalmac&avatarId=19736","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bcalmac&avatarId=19736","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bcalmac&avatarId=19736","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bcalmac&avatarId=19736"},"displayName":"Bogdan Calmac","active":true},"body":"The first thread (http://www.nabble.com/lock-escalation-and-deadlocks-t4197785.html ) is just my wrong interpretation of the cause, so can be discarded.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bcalmac","name":"bcalmac","emailAddress":"bcalmac at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=bcalmac&avatarId=19736","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bcalmac&avatarId=19736","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bcalmac&avatarId=19736","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bcalmac&avatarId=19736"},"displayName":"Bogdan Calmac","active":true},"created":"2007-08-30T13:49:42.620+0000","updated":"2007-08-30T13:49:42.620+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12542746","id":"12542746","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"body":"Hello.\r\n\r\nReading the code of Repro program, \r\nI found the situation that insert thread inserts *multiple rows* in a transaction for times \r\nwhile select thread selects *rows in a range condition* results in scanning index for same table.\r\n\r\nI think the problem is that\r\ninserting multiple row in a transaction make multiple locks for data rows and index rows ,\r\nand then, \r\nthose locks causes deadlock between selecting same table,\r\nbecause operation of selecting rows for range condition also needs locks for data rows and index rows in scanned range.\r\n\r\n\r\nI think there exists two ways to walk around for this situation.\r\n\r\n1:\r\nDo not insert multiple rows in a transaction, \r\nwhen selecting rows of same table in a range condition simultaneously, \r\nas the Repro program.\r\nI tried changing tracksPerBatch as 1 and \r\nthe deadlock problem of Repro program was resolved.\r\n\r\n2:\r\nLoosen transaction isolation level.\r\nI tried conn.setTransactionIsolation( Connection.TRANSACTION_READ_UNCOMMITTED ) and \r\nthe deadlock problem of Repro program was resolved.\r\n\r\n\r\nI'm not sure those walk around is suitable for your case, \r\nbut I hope it helps you.\r\n\r\n\r\nI also think feature like hint for sql may be helpful in those case.\r\nIf we can suppress the use of index for select operation with hint, \r\nwe could also escape the problem using that feature.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"created":"2007-11-15T12:05:11.805+0000","updated":"2007-11-15T12:07:13.156+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12542750","id":"12542750","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kurti","name":"kurti","emailAddress":"apache at huwig dot de","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kurt Huwig","active":true},"body":"I Tomohito,\r\n\r\nin my application, every insert is done on its own and the isolation is set to READ_UNCOMMITTED. Still the very same deadlock happens, although it needs several days and thousands of inserts and selects to manifest.\r\n\r\nThe main difference of my application is, that the database is embedded, but accessed embedded and via the network. Do you think it would solve the problems if I'd only use the network access? Or does there is no difference?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kurti","name":"kurti","emailAddress":"apache at huwig dot de","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kurt Huwig","active":true},"created":"2007-11-15T12:24:12.358+0000","updated":"2007-11-15T12:24:12.358+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12542757","id":"12542757","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"body":"Well ....\r\nI set transaction isolation level of both select and insert operations to TRANSACTION_READ_UNCOMMITTED.\r\nIn that situation, I didn't see dead lock problem.\r\n\r\nI'm not sure your situation exactly other than uploaded program...\r\n\r\nI don't think your problem have something to do with embedded or network server/client,\r\nthough I don't think using embedded mode via network file sharing system is good practice ....\r\n\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"created":"2007-11-15T12:37:53.478+0000","updated":"2007-11-15T12:37:53.478+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12542769","id":"12542769","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kristwaa","name":"kristwaa","emailAddress":"kristwaa at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kristwaa&avatarId=14736","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kristwaa&avatarId=14736","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kristwaa&avatarId=14736","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kristwaa&avatarId=14736"},"displayName":"Kristian Waagan","active":true},"body":"As a data point for Kurts last comment/question, I don't think accessing the database using only the client driver matters either.\r\nI do sometimes see the deadlock in an application where all clients are using the client driver.\r\nIn this application only one row is inserted per transaction as well, but in addition there is a multi-row select and a single-row delete.\r\n\r\nIn my case I was able to tune other parts of the application to work around the problem, but I am unable to tell exactly what caused the problem.\r\nFor your information, it is running with READ_COMMITTED (or REPEATABLE_READ), the load could be said to be medium+ and the table itself is normally pretty small (less than 1000 rows, can be down to a few hundreds).","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kristwaa","name":"kristwaa","emailAddress":"kristwaa at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?ownerId=kristwaa&avatarId=14736","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kristwaa&avatarId=14736","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kristwaa&avatarId=14736","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kristwaa&avatarId=14736"},"displayName":"Kristian Waagan","active":true},"created":"2007-11-15T13:16:30.677+0000","updated":"2007-11-15T13:16:30.677+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12542781","id":"12542781","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"body":"My recognition for this issue is that \r\nDerby uses locks for table and index as a way to realize isolation of transaction and\r\ncares needs to be taken for those locks.\r\n\r\nI found information around lock for index at next url.\r\nhttp://db.apache.org/derby/papers/btree_package.html","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"created":"2007-11-15T13:50:54.504+0000","updated":"2007-11-15T13:50:54.504+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12542953","id":"12542953","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"body":"See the analysis made by Knut Anders above (17/Aug/07).  This is a deadlock between an index scan that has shared locked a special row of the page to avoid that the row it is waiting for is moved to another page.  When another transaction needs to split the page, it creates a deadlock since the splitter needs this special lock in order to perform the split.  Hence, I think all isolation levels except READ UNCOMMITTED will have this problem.   (Since for all other isolation levels the scanner will have to wait for the exclusive lock of the inserter).\r\n\r\nAs Knut Anders say, this deadlock could be avoided if the scanner did not lock this special row, but instead had some way to detect that the row has moved, and then renavigate from the root in such cases.  I would think something similar happens during rollback where an index  row may have moved due to page splits between do and undo.  Maybe something similar could be done here.  I think there are parts to this:\r\n\r\n  1. When a scan needs to wait for a lock, instead of locking this special row, it copies the key of the row so that when it has acquired the lock it is waiting for, it can restart the scan using this key.  \r\n\r\n  2. In order to detect when a renavigation is needed, the page needs to have some kind of state id that indicates whether a renavigation may be needed.  That is, should some row move off the page or in other ways have their address change, the state id will be incremented.  This way the scanner, by copying the current state id before it is suspended, can detect whether the page has changed.  (One need to consider whether this state id is something that needs to be persisted on the page or whether it can just reside in memory.  It depends on whether it may occur that the page is no longer in the page cache when the scan resumes.)\r\n\r\n\r\n\r\n ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"created":"2007-11-16T04:53:03.468+0000","updated":"2007-11-16T04:53:03.468+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12542990","id":"12542990","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kurti","name":"kurti","emailAddress":"apache at huwig dot de","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kurt Huwig","active":true},"body":"Sorry for the noise, but my application even gets the deadlock with\r\n\r\nConnection.TRANSACTION_READ_UNCOMMITTED\r\n\r\nUnfortunately it is a mail cluster and it only gets this with 200+ simultaneous mail connections after several hours/days, so it is somehow hard to create a reproducing example. But I get it every second day, so I can easily verify any fix.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kurti","name":"kurti","emailAddress":"apache at huwig dot de","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kurt Huwig","active":true},"created":"2007-11-16T08:10:42.241+0000","updated":"2007-11-16T08:10:42.241+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12543058","id":"12543058","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"body":"I might be bound by idea of lock for scanning index ...\r\nMy concern is about situation when the range of index, where are already scanned, are restructured.\r\n\r\nThat situation would result \r\nthat rows fetched before the restructuring operation done are not based on restructured index \r\nthough rows fetched after restructuring operation done are based on.\r\n\r\n\r\nThinking that, I think lock is needed for index to be scanned, at least if transaction isolation level is Serializable.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"created":"2007-11-16T12:38:27.620+0000","updated":"2007-11-16T12:38:27.620+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12543077","id":"12543077","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"body":"I found what I was confused ...\r\n\r\nLock for scanning index is held only for *current position*.\r\nI confused as locks are held for not only current position but also scanned range.\r\n\r\nReading code of BTreeScan#posotionAtNextPage,\r\nlock for current page are unlocked when proceeding to next page. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"created":"2007-11-16T14:05:44.793+0000","updated":"2007-11-16T14:05:44.793+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12543340","id":"12543340","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"body":"> One need to consider whether this state id is something that needs to be persisted on the page or whether it can just reside in memory. It depends on whether it may occur that the page is no longer in the page cache when the scan resumes.\r\n\r\nIt would be needed for thestate id discussed here to be persisted.\r\nAccording to the code of StoredPage#releaseExclusive() method, page cache are removed from CacheManager when the page is unlatched.\r\n\r\norg.apache.derby.impl.store.raw.data.StoredPage#releaseExclusive() :\r\n    /**\r\n     * Ensure that the page is released from the cache when it is unlatched.\r\n     *\r\n     * @see org.apache.derby.impl.store.raw.data.BasePage#releaseExclusive\r\n     *\r\n     **/\r\n\tprotected void releaseExclusive()\r\n\t{\r\n\t\tsuper.releaseExclusive();\r\n\r\n\t\tpageCache.release(this);\r\n\t}\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"created":"2007-11-18T04:18:02.349+0000","updated":"2007-11-18T04:18:02.349+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12543363","id":"12543363","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"The page is not removed from the page cache when it is unlatched, but its keep count is decremented, so it is possible that someone else has removed it when the scan is resumed.\r\n\r\nBasePage already has a pageVersion field, but it's only incremented when a logged action is performed on the page. I assume there also are unlogged actions that may move the row off the page?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2007-11-18T10:04:44.818+0000","updated":"2007-11-18T10:04:44.818+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12543575","id":"12543575","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"body":"I found methods of StoredPage, which update contents of page, call logAction method which also bump pageVersion value.\r\nBecause index is in stored page,  I think any actions which move the row off the page are handled using those methods in StoredPage and are logged.\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"created":"2007-11-19T14:34:34.464+0000","updated":"2007-11-19T14:34:34.464+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12543576","id":"12543576","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"body":"I think pageVersion is bumped on all (logged) changes to the page.  The ideal here would be a version number that is only bumped when a row is moved.  Otherwise, most re-navigations would happen when not necessary.   Given that an exclusive lock normally leads to the an update, one might as well do an unconditional re-navigation after having waited instead of basing it on pageVersion.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"created":"2007-11-19T14:41:55.280+0000","updated":"2007-11-19T14:41:55.280+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12543589","id":"12543589","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Could we then have a variable which contains the last page version on which a row was moved, but not store the value to disk? Then the waiter could do something like\r\n\r\n    long savedVersion = pageVersion;\r\n    waitForLock();\r\n    if (lastRowMove == UNINITIALIZED) {\r\n        // page was evicted from the page cache while we were waiting,\r\n        // row might have moved\r\n        renavigate();\r\n    } else if (lastRowMove > savedVersion) {\r\n        // a row has been moved while we were waiting\r\n        renavigate();\r\n    } else {\r\n        // row has not moved\r\n    }\r\n\r\nThen we only renavigate when a row has moved or the page has been removed from the cache.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2007-11-19T15:11:28.881+0000","updated":"2007-11-19T15:11:28.881+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12543590","id":"12543590","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"body":"Knut Anders Hatlen (JIRA) wrote:\r\n\r\n> Then we only renavigate when a row has moved or the page has been removed from the cache.\r\n\r\nI think that is a good idea.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=oysteing","name":"oysteing","emailAddress":"oystein dot grovlen at sun dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Øystein Grøvlen","active":true},"created":"2007-11-19T15:19:57.275+0000","updated":"2007-11-19T15:19:57.275+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12543596","id":"12543596","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"body":"I think lastRowMove is needed to be instance variable of page cache object ...\r\nHere we encounter removed cache problem again ....\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"created":"2007-11-19T15:30:54.407+0000","updated":"2007-11-19T15:30:54.407+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12543603","id":"12543603","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"body":"Oh I understand.\r\nTaking removal of page cache as need for renavigate.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"created":"2007-11-19T16:03:57.549+0000","updated":"2007-11-19T16:03:57.549+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12543867","id":"12543867","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"body":"I found there exists confusion yet...\r\n\r\n>    long savedVersion = pageVersion; \r\n>    waitForLock(); \r\n>    if (lastRowMove == UNINITIALIZED) { \r\n>        // page was evicted from the page cache while we were waiting, \r\n>        // row might have moved \r\n>        renavigate(); \r\n>    } else if (lastRowMove > savedVersion) { \r\n>        // a row has been moved while we were waiting \r\n>        renavigate(); \r\n>    } else { \r\n>        // row has not moved \r\n>    } \r\n\r\n>    waitForLock(); \r\n\r\nWe were thinking about not locking the row.\r\nThen I think this plan is impossible.\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"created":"2007-11-20T11:26:01.723+0000","updated":"2007-11-20T11:26:01.723+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12543873","id":"12543873","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"body":"I read current code (and Knuts comment) that shared lock is gotten instead of latch of page and \r\nthe chance to release the latch are given to escape deadlock through trial for lock\r\nin order to escape deadlock.\r\n\r\nIf we don't get shared lock any more in program, we can do for escaping deadlock is just release the latch.\r\n\r\nReleasing the latch may results the StoredPage, which also means latch for Page, to be removed.\r\n\r\nIf the PageCache is not removed, we can use lastRowMove of StoredPage as above.\r\nIf the PageCache is removed, there are three cases.\r\n1: Only scanning index operation held latch and PageCache was removed. The row is not moved.\r\n2: Other operation also held latch and move the row and release the latch and PageCache was removed.\r\n3: Other operation also held latch and does not move the row but store something and release the latch and PageCache was removed.\r\n\r\nSeeing page version of loaded PageCache, we can distinguish 1 from others.\r\nI think it would be not so awful to check rows in page to know 2 or 3.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"created":"2007-11-20T11:48:32.360+0000","updated":"2007-11-20T11:48:32.360+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12543877","id":"12543877","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"body":"I think code would be like this.\r\nI think we also need to see contents of page if cache was removed once.\r\n    \r\n    long savedVersion = pageVersion; \r\n    page.unlatch()    \r\n    page = null;\r\n               <snip>\r\n\r\n     //Where need to see the row\r\n     page = getFromCache()\r\n\r\n     if (page == null) { \r\n         page = getFromStorage()\r\n\r\n         if( page.pageVersion == savedVersion ){\r\n            // row has not moved \r\n         }else if( checkRowMoved(page) )\r\n            renavigate(); \r\n         }else{\r\n            // row has not moved \r\n         }\r\n\r\n     } else if(page.lastRowMove == UNINITIALIZED ){  // This can be true if cache of page was removed once and loaded again.\r\n         if( checkRowMoved(page)){ // The cache was removed after row moved.\r\n            renavigate(); \r\n         }else{\r\n            // row has not moved \r\n         }\r\n\r\n     } else if (page.lastRowMove > savedVersion) { \r\n         // a row has been moved while we were waiting \r\n         renavigate(); \r\n     } else { \r\n         // row has not moved \r\n     } ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=naka","name":"naka","emailAddress":"tomonaka at basil dot ocn dot ne dot jp","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Tomohito Nakayama","active":true},"created":"2007-11-20T12:16:59.547+0000","updated":"2007-11-20T12:16:59.547+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12641834","id":"12641834","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I'm hoping to find some time to investigate this issue.\r\n\r\nSo far, only one suggestion for how we can fix this has come up. The\r\nbasic idea is that we don't set the scan lock to protect the scan\r\nposition, and instead we reposition the scan if we need to wait for a\r\nlock and therefore have released the latch on the index leaf.\r\n\r\nMost of the discussion has been about how we can avoid the\r\nrepositioning when it's not needed, and I think we have a reasonably\r\ngood understanding of how we can do that by having a (non-persistent)\r\nfield in the page objects that give us a version number after which it\r\nis guaranteed that no row has moved off the page.\r\n\r\nEarlier in the discussion we have said that this field should have a\r\nspecial value to tell that it's uninitialized when the page is faulted\r\nin to the page cache. After some more thinking, I now believe it would\r\nbe more reasonable to initialize it to the current version of the\r\npage. Otherwise, the field would be uninitialized for most of the\r\ncached pages, and it wouldn't help us avoiding repositioning most of\r\nthe time.\r\n\r\nWhat hasn't been discussed yet, is how we can do the repositioning\r\nwhen we don't have the scan lock. Øystein mentioned that the scan\r\ncould copy the key when it needs to wait for a lock, and use the key\r\nto reposition itself in the B-tree. I think that sounds like a good\r\napproach, but there are some things that are not quite clear to me:\r\n\r\n1) Would copying the key work for non-unique indexes as well? I guess\r\nso since the non-unique indexes seem to append the RecordId to the\r\nkey.\r\n\r\n2) How stable are the RecordIds? Can they be changed by other\r\noperations than compress table?\r\n\r\n3) If the isolation level is READ_COMMITTED or higher, the open scans\r\nwould have an intentional read lock on the table, so even without the\r\nscan locks compress table shouldn't be able to change the RecordIds\r\nwhile a scan is waiting for a lock (the intentional read lock should\r\nblock compress table when it attempts to write lock the table). But\r\nwould this work in READ_UNCOMMITTED? Or rather, does it work correctly\r\nin READ_UNCOMMITTED today? READ_UNCOMMITTED doesn't set shared locks,\r\nso I would assume that it doesn't set any shared scan locks either.\r\n\r\nComments and suggestions would be appreciated. I'll do some more\r\ndigging and report back with my findings.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-10-22T14:00:00.179+0000","updated":"2008-10-22T14:00:00.179+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12642440","id":"12642440","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"It looks like READ_UNCOMMITTED transactions also obtain an IS lock on the tables they are scanning, and if they're performing an index scan an S lock on the scan control row. I think this means that the RecordId will not change because of compress table performed in another transaction while there's an open scan. I'm not sure if that's always true if inplace compress table is performed in the same transaction, but it seems like at least the purging is performed in a nested transaction and will time out on getting an exclusive lock if the parent transaction has an open scan on that table.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-10-24T11:07:14.222+0000","updated":"2008-10-24T11:07:14.222+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12646901","id":"12646901","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"We already have code to save the position by key and reposition using\r\nthe saved key (methods savePosition() and reposition() in\r\nBTreeScan). Currently, we only save the key on transaction borders so\r\nthat we can reposition a holdable cursor after a commit. This is\r\nneeded because transactions release all their locks on commit, scan\r\nlocks included.\r\n\r\nI think it should be possible to use the same logic to save the\r\nposition within a transaction. The current position of an index scan\r\nis stored in a BTreeRowPosition object, either as a Page/RecordId pair\r\nwhich requires a scan protection lock, or as a key value. Every time\r\nthe access layer is reentered, reposition() is called which either\r\njust reacquires the latch on the page (if there's a scan lock) or\r\nrepositions from the root of the B-tree (if there's no scan lock).\r\n\r\nSo I think that if we find a way to ensure that we always save the\r\nposition by key when we're about to release the latch on a leaf page\r\n(either because we cannot obtain a lock immediately, or because we're\r\nleaving the access layer), the repositioning code should work more or\r\nless as it is.\r\n\r\nI'm hoping that saving the key each time we release the latch doesn't\r\nhave a too heavy impact on single-threaded performance. For short\r\nkeys, it should be relatively cheap, and the cost of saving the key\r\nmay be outweighed by what we save by not having to maintain the scan\r\nprotection lock.\r\n\r\nWith the optimizations suggested for the repositioning in earlier\r\ncomments, I believe that the repositioning will not be more expensive\r\nthan today in the common case where the page hasn't been split.\r\n\r\nI'd welcome any comments and suggestions on how to implement this.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-11-12T14:05:33.428+0000","updated":"2008-11-12T14:05:33.428+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12650107","id":"12650107","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuckman","name":"stuckman","emailAddress":"stuckman at umd dot edu","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jeff Stuckman","active":true},"body":"I'm also affected by this issue, and I'd like to note that a concurrent select and update can cause the undesired behavior, not just a concurrent select and insert.\r\n\r\nSummary:\r\nEven using READ_COMMITTED, a single non-updatable SELECT and a single UPDATE statement can deadlock against each other when an index includes the updated column.\r\n\r\nMy test case uses the following table and index:\r\nCREATE TABLE urls (urlid INTEGER NOT NULL PRIMARY KEY, url VARCHAR(2048) NOT NULL UNIQUE, site INTEGER, expectation INTEGER, jobflag CHAR DEFAULT 'N'); CREATE INDEX findurlbysiteandjob ON urls(site,jobflag);\r\n\r\nMy test case creates two threads and executes the following statements until they deadlock against each other:\r\nUPDATE urls SET jobflag=? WHERE urlid=?\t\r\nSELECT urlid,url,expectation FROM urls WHERE site=?\r\n\r\nThe test eventually deadlocks with the following transaction and lock table\r\ncontents:\r\nXID     TYPE  MODE TABLENAME LOCKNAME  STATE TABLETYPE  LOCKCOUNT  INDEXNAME\r\n2217109 ROW   S    URLS      (13,1)    GRANT T          1 FINDURLBYSITEANDJOB\r\n2217114 ROW   X    URLS      (13,1)    WAIT  T          0 FINDURLBYSITEANDJOB\r\n2217113 ROW   S    URLS      (15,1)    GRANT T          1 FINDURLBYSITEANDJOB\r\n2217113 ROW   X    URLS      (3,132)   GRANT T          3          null\r\n2217109 ROW   S    URLS      (3,132)   WAIT  T          0          null\r\n2217109 TABLE IS   URLS      Tablelock GRANT T          2          null\r\n2217113 TABLE IX   URLS      Tablelock GRANT T          4          null\r\n2217114 TABLE IX   URLS      Tablelock GRANT T          1          null\r\n2217113 ROW   S    URLS      (6,1)     GRANT T          1 SQL081111021116970\r\n\r\nXID     GLOBAL_XID  USERNAME TYPE                 STATUS  FIRST_INSTANT SQL_TEXT\r\n2217115 null        APP      UserTransaction      IDLE    null select * from SYSCS_DIAG.TRANSACTION_TABLE\r\n2217114 null        APP      InternalTransaction  ACTIVE  null UPDATE urls SET jobflag=? WHERE urlid=?\r\n2217113 null        APP      UserTransaction      ACTIVE  (526,52925) UPDATE urls SET jobflag=? WHERE urlid=?\r\n2069160 null        null     SystemTransaction    IDLE    null          null\r\n2217109 null        APP      UserTransaction      ACTIVE  null\r\n\r\n\r\n1. The SELECT statement begins to execute and the cursor is stepping through the result set. The results are derived from index FINDURLBYSITEANDJOB as expected.\r\n2. The UPDATE statement begins to execute. The row to be updated is the row immediately after the SELECT statement's cursor. The row is locked and updated.\r\n3. The UPDATE statement must modify the index structure (tree rebalancing or similar?). It must lock the row that the SELECT statement's cursor is currently occupying. It cannot do this, so the transaction waits.\r\n4. The SELECT statement is ready to advance the cursor. However, it cannot advance the cursor because the UPDATE statement has locked the next row. The transaction waits and we have a deadlock.\r\n\r\nApparently, the only way to avoid this deadlock is to LOCK TABLE before updating.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=stuckman","name":"stuckman","emailAddress":"stuckman at umd dot edu","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Jeff Stuckman","active":true},"created":"2008-11-24T04:50:53.520+0000","updated":"2008-11-24T04:50:53.520+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12650164","id":"12650164","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Attaching an experimental patch (d2991-preview-1a.diff) to show how\r\nI'm planning to fix the deadlock.\r\n\r\nThe patch makes the B-tree scans save the scan position and release\r\nthe scan lock if they release the latch in the middle of the\r\nscan. Although the patch doesn't remove the use of scan locks, it does\r\nmake sure that no transaction holds the scan lock on a page without\r\nholding the latch on the same page, so the scan locks don't have any\r\neffect anymore.\r\n\r\nThe code to save the position and reposition could be used more or\r\nless in its current state. Some small adjustments needed to be made:\r\n\r\n  * The existing savePosition methods couldn't be used directly since\r\n    one of them assumed that the page was not latched when called, and\r\n    the other one was meant to be called from other transactions that\r\n    needed to tell the scan to save its position if it happened to be\r\n    positioned on a given page. A new variant of savePosition was\r\n    added. I believe that both of the old ones can be removed now,\r\n    since the position will already have been saved and they won't\r\n    have any work to do, but I need to check that.\r\n\r\n  * savePosition/reposition needed to save/restore information about\r\n    whether or not the row at the current position was locked (which\r\n    is available from scan_position.current_rh when the scan is\r\n    positioned). This information wasn't need earlier since the scan\r\n    position would only be saved on transactions boundaries, in which\r\n    case the locks would be released.\r\n\r\nThe final solution should of course also remove the scan locks and\r\ninclude the earlier discussed optimization to prevent unnecessary\r\nrepositioning when no rows have been moved off the page.\r\n\r\nI ran the attached repro (InsertSelectDeadlock.java) and didn't see\r\nany timeouts when the patch was applied.\r\n\r\nI have also run the full regression test suite. suites.All ran\r\ncleanly. Derbyall had five failures in the store tests:\r\n\r\nstore/RowLockIso.sql\r\nstore/rlliso2multi.sql\r\nstore/rlliso3multi.sql\r\nstore/readlocks.sql\r\nunit/T_b2i.unit\r\n\r\nThe first four of them failed because (a) lock table dumps didn't\r\ncontain scan locks any longer, and (b) some inserts didn't fail with a\r\ntimeout trying to obtain the scan lock. These sound like expected\r\nchanges in behaviour and should probably be fixed by updating the\r\ncanons.\r\n\r\nThe last failure (unit/T_b2i.unit) was caused by some debug code that\r\nis only enabled when running that test. The debug code simulates that\r\nthe latch is lost, but it has not been updated to save the position\r\nbefore it releases the latch, so an assert is triggered when we later\r\ntry to reposition. This should be fixed by changing the method\r\nOpenBTree.test_errors so that it saves the position if needed.\r\n\r\nIt would be great if someone could take a look at the patch and verify\r\nthat I'm on the right track and that I'm not missing something\r\nessential.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-11-24T10:56:51.730+0000","updated":"2008-11-24T10:56:51.730+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12651108","id":"12651108","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Attaching an updated preview patch (d2991-preview-1b.diff). Now all\r\nthe regression tests run cleanly. Differences from the previous patch:\r\n\r\n  - updated store tests so that they didn't expect scan locks in the\r\n    lock table dumps or conflicts on the scan lock\r\n\r\n  - ensured that OpenBTree.test_errors() would save the position if\r\n    the condition that is simulated would have resulted in the\r\n    position being saved\r\n\r\n  - verified that the existing savePosition methods could be removed,\r\n    as I indicated in the previous comment, and removed the\r\n    methods. This also made it possible to remove the methods from\r\n    interfaces and no-op implementations of these methods in other\r\n    scan types.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-11-26T19:03:20.211+0000","updated":"2008-11-26T19:03:20.211+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12651519","id":"12651519","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Here's a new update (preview-1c).\r\n\r\nIn this patch, I have removed the locking of the scan protection\r\nhandle completely. This also led to the removal of some debug code\r\nused to simulate wait and/or deadlock when locking the scan, and\r\ntherefore the test cases in T_b2i that expected this debug code to\r\nrun also had to be removed.\r\n\r\nI ran some simple performance tests to get an impression of how the\r\nperformance is affected (used o.a.derbyTesting.perf.clients.Runner).\r\n\r\nFor single-record selects on primary key (-load sr_select) the\r\nthroughput was increased by 5-10%. I suppose this improvement is seen\r\nbecause we no longer spend any time on obtaining and releasing the\r\nscan locks. And since there's no saving of position or repositioning\r\nhappening with this load, no extra overhead is introduced.\r\n\r\nFor 1000x10000 index joins (-load index_join) the throughput was down\r\n15% (single-threaded) to 45% (multi-threaded). These operations\r\nrelease the latch on the leaf frequently (once every 16 rows in the\r\nindex scans), which would mean that a costly renavigation in the\r\nB-tree would happen very often. Additionally, the renavigation would\r\nincrease the contention on the root node of the B-tree, which is\r\nprobably why the performance drop is greater in the multi-threaded\r\nscenario.\r\n\r\nSince some operations may see a significant performance drop, I think\r\nthe previously discussed optimization to prevent unnecessary\r\nrenavigation needs to be implemented before we can consider the patch\r\nready for commit.\r\n\r\nThe patch is starting to get big, but I'm not sure how to split it up\r\nin smaller increments without temporarily degrading the performance of\r\nthe trunk. The patch currently removes a lot more code than it adds,\r\nthough, so the size of the patch doesn't tell the whole truth. The\r\ninserted/deleted ratio is about 1/7, as seen by\r\n\r\n$ svn diff | diffstat | tail -1\r\n 27 files changed, 196 insertions(+), 1410 deletions(-)\r\n\r\nI'll be away next week and will probably not have much time to work on\r\nthis issue, but I will read my mail and try to answer questions.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-11-28T10:44:58.787+0000","updated":"2008-11-28T10:44:58.787+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12651592","id":"12651592","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"Thanks for running the performance tests. It seems like the cases\r\nwhere you are seeing some performance problems are mostly those\r\ncases where the deadlocks were occurring. Since a small\r\nperformance penalty is vastly superior to a deadlock, I think it would\r\nbe reasonable to accept that penalty if the deadlocks are greatly\r\nreduced or (hopefully) eliminated.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2008-11-28T16:12:32.921+0000","updated":"2008-11-28T16:12:32.921+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12652417","id":"12652417","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I agree that the overhead would be acceptable if it had (almost) only\r\naffected those situations where a deadlock could occur, but now\r\nthere's an overhead in other situations as well.\r\n\r\nA B-tree scan may release the latch on the current leaf page in the\r\nfollowing situations:\r\n\r\n1) When a lock cannot be obtained without waiting\r\n\r\n2) When no more rows should be returned by the scan (current key >\r\nstop key)\r\n\r\n3) After a bulk fetch (where a bulk contains from 1 row to 16 rows)\r\n\r\n4) When the end of the current leaf has been reached and the next leaf\r\nhas been latched\r\n\r\nWith the latest patch, we save the current position by key in (1) and\r\n(3). In (2) it's not needed because the scan is complete and no\r\nrepositioning will ever be attempted. In (4) it's not needed since\r\nwe're now successfully positioned on the first row on the next page.\r\n\r\nThe only situation in which a deadlock can occur, is (1), but we\r\ncurrently always reposition by renavigating the B-tree after having\r\nsaved the position by key, so the overhead is also seen in\r\n(3). Unfortunately, almost any query that reads more than 16 rows from\r\nan index will be hit by this.\r\n\r\nI'm planning to update the experimental patch with the discussed\r\noptimization so that we don't need to renavigate the B-tree when\r\nrepositioning in the common case. If that's successful, we can revisit\r\nwhether the patch should be split and reviewed/committed in smaller\r\npieces. If we have a proof of concept in place that shows that the\r\nperformance issues are solvable, it might be acceptable to commit a\r\npartial solution that causes performance regressions for some\r\noperations for a shorter period of time (a week or so) before we\r\ncommit the final patch.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-12-02T16:12:01.887+0000","updated":"2008-12-02T16:12:01.887+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12652969","id":"12652969","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Thanks Knut for working on this issue.  I know it is important to several users.    For one of those users, Myrna backported the 1c patch  along with the fix for DERBY-2878 to 10.3  to try out (Thanks Myrna).  The user reported that it resolved all of their lock timeouts due to this issue and passed their regression tests.  So great work Knut!    We also have a request to backport this once done all the way to 10.1 for a user locked into that version.  So my questions are:\r\n\r\n1)  Do you have any kind of general estimate when the final patch might be ready for trunk?\r\n2)  Do you have any reservations or concerns about my trying to backport the fix once complete to older codelines? Do you know if that is even feasible for 10.1?\r\n3) Is there anything that I can do to help with this issue?\r\n\r\nThanks\r\n\r\nKathey\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2008-12-03T20:56:23.377+0000","updated":"2008-12-03T20:56:23.377+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12652990","id":"12652990","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"I am concerned about performance of always saving full key.  This is going to cause both cpu and memory problems(garbage collection).  As originally designed it was expected that this path would be rare so no optimization was ever done.  The save by id path was the one optimized.\r\n\r\nDid you ever consider fixing by only changing the deadlock case, ie always giving up the scan position lock when one has to wait on a lock?  This case should be rare, compared with the very normal case of group scan which happens by default for any scan of btree returning more than 16 rows for one query.\r\n\r\nsorry for late comment, was out on vacation when you started on this.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2008-12-03T21:49:24.390+0000","updated":"2008-12-03T21:49:24.390+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12653039","id":"12653039","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"After reviewing the current patch, this does not look like a change appropriate for a backport.  It is already 5000 lines of diffs and changes a basic concurrency building block of the btree code.  Getting rid of the scan lock if it can be done with little or no performance penality does look like a good feature for a major release.  It will simplify a lot of code, but would like to see a lot of testing before it gets into an official derby release.  \r\n\r\nI do agree this is a good direction.  Some of the code that originally depended on the scan protection lock no longer needs to as part of work that was later done to support the read uncommitted isolation level.  Off the top of my head my areas of concern would be that the following operations work correctly in all combinations without the concurrency protection provided by the scan protection lock (I think they are ok as they should be protected by latches, but just get worried removing locking from these operations):\r\nsplit\r\nmerge\r\nreclaim deleted rows\r\n\r\nAnother area that might be worth thinking about is to make sure the code that get's previous key locks for serializable is still right without the scan protection lock.  Need to make sure an intervening split which previously was not possible does not break this code.\r\n\r\nThis stuff is hard to test for, I will think about these operations and see if there is any hidden dependency or if they only got the scan protection lock to enable the scan optimization. \r\n\r\nI definitely do worry about having to copy around the full key every time one gives up the latch.  Given the current store interface we can't keep references so we have to allocate \r\nobjects.  This in the worst case can lead to allocation/copies for every index reference in a query and can quickly add up which was why the additional complicaiton of the scan lock was added in the first place.  It would be interesting to understand the performance overhead of the copy vs. the extra search.  As I understand it the proposed optimization would in the \"usual\" case as long as the page remained in memory eliminate the scan but would not eliminate the copy.   Probably the worst case is long keys (maybe multi-part) and maybe datatypes that require object allocations every time they are copied (like decimal).","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2008-12-03T23:12:34.645+0000","updated":"2008-12-03T23:12:34.645+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12653364","id":"12653364","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Thanks to all of you for looking at this.\r\n\r\nTo Kathey's questions, I will get back to working on this issue next\r\nweek and hope to have optimized the patch further and tested it some\r\nmore by the end of that week. It's difficult to say when a fix can be\r\ncommitted to trunk, as it depends on whether we find the suggested\r\napproach acceptable or if we need to find another way to fix it. And\r\nas Mike mentioned more testing is needed in any case. I do hope we can\r\ncome up with an approach everyone feels comfortable with in the next\r\ncouple of weeks before the holiday season, and then get it implemented\r\nand properly tested in January. I agree with Mike though, that it's\r\nprobably too risky to backport the fix, unless we end up with\r\nsomething simpler than the current proposal. Not that I'm planning to\r\nintroduce any bugs, but since it changes some fundamental assumptions\r\nin a critical part of the system, I wouldn't feel all that comfortable\r\nwith backporting it.\r\n\r\nTo Mike's questions:\r\n\r\nYes, I think it is possible to only save the position in situations\r\nthat could cause deadlocks. That would mean that we only save the\r\nposition if we need to wait for a lock. One possible complication is\r\nthat it's not necessarily the scan that's waiting for a lock that's\r\nholding the scan lock that causes the deadlock. Therefore we would\r\nneed to save the position in all the open B-tree scans in the\r\ntransaction when a lock cannot be granted immediately. And this must\r\nbe done for all locks that we wait on, not only locks in B-tree scans,\r\nso it will add complexity to code outside the B-tree code as\r\nwell. Given that this increases the complexity and removing the scan\r\nlocks reduces the complexity, I'd prefer a solution where the scan\r\nlocks are removed completely if it can be done with acceptable\r\nperformance.\r\n\r\nAs to the performance, I hope that it will be possible to measure the\r\nactual cost of copying the key once I have removed the expensive and\r\nunnecessary renavigation. You are right that the suggested\r\noptimization will only save the renavigation, not the copying. Some\r\nthoughts/guesses:\r\n\r\n  - The current code that saves the key always allocates a new\r\n    DataValueDescriptor array and populates it with empty\r\n    DataValueDescriptors of the correct type. It shouldn't be\r\n    necessary to do this more than once per scan. That could save much\r\n    allocation/gc work.\r\n\r\n  - When we save the key, we retrieve it by calling fetchFromSlot(),\r\n    which will deserialize the value of the key from the page. I think\r\n    that this is causing the same work to be performed twice when we\r\n    save the position in methods like BTreeForwardScan.fetchRows(), at\r\n    least when the scan is returning the full key, and we could\r\n    probably make this more efficient.\r\n\r\n  - What we save by not obtaining/releasing the scan lock includes 2-3\r\n    lookups in a global hashtable per leaf page, which could give an\r\n    extra benefit in a multi-threaded scenario.\r\n\r\n  - It's not clear to me that the size of the key is significant. The\r\n    cost of the scan lock is constant per page. Since a bigger key\r\n    means fewer keys per page, the cost of copying keys should also be\r\n    more or less constant per page. So the ratio between the cost\r\n    saved and the cost added may not be that much affected by the size\r\n    of the key.\r\n\r\n  - One of the worst cases is probably where extra qualification of\r\n    the row is needed. Like \"SELECT index_column FROM t WHERE\r\n    length(index_column) = 10\", in which case I think we'll release\r\n    the latch, and therefore also save the key, for every row in the\r\n    index.\r\n\r\nThe suggestions for new tests look reasonable to me. The current\r\nregression tests probably don't test that the current position has\r\nbeen moved to another page while we didn't hold the latch, since those\r\nsituations would have resulted in a lock timeout before. So we\r\nbasically need to have tests for split/merge/reclaim for every call to\r\nreposition() in the code. Will need to think more about how to do\r\nthat. Thanks for raising the concern for the previous key locking as\r\nwell.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-12-04T17:07:31.036+0000","updated":"2008-12-04T17:07:31.036+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12657001","id":"12657001","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Attaching a new preview patch (1d) that implements the optimization\r\nwhich prevents the expensive repositioning when no rows have been\r\nmoved off the page. I haven't done any serious testing of the\r\ncorrectness in all scenarios, I'm just posting it so that we can get\r\nmore information about the performance impact of saving the position.\r\n\r\nAs an initial test, I reran the index-join test that I mentioned\r\nearlier and that showed a significant decrease in performance with the\r\npreview-1c patch. With the preview-1d patch, I'm not able to see any\r\ndecrease (the numbers are actually slightly better with the 1d patch\r\nthan with trunk, though I'm not sure whether it's significant). Below\r\nare the results for 1, 2, 4, 8 and 16 concurrent threads for the 1d\r\npatch (rows prefixed with 'd2991') and trunk (rows prefixed with\r\n'trunk'). The AVG_TPS column shows the number of transactions per\r\nsecond, all configurations were run 30 times (each test run had 30 sec\r\nwarmup and 45 sec steady state) and the AVG_TPS column shows the\r\naverage from the 30 runs.\r\n\r\nJAR       |THREADS    |AVG_TPS               \r\n---------------------------------------------\r\nd2991     |1          |136.3599695946353     \r\ntrunk     |1          |136.0475449900022     \r\nd2991     |2          |265.9779264453826     \r\ntrunk     |2          |262.8875064800415     \r\nd2991     |4          |262.95638006368955    \r\ntrunk     |4          |255.46471154558247    \r\nd2991     |8          |256.97232845038025    \r\ntrunk     |8          |252.92527586462265    \r\nd2991     |16         |256.84847624018147    \r\ntrunk     |16         |254.06894019626188    \r\n\r\nI will see if I can write some more specific tests that test the other\r\npossible worst-case scenarios suggested in earlier comments.\r\n\r\nWhat the patch does, is that it saves the version of the page in the\r\nBTreeRowPosition object before it saves the page, and each time rows\r\ncan be moved off the page (in operations that previously acquired an\r\nexclusive scan lock) this is flagged in the in-memory representation\r\nof the page. BTreeScan.reposition() will first match the version in\r\nBTreeRowPosition with the flagged version number on the page, and will\r\nonly reposition by key if the page has been flagged after the position\r\nwas saved. Pages are automatically flagged with the current version\r\nwhen they are fetched into the cache, so we'll always reposition by\r\nkey if the page has been evicted from the cache after we saved the\r\nposition.\r\n\r\nThe patch also makes savePosition() reuse the DataValueDescriptor\r\nobject in which the key is stored, so that it's only allocated once\r\nper scan.\r\n\r\nCurrently, the patch does not handle the case where the page has\r\ndisappeared when we reposition (only happens with holdable cursors\r\nafter a commit followed by truncate table, I think) or the case where\r\nthe leaf page has turned into a branch page while we waited. These\r\nproblems led to four failures in derbyall and four failures in\r\nsuites.All.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-12-16T14:57:01.055+0000","updated":"2008-12-16T14:57:01.055+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12657838","id":"12657838","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Here's a small performance test that I wrote. It extends the JDBCPerfTestCase class in the JUnit framework. All the tests use a table with 1000 rows. The table has 13 columns: one VARCHAR(10), one VARCHAR(100), one VARCHAR(1000) and ten DECIMAL(10,10). Each single VARCHAR column has an index, one compound index is covering all the VARCHAR columns, there's an index on one of the DECIMAL columns, and there's one covering all the DECIMAL columns. For each index, there's a test case that simply runs through the entire index.\r\n\r\nAfter a couple of repeated runs I can't say that saving the position looks more expensive than locking the scan. Actually, the tests appear to perform slightly better when the position is saved, at least that's what it looks like in my environment (OpenSolaris 2008.11, Java 1.6.0_10). (Except that in some cases it fails because the JUnit framework compresses all the tables before starting the test, and the problem with pages changing from leaf to branch mentioned in my previous comment surfaces.) I'll need to run the tests more in order to say anything for sure. I will do that and report back.\r\n\r\nDoes anyone have suggestions for any other performance tests we should run to check if this is an appropriate path to follow?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-12-18T18:16:05.851+0000","updated":"2008-12-18T18:16:05.851+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12658152","id":"12658152","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"that's great news on initial performance comparisons.  \r\n\r\nI am not sure if the following will do better, but it is what I thought of.  It seems like the worst case would be cases where we move the scan a lot without having latch on page.  ie. case where we get one row at a time from the page.  So I would suggest using the bulk fetch property to only get 1 row at a time:\r\nCALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY('derby.language.bulkFetchDefault','1');\r\n\r\n1000 rows does not seem like enough data to do a test.  One of the problems with the new approach, especially with something like decimal is that there is going to be extra object allocation per row.  So you want enough rows to see what effect it might have on GC.  I usually tried to make sure performance test took at least a second, and maybe 60 seconds\r\nfor at least a one time run.  \r\n\r\nIs a read only test  affected by pages going out of cache?  From your description I don't think so unless you get very strange cache behavior in that the scan current page goes out of cache during the scan of that page.  But might be worth showing that a both approaches perform same on a scan of a\r\ntable that is bigger than the cache when the scan is executed multiple times in a row.\r\n\r\n\r\nShould there be something that exercises the worst case where  the page is updated?  Again for this having a bigger dataset wil cause more overhead for the \r\nsearch.   For this maybe something like a 2 part key with first part being as the current test\r\nand the second part being an int and the test runs a cursor through the table and after reading each index row then updates the second part of the key by minus one, likely leaving the key on the same page - but not putting the scan into an infinite loop.   Make sure the cursor choice is one which goes to the table every time, not one that caches the\r\nvalues in the client somehow.   ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2008-12-19T18:55:18.917+0000","updated":"2008-12-19T18:55:18.917+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12658493","id":"12658493","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I had the JUnit test running repeatedly over the weekend, 300 times\r\nfor each configuration to get a more reliable average. I've summarized\r\nthe results in the table below. Positive values in the increase column\r\nmeans that trunk is faster, negative values means that the patched\r\nversion is faster.\r\n\r\nTEST                |TRUNK_TIME |PATCHED_TI&|INCREASE   |INCREASE_PERCENT      \r\n-------------------------------------------------------------------------------\r\ndecimal10columns    |17752      |17761      |9          |0.0506985128436277    \r\ndecimal1column      |4875       |4842       |-33        |-0.676923076923075    \r\nvarchar10           |4586       |4517       |-69        |-1.5045791539467945   \r\nvarchar100          |7288       |7185       |-103       |-1.4132821075740987   \r\nvarchar1000         |35977      |37008      |1031       |2.865719765405683     \r\nvarcharAll          |41502      |42701      |1199       |2.8890173967519583    \r\n\r\nNot much difference between them. For smaller keys, it seems like\r\nsaving the position is slightly cheaper, whereas for larger keys it\r\nappears to be slightly more expensive.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-12-22T10:21:11.990+0000","updated":"2008-12-22T10:21:11.990+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12658514","id":"12658514","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Thanks for your comments, Mike.\r\n\r\n> I am not sure if the following will do better, but it is what I\r\n> thought of. It seems like the worst case would be cases where we\r\n> move the scan a lot without having latch on page. ie. case where we\r\n> get one row at a time from the page. So I would suggest using the\r\n> bulk fetch property to only get 1 row at a time: CALL\r\n> SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY('derby.language.bulkFetchDefault','1');\r\n\r\nThanks, I wasn't aware of that property. I'll do some experiments with\r\nit.\r\n\r\n> 1000 rows does not seem like enough data to do a test. One of the\r\n> problems with the new approach, especially with something like\r\n> decimal is that there is going to be extra object allocation per\r\n> row. So you want enough rows to see what effect it might have on\r\n> GC.\r\n\r\nI picked 1000 rows to make sure that we had at least a couple of full\r\nindex pages in each of the test cases. I assumed that having multiple\r\niterations on a smaller number of rows would have about the same\r\neffect on GC as fewer iterations on a larger data set.\r\n\r\n> I usually tried to make sure performance test took at least a\r\n> second, and maybe 60 seconds for at least a one time run.\r\n\r\nThe tests mentioned in my previous comment had a fixed number of\r\niterations, so the total time for each test case varied between 20 and\r\n150 seconds depending on key size. (The times in milliseconds in the\r\ntable must be multiplied by four to get the actual time spent because\r\nof the way the framework runs the tests.) I can also try some longer\r\nruns.\r\n\r\n> Is a read only test affected by pages going out of cache? From your\r\n> description I don't think so unless you get very strange cache\r\n> behavior in that the scan current page goes out of cache during the\r\n> scan of that page.\r\n\r\nThat's correct. Read only tests should not be affected by pages going\r\nout of the cache. Even if the current page goes out while we don't\r\nhold the latch, they shouldn't be affected unless there has been a\r\nmodification on the page after the latch was released. In that case\r\nthe page will have the dirty flag in addition to the recently-used\r\nflag, so it's highly unlikely that it will be chosen for eviction.\r\n\r\n> But might be worth showing that a both approaches\r\n> perform same on a scan of a table that is bigger than the cache when\r\n> the scan is executed multiple times in a row.\r\n\r\nGood point. I'll run such a test.\r\n\r\n> Should there be something that exercises the worst case where the\r\n> page is updated? Again for this having a bigger dataset wil cause\r\n> more overhead for the search. For this maybe something like a 2 part\r\n> key with first part being as the current test and the second part\r\n> being an int and the test runs a cursor through the table and after\r\n> reading each index row then updates the second part of the key by\r\n> minus one, likely leaving the key on the same page - but not putting\r\n> the scan into an infinite loop. Make sure the cursor choice is one\r\n> which goes to the table every time, not one that caches the values\r\n> in the client somehow.\r\n\r\nI think I understand what you're suggesting, but a couple of questions\r\njust to make sure that I'm not missing the point:\r\n\r\n  - the purpose of this test is to check that we don't perform any\r\n    repositioning by key just because there has been an update on the\r\n    page?\r\n\r\n  - by making sure that the client doesn't cache the values, you\r\n    basically mean that bulk fetch should be disabled? So setting\r\n    derby.language.bulkFetchDefault or perhaps using an updatable\r\n    cursor and positioned updates should do the trick?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-12-22T11:43:19.148+0000","updated":"2008-12-22T11:43:19.148+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12658895","id":"12658895","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I checked in the performance test with revision 729039.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-12-23T17:06:13.894+0000","updated":"2008-12-23T17:06:13.894+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12659168","id":"12659168","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Here are the results from running the same tests with derby.language.bulkFetchDefault=1 (20 runs with each configuration):\r\n\r\nTEST                |TRUNK_TIME |PATCHED_TI&|INCREASE   |INC_PERCENT           \r\n-------------------------------------------------------------------------------\r\ndecimal10columns    |28390      |33116      |4726       |16.646706586826348    \r\ndecimal1column      |16638      |17997      |1359       |8.168049044356293     \r\nvarchar10           |15062      |16426      |1364       |9.055902270614792     \r\nvarchar100          |18655      |21829      |3174       |17.014205306888233    \r\nvarchar1000         |47123      |70214      |23091      |49.001549137363924    \r\nvarcharAll          |52362      |78693      |26331      |50.286467285436       \r\n\r\nWhen bulk fetch is disabled, saving the position by key is clearly more expensive for these scans. With small keys, the extra cost appears to be moderate, but with large keys it is quite high.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-12-24T23:06:15.946+0000","updated":"2008-12-24T23:06:15.946+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12659315","id":"12659315","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"In BTreeForwardScan.fetchRows() we have already fetched the key (or\r\nparts of the key) before we save the position. So I experimented with\r\ncopying the key instead of re-reading the entire record. The copying\r\nwas performed by iterating over fetch_row and calling setValue() on\r\neach element of scan_position.current_positionKey. This eliminated\r\nmuch of the overhead. A rerun of the JUnit test with\r\nderby.language.bulkFetchDefault=1 gave these results (average of 20\r\nruns for each configuration):\r\n\r\n\r\nTEST                |TRUNK_TIME |PATCHED_TI&|INCREASE   |INC_PERCENT  \r\n----------------------------------------------------------------------\r\ndecimal10columns    |28427      |29727      |1300       |4.5731173    \r\ndecimal1column      |16572      |16890      |318        |1.9188993    \r\nvarchar10           |14715      |15673      |958        |6.5103636    \r\nvarchar100          |18378      |19472      |1094       |5.9527693    \r\nvarchar1000         |47092      |51618      |4526       |9.610974     \r\nvarcharAll          |52457      |57628      |5171       |9.857598     \r\n\r\nThis will of course only work if the entire key is fetched by the\r\nscan. A proper solution would have to read the missing parts of the\r\nkey if only parts of it are used by the scan.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2008-12-27T09:07:51.067+0000","updated":"2008-12-27T09:07:51.067+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12660782","id":"12660782","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I have taken another look at the previous key locking. If the latches\r\nare released when we're searching backward for the previous key, it\r\nseems like we'll rescan the tree, so it doesn't seem like we're\r\ndepending on the scan lock. Some relevant code fragments and comments:\r\n\r\n* BTreeController.doIns():\r\n\r\n    while (true)\r\n    {\r\n    .\r\n    .\r\n    .\r\n        // Row locking - first lock row previous to row being inserted:\r\n    .\r\n    .\r\n    .\r\n        if (latch_released)\r\n        {\r\n            // Had to release latch in order to get the lock, probably \r\n            // because of a forward scanner, research tree, and try again.\r\n            targetleaf = null;\r\n            continue;\r\n        }\r\n\r\n* B2IRowLocking3._lockScanRow():\r\n\r\n    if (pos.current_slot == 0)\r\n    {\r\n        // this call will take care of searching left in the btree\r\n        // to find the previous row to lock, 0 is the control row and\r\n        // not a valid thing to lock as a previous key.\r\n\r\n        // it is ok to call the non-scan as this is just a special\r\n        // case of a previous key lock call.  The only scan code that\r\n        // will call this routine with slot == 0 will retry if this\r\n        // routine returns that a latch was released.\r\n\r\n        latch_released = \r\n            !lockNonScanPreviousRow(\r\n\r\n* B2IRowLocking3.lockNonScanPreviousRow():\r\n\r\n    // RESOLVE RLL (mikem) - NO RECORD_ID PROTECTION IN EFFECT.\r\n    // caller must research, get new locks if this routine \r\n    // releases latches.\r\n    ret_status = this.searchLeftAndLockPreviousKey(\r\n\r\n* B2IRowLocking3.searchLeftAndLockPreviousKey():\r\n\r\n     * If along the search a latch has to be waited on then latches are\r\n     * released and a wait is performed, and \"false\" status is returned to\r\n     * caller.  In this case the routine can no longer be sure of it's current\r\n     * position and may have to retry the whole operation.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-01-05T15:13:32.906+0000","updated":"2009-01-05T15:13:32.906+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12661220","id":"12661220","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"sorry for late reply, was out and away from computer end of the year.\r\n> I think I understand what you're suggesting, but a couple of questions\r\n> just to make sure that I'm not missing the point:\r\n>\r\n> - the purpose of this test is to check that we don't perform any\r\n> repositioning by key just because there has been an update on the\r\n> page?\r\nyes.  I must be misunderstanding the current patch, I thought it would\r\nresearch on an update of the page.  probably worth measuring but not a lot\r\nof different cases if the design does not expect a research.  I was trying\r\nto force a measurement of worst case where a search would happen after every\r\nrow.\r\n>\r\n> - by making sure that the client doesn't cache the values, you\r\n> basically mean that bulk fetch should be disabled? So setting\r\n> derby.language.bulkFetchDefault or perhaps using an updatable\r\n> cursor and positioned updates should do the trick?\r\nMy comment was about making the tree bigger.  Not necessarily to not cache\r\nthe tree, but by making there be more levels in the tree then it will cost\r\nmore to research the tree from the top.  Again was just wanting to know the\r\nworst case penalty.  Maybe you could add a short comment about in which\r\ncases we will research the tree with the new scheme vs. the old scheme.\r\n\r\nThe test I was suggesting I think could be done with updatable cursor and\r\npositioned updates, as long as the properties of the cursor are such that\r\neach next goes to the database.   There are some cursor settings where\r\ncaching will happen in the client and nothing you do to the database after\r\neach row fetch will get you into the btree research code that we are trying\r\nto exercise.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2009-01-06T17:44:22.497+0000","updated":"2009-01-06T17:44:22.497+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12661235","id":"12661235","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"concerning the latest performance results, I am still concerned as I believe the bulkfetch=1 case simulates the path that nested loop joins take, so may affect a lot of normal query behavior.  But your latest optimization looks promising, I would not be surprised if \r\nthere was some optimization that could be made in the copying of one DataValueDescriptor to another.  \r\n\r\nDo you know if in the char/varchar case if the source DVD is already in String form (vs raw character array).","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2009-01-06T18:13:02.625+0000","updated":"2009-01-06T18:13:02.625+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12661580","id":"12661580","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Thanks for clarifying the comments about the tests, Mike. I'll make\r\nthe modifications and come back with the results.\r\n\r\n> Maybe you could add a short comment about in which cases we will\r\n> research the tree with the new scheme vs. the old scheme.\r\n\r\nThe old scheme (current Derby) will research the tree in these\r\nsituations:\r\n\r\n  a) Locks (scan lock, row lock or prev key lock) could not be obtained\r\n     immediately when positioning at the start of the scan\r\n\r\n  b) Transaction was committed after we released the latch (then\r\n     there's no scan lock protecting the position anymore)\r\n\r\n  c) Some other operation within the same transaction caused a split\r\n     on the page we were positioned on after we released the latch\r\n     (scan lock doesn't protect us against changes in the same\r\n     transaction)\r\n\r\nThe new scheme will research the tree in situation (a) above, and\r\nadditionally:\r\n\r\n  d) A row was moved off the page after we released the latch (caused\r\n     by split or purge)\r\n\r\n  e) The current page was updated (any update, as long as the page\r\n     version was changed) *and* evicted from the page cache after we\r\n     released the latch\r\n\r\n> Do you know if in the char/varchar case if the source DVD is already\r\n> in String form (vs raw character array).\r\n\r\nIt is still in raw form when the value is copied, but it will be\r\nconverted to string form SQLChar.setFrom(DVD) calls getString() on the\r\nDVD. In the tests I've run till now, it shouldn't matter since we'll\r\nend up calling DVD.getString() from EmbedRS.getString() on all the\r\nstrings anyway, and the two SQLChar instances share the same immutable\r\nString instance. In other cases it could matter, so it would be better\r\nif we could share the char array between the two SQLChar objects and\r\navoid the allocation of the String. Not sure if this is safe,\r\nthough. SQLChar treats the raw char array as an immutable data type in\r\nmost cases, but not in normalize().\r\n\r\nIt's the same with the DECIMAL tests. The source DVD is in raw form\r\n(byte[] + int) and is converted to a BigDecimal that's shared between\r\nthe two SQLDecimal instances.\r\n\r\nThe cheapest way to copy the key would probably be to have a method in\r\nthe Page interface that could copy the raw row to a byte array. We\r\nwould only have to deserialize the key if repositioning was needed,\r\nand we would only need one extra object allocation per scan in the\r\nnormal case (unless the byte buffer we allocated the first time was\r\ntoo small). Is that an option? The methods to serialize and\r\ndeserialize DVDs are public methods of all DVDs (writeExternal() and\r\nwriteExternal()), so it's not really like it would be exposing\r\nimplementation details in interface methods.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-01-07T14:05:51.389+0000","updated":"2009-01-07T14:05:51.389+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12661938","id":"12661938","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Thinking more about it, copying the raw bytes from the page array would probably only be cheaper if the materialized values created by copying the keys were not going to be used later. So in the tests that I have run till now it shouldn't be any cheaper at all, since the objects we allocate when we copy the key would have been allocated later anyway. Might be worth a try if everything else fails, though.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-01-08T11:02:42.134+0000","updated":"2009-01-08T11:02:42.134+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12662370","id":"12662370","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"There must be something wrong with the test results I posted on\r\n27/Dec/08.\r\n\r\nFirst of all, they don't really make any sense. Why should the\r\noverhead of saving the position be greater for VARCHAR(1000) than for\r\nVARCHAR(10)? Since the String object that we generate when we copy the\r\nkey is shared between the source DVD and the target DVD, and the\r\nsource DVD saves the same amount of work when it later needs to return\r\nthe String to the user, the overhead per row should be proportional to\r\nthe number of columns in the key, not to the size of the columns in\r\nthe key. And since reading longer values is more expensive than\r\nreading shorter values, the relative overhead should be smaller rather\r\nthan greater for VARCHAR(1000).\r\n\r\nSecondly, I see the exact same results when I compare a clean trunk\r\nwith another clean trunk. For some reason, the runs (1, 3, 5, ...)\r\nconsistently show significantly better performance than the runs (2,\r\n4, 6, ...). But it turns out that if I remove the database directory\r\nbetween each run, I get much more stable results. I've got no idea why\r\nthis happens. Perhaps something CleanDatabaseTestSetup or some other\r\npart of the test framework does?\r\n\r\nAnyway, no matter what's causing it, I'll need to rerun the tests and\r\nlet each test run create its own database. It's probably also a good\r\nidea to randomize the order of the test to eliminate interference from\r\nperiodic/alternating factors. In the previous test runs, I ran clean,\r\npatched, clean, patched, and so on, so that all the bad runs were with\r\npatched jars and all the good runs were with clean jars. Perhaps I'll\r\nalso write a simple standalone test, so that we don't need to worry\r\nabout what happens in the test framework.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-01-09T13:55:43.151+0000","updated":"2009-01-09T13:55:43.151+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12662951","id":"12662951","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Had the tests with bulk-fetch disabled running over the weekend (200\r\ntimes with a clean trunk, 200 times patched). Now I used a standalone\r\ntest which did the same as the JUnit test (except from some adjusting\r\nof the number of iterations to get the time more evenly distributed\r\nbetween the test cases, and the size of the test table was increased\r\nfrom 1000 rows to 10000 rows), and I randomized the order of the\r\ntests. Now the test results look much more reasonable.\r\n\r\nThe test case with a key consisting of ten DECIMAL columns shows the\r\nworst performance, with a 1.9% increase in the time spent. The test\r\ncases with VARCHAR(10) and VARCHAR(100) showed 1.6% and 0.9% increase\r\nin time spent, respectively. The other test cases basically showed the\r\nsame performance for clean jars and patched jars. The table below\r\nshows the average numbers (times in milliseconds) for the test runs.\r\n\r\nNAME                    |TRUNK_TIME |PATCHED_TI&|INCREASE   |INC_PERCENT  \r\n--------------------------------------------------------------------------\r\nDecimal10Columns        |81495      |83025      |1530       |1.8774158    \r\nDecimalSingleColumn     |63722      |63769      |47         |0.07375789   \r\nVarchar0010             |54268      |55145      |877        |1.6160537    \r\nVarchar0100             |70907      |71576      |669        |0.9434894    \r\nVarchar1000             |87431      |87457      |26         |0.029737735  \r\nVarcharAll              |97197      |96845      |-352       |-0.3621511   \r\n\r\nNow that I've got test results that I understand, I'll go on and add\r\nthe test cases Mike suggested. If we don't find any common code path\r\nthat's slowed down more than what the latest test run showed, I would\r\nbe inclined to say the overhead is acceptable, given that it fixes a\r\nserious issue and that other common code paths are actually getting\r\nbetter performance, and investigation on how to reduce the overhead\r\nfurther could be postponed until later. But let me first see how the\r\nother suggested test cases are affected.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-01-12T13:26:59.210+0000","updated":"2009-01-12T13:26:59.210+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12666147","id":"12666147","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Updating the preview patch (1e). There are two changes from the previous preview:\r\n\r\n1) If the leaf page on which we're positioned is transformed into a branch page while we don't hold the latch, we reposition by key. This fixes eight regression test failures (ClassCastExceptions) seen with 1d. FWIW, derbyall and suites.All now run without failures.\r\n\r\n2) Copy the (possibly partial) key fetched in BTreeForwardScan when saving the position, instead of re-reading the full key from the page. If the scan just fetches a partial key, we fetch the missing parts only from the page.\r\n\r\nThis is not the same patch as I used in the latest performance test runs. That patch copied the key as if the full key had been fetched by the scan. However, since the tests only scan the index and don't go to the base table, the scans don't fetch the RowLocation which is the last column in the index. So when we save the position we still need to call Page.fetchFromSlot() to get the RowLocation. So now the overhead with bulk fetch disabled is back at 1% (for large key columns) to 10% (small/many key columns). I'm posting the patch for reference anyway.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-01-22T14:09:25.173+0000","updated":"2009-01-22T14:09:25.173+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12668514","id":"12668514","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I've tried to find out which effect the proposed solution has on\r\nnested loop joins. The assumption was earlier that nested loop joins\r\nwould turn off bulk fetching and therefore the index scans with\r\nderby.language.bulkFetchDefault=1 would give a good impression of the\r\noverhead imposed by the patch.\r\n\r\nThis turns out not to be the case. Nested loop joins do in fact use\r\nthe default bulk fetch size (16) both for accesses to the outer table\r\nand to the inner table. The inner table/index is accessed through many\r\nshorter scans that frequently return fewer rows than the bulk fetch\r\nsize. But even if that causes frequent release of latches, it doesn't\r\ncause copying of the current key, since the scan is done when the\r\nlatch is released, and therefore we don't need the position\r\nanymore. So the nested loop joins will actually get much of the\r\nperformance benefit observed in single-record primary key selects\r\nmentioned when the preview-1c patch was uploaded.\r\n\r\nI inserted some optimizer overrides in the index_join test in\r\norg.apache.derbyTesting.perf.clients.Runner to make the optimizer pick\r\na nested loop join. With the modified test, the throughput appeared to\r\nincrease by about 6% when the patch was applied (average of 30 runs\r\nwith each configuration).\r\n\r\nSo here's what it looks to me as if the performance impact is:\r\n\r\na) Short index scans get increased performance because they don't need\r\nto obtain the scan lock, and because saving the position is not needed\r\nsince they complete before they release the latch.\r\n\r\nb) Long index scans don't get very much affected by the patch (there's\r\nextra cost in saving keys, but that only happens for every 16th row,\r\nand there's a per page reduction in cost by obtaining the scan lock)\r\n\r\nc) Nested loop joins use (b) to scan the outer table and (a) to scan\r\nthe inner table, so they should not see any negative impact\r\n\r\nd) Long index scans without bulk fetching get lower performance\r\nbecause they save the position for every qualified row in the index\r\n\r\nSo the only case identified so far which will get lower performance,\r\nis (d) long index scans without bulk fetching. This kind of scan may\r\nbe used by updatable cursors, but I'm not aware of any other kind of\r\nqueries that would disable bulk fetching (except when users set\r\nderby.language.bulkFetchDefault, but I don't think that's a very\r\nimportant case). The overhead appears to be in the range 1%-10%,\r\ndepending on the key.\r\n\r\nUnless there are other common cases that I haven't thought of, it\r\nsounds like an acceptable overhead to me, given that\r\n\r\na) updatable cursors aren't all that common, and if they are actually\r\nused to update the database, the extra CPU spent by the scan will be\r\nnegligible\r\n\r\nb) shorter scans see a performance increase in the same order as the\r\ndecrease seen by longer no-bulk scans\r\n\r\nc) concurrent reads and writes don't deadlock anymore unless there's a\r\nreal lock conflict\r\n\r\nComments?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-01-29T16:48:10.510+0000","updated":"2009-01-29T16:48:10.510+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12669401","id":"12669401","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"body":"I think your performance testing has been superb: detailed and thorough.\r\n\r\nI'm comfortable with the performance impact of this change.\r\n\r\nThe deadlock is a serious problem, experienced by many users, and I think\r\nthis proposed fix is great. +1 from me to proceed with committing your patch.\r\nLet's get it into the codeline and start getting some wider experience with it.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bryanpendleton","name":"bryanpendleton","emailAddress":"bpendleton dot derby at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bryan Pendleton","active":true},"created":"2009-02-01T16:50:01.797+0000","updated":"2009-02-01T16:50:01.797+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12669461","id":"12669461","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Thanks for your comments, Bryan. I agree that if we go for this approach, it is better to get the code in early to get as much testing as possible before the next release. But I think the preview patches need to be cleaned up and have some more comments before they're ready to be committed. I'm also about to start writing more functional tests, as I don't trust that the existing tests exercise all the new code paths. At the very least, I would like to have tests for all calls to reposition() in situations where the calls actually lead to a full repositioning from the root of the B-tree. Most of those cases are not tested by the existing tests because they would likely have led to timeouts.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-02-01T22:02:15.547+0000","updated":"2009-02-01T22:02:15.547+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12670426","id":"12670426","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"I believe we should go forward with this change in the trunk.  I also am ok with the tested \r\nperformance trade off's.  I don't think we should backport a change of this magnitude, I think\r\nit is appropriate for a new feature release, hopefully 10.5.  I especially like that after this change\r\nthe code is simpler, the scan locking stuff was complicated and it is great that it can be removed\r\nwith performance sometimes increased and mostly not too affected.\r\n\r\nOnce the change goes in there may be more work possible to improve performance, but I think\r\nit is fine to get the basic stuff in now.  One thing that comes to mind is to change the default group\r\nfetch size from a fixed size to a page worth.  That had always been a future direction and I think the\r\ninterfaces are there (ie. allow store to set the size of the fetch, and passing variable size groups back\r\nto caller).  This seems even more important as once the latch is given up repositioning costs may\r\nbe higher than before.  \r\n\r\nKnut, I would be happy to review the entire package one more time, but would rather wait until you do\r\nthe cleanup you mention.  Just post a comment when you are ready.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2009-02-04T19:28:16.985+0000","updated":"2009-02-04T19:28:16.985+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12670798","id":"12670798","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Thanks Mike. I agree that this change should not be back-ported. Increasing the\r\nfetch size sounds like a good idea to me. I guess we should collect this and\r\nother ideas in JIRA issues before we close this issue. I'll post a comment when\r\nI have a cleaned up patch ready.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-02-05T15:44:26.770+0000","updated":"2009-02-05T15:44:26.770+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12674994","id":"12674994","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Here's the first attempt to create a test that exercises the new code. It's only got two test cases for now, but I'm posting it anyway. More test cases will come.\r\n\r\nTest case 1 tests the call to BTreeScan.reposition() in BTreeMaxScan.fetchMaxFromBeginning().\r\n(BTreeMaxScan has another call to reposition() in fetchMax(), but as far as I can see it's impossible to reach that call, so I haven't added any test case for it.)\r\n\r\nTest case 2 tests the first call to reposition() in BTreeForwardScan.fetchRows() (there are four more in that method) when the leaf page on which the scan is positioned has been split after the position was saved. (Full repositioning from the root of the B-tree is required in this case.)\r\n\r\n#1 fails with the patch (assert in sane builds, NPE in insane builds), so there's more to investigate. It runs cleanly without the patch.\r\n\r\n#2 times out without the patch, and runs successfully with the patch.\r\n\r\nCommitted revision 745866.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-02-19T13:51:25.754+0000","updated":"2009-02-19T13:51:25.754+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12675382","id":"12675382","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Attaching a patch with more test cases for the calls to reposition() in BTreeForwardScan.fetchRows(). None of the added test cases fail on a clean trunk. One of them fails with the preview-1e patch. This is an expected failure (there's a TODO mentioning it in reposition()) where the page has disappeared because of an in-place compress before resuming the scan with a holdable cursor. It fails with an assert in sane builds when calling ControlRow.get(). I had expected it to work in insane builds, but then get() throws a NullPointerException. I guess this should either be resolved by allowing ControlRow.get() to return null when the page has disappeared, or to create a variant of ControlRow.get() which is allowed to return null.\r\n\r\nCommitted the new test cases to trunk with revision 746273.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-02-20T15:26:38.800+0000","updated":"2009-02-20T15:26:38.800+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12675848","id":"12675848","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Attaching a patch with two more test cases for BTreeForwardScan.fetchRows(). The test cases exercise the code path taken when an index scan waits for a lock and the current leaf page has been split before it wakes up. One of the test cases is for unique indexes, and the other one is for non-unique indexes (two test cases were needed since the different indexes call reposition() from different places). Both of the test cases fail (lock timeout) on a clean trunk and pass with patch 1e.\r\n\r\nCommitted revision 746954.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-02-23T10:48:36.685+0000","updated":"2009-02-23T10:48:36.685+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12676266","id":"12676266","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I've been trying to write test cases for the rest of the calls to BTreeScan.reposition(), but I haven't managed to come up with any sensible test cases for IndexSplitDeadlockTest. Some of the calls appear to be unreachable unless we use the internal API. Others are reachable, but in order to test them better than they're already tested by other tests (for instance testing that they work if there's been a split right before the repositioning) I think we'll need to write tests against the internal API for those calls as well. I'll defer writing tests against the internal API for now (of course, suggestions of how to test them via the public API are welcome) and instead add more test cases for the places we are saving the position. I added a comment to IndexSplitDeadlockTest describing which calls to reposition() that are not explicitly tested (revision 747371).","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-02-24T13:26:25.162+0000","updated":"2009-02-24T13:26:25.162+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12676991","id":"12676991","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I'm attaching a new patch (d2991-2a.diff) which has these changes\r\ncompared to the preview-1e patch:\r\n\r\n- added more comments and removed mentioning of scan lock in (some of\r\n  the) existing comments\r\n\r\n- removed the savedLockedPos flag from BTreeRowPosition and moved back\r\n  to the original approach of just using current_rh != null to\r\n  indicate that the row on the current position was locked. This also\r\n  allows cheap repositioning by record id in more cases than before\r\n  because current_rh is not null as often as it was with the\r\n  preview-1e patch\r\n\r\n- fixed the bug exposed by testBTreeMaxScan_fetchMaxRowFromBeginning\r\n  in IndexSplitDeadlockTest. The problem was that one of the methods\r\n  was passed the scan_position instance variable as an argument. When\r\n  that method called reopenScan(), the instance variable would be\r\n  replaced, but the local variable would remain the same, and this\r\n  inconsistency triggered an assert in the added code. Solved by\r\n  removing the position from the argument list and instead using the\r\n  instance variable directly\r\n\r\n- fixed the bug exposed by\r\n  testBTreeForwardScan_fetchRows_resumeScanAfterCompress. Solved by\r\n  fetching the page with another method that didn't fail if the page\r\n  had disappeared, and reposition from the root of the B-tree if the\r\n  page was removed by SYSCS_COMPRESS_TABLE.\r\n\r\n- updated canon for store/updatelocksJDBC30.sql which has been added\r\n  to derbyall recently\r\n\r\nI have just realized that there are some more problems that need to be\r\nresolved, but I think they will have just minor effect on the patch,\r\nso I'm posting it anyway to allow others to take a look at it and see\r\nif there are more serious problems with it.\r\n\r\nHere's a description of the changes in each file touched by the patch\r\n(excluding the test files which were just updated so that they didn't\r\nexpect scan locks in the lock tables, and so that they didn't expect\r\nindex split deadlocks):\r\n\r\n* impl/store/access/sort/Scan.java\r\n\r\nRemoved savePosition() method from the interface because the position\r\nis now always saved by key when the scan doesn't hold a latch on the\r\nleaf.\r\n\r\n* impl/store/access/btree/LeafControlRow.java\r\n\r\nRemoved calls to Scan.saveScanPositions() and\r\nBTreeLockingPolicy.lockScan() before splitting the page, because\r\npositions are always saved by the scan itself now, and because we\r\ndon't use scan locks anymore.\r\n\r\nSet a hint in the page object after splitting to notify the scans that\r\nthey must reposition from the root of the B-tree after a split.\r\n\r\n* impl/store/access/btree/BTreeController.java\r\n\r\nDon't lock scan before purging committed deletes. Set a hint in the\r\npage object to tell the scans that they must reposition from the root\r\nof the B-tree since the row may not be there anymore.\r\n\r\n* impl/store/access/btree/BTreeScan.java\r\n\r\nRemove locking/unlocking of scan.\r\n\r\nUpdate savePosition() to allow the position to be saved by record id\r\nand by key at the same time, and make it possible to pass in a partial\r\nor a full key to reduce the number of slots that must be fetched from\r\nthe page.\r\n\r\nUpdate reposition() to reposition by record id if possible and by key\r\nif needed. Repositioning by record id (which is cheaper) is possible\r\nif the row is guaranteed to be on the same page as when the position\r\nwas saved (that is, no split or purge operation has been performed on\r\nthe page after saving the position).\r\n\r\nUse savePositionAndReleasePage() when returning from the scan in\r\ndelete(), fetch(), doesCurrentPositionQualify() and\r\nisCurrentPositionDeleted().\r\n\r\n* impl/store/access/btree/BTreeMaxScan.java\r\n\r\nRemove the BTreeRowPosition argument from fetchMaxRowFromBeginning()\r\nto prevent that it goes out of sync with the instance variable\r\nscan_position when reopenScan() is called. Use the fresh instance\r\nvariable instead.\r\n\r\nRemove references to the scan protection handle.\r\n\r\n* impl/store/access/btree/BTreeRowPosition.java\r\n\r\nAdd more state (and methods to access the state):\r\n\r\n  - parent of the position. That is, which scan owns this\r\n    position. This was needed to allow the position to be saved from\r\n    some methods that didn't know which scan it belonged to. Could\r\n    alternatively be solved by passing the scan as an argument to\r\n    those methods (or actually to those methods and their callers)\r\n    which is probably cleaner, but could be performed in a later\r\n    clean-up\r\n\r\n  - version number of the current leaf page when the position was\r\n    saved (used to determine whether full repositioning is needed\r\n    because of split, etc.)\r\n\r\n  - template for the key to save (to prevent allocation each time the\r\n    key is saved). When the position is saved by key, this is\r\n    identical to current_positionKey. A separate field was added so\r\n    that we keep the object even when current_positionKey is nulled\r\n    out, but a possibly cleaner solution would be to have just a flag\r\n    telling whether the value in current_positionKey is valid, and\r\n    never reset current_positionKey to null. Could be done in a later\r\n    clean-up\r\n\r\n  - fetch descriptor used to fetch the rest of the key in the cases\r\n    where the scan has already fetched parts of the key before saving\r\n    the position\r\n\r\n* impl/store/access/btree/BTreePostCommit.java\r\n\r\npurgeRowLevelCommittedDeletes() sets a hint in the page object to\r\nforce scans to reposition from the root of the B-tree when at least\r\none row has been purged from the page.\r\n\r\nI think the same change should have been made in\r\npurgeCommittedDeletes(). I missed it because the method assumed an\r\nexclusive table lock and therefore didn't need a scan lock. Will\r\nupdate the patch later.\r\n\r\n* impl/store/access/btree/OpenBTree.java\r\n\r\nRemove references to the removed saveScanPositions() method and to the\r\nprotection record handle.\r\n\r\nMake the debug code that simulates release of latches save the\r\nposition since that's what happens if the latches really are released\r\nby the production code now.\r\n\r\n* impl/store/access/btree/index/B2IRowLockingRR.java\r\n* impl/store/access/btree/index/B2INoLocking.java\r\n* impl/store/access/btree/index/B2IRowLocking1.java\r\n* impl/store/access/btree/index/B2IRowLocking3.java\r\n* impl/store/access/btree/BTreeLockingPolicy.java\r\n\r\nRemove request_scan_lock parameter.\r\n\r\nRemove code to lock/unlock scan.\r\n\r\nSave position of scan if lock cannot be granted immediately.\r\n\r\n* impl/store/access/btree/BTreeForwardScan.java\r\n\r\nSave position by key each time the scan returns a group of rows. Use\r\nthe partial (possibly full) key fetched by the scan to make the save\r\nposition operation cheaper.\r\n\r\n* impl/store/access/RAMTransaction.java\r\n* impl/store/access/heap/HeapScan.java\r\n* iapi/store/access/conglomerate/ScanManager.java\r\n* iapi/store/access/conglomerate/TransactionManager.java\r\n\r\nRemove saveScanPositions()/savePosition() because the position will\r\nalready have been saved now since we always save the position when we\r\nrelease the latch.\r\n\r\n* impl/store/access/heap/HeapRowLocation.java\r\n\r\nRemove THROWASSERT from and complete implementation of\r\nsetFrom(DataValueDescriptor) to allow the RowLocation in the index row\r\nto be copied when we save the position.\r\n\r\n* impl/store/raw/data/BasePage.java\r\n* iapi/store/raw/Page.java\r\n\r\nRemove reference to protection record handle.\r\n\r\nAdd code to set the hint that repositioning from the root of the\r\nB-tree is needed.\r\n\r\n* iapi/store/raw/RecordHandle.java\r\n\r\nRemove constant identifying the record protection handle that we no\r\nlonger use.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-02-26T13:22:32.050+0000","updated":"2009-02-26T13:22:32.050+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12676998","id":"12676998","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I know there are at least a couple of issues with the 2a patch, but\r\nI'm setting the patch available flag anyway because I believe those\r\nissues won't cause big changes to the patch, so the patch is in such a\r\nstate that it should be ready for review.\r\n\r\nThe issues I'm aware of that need to be resolved, are these:\r\n\r\n- BTreePostCommit.purgeCommittedDeletes() needs to call\r\n  Page.setRepositionNeeded() to tell index scans that they need to\r\n  reposition by key. Since purgeCommittedDeletes() is only called in a\r\n  separate transaction that has an exclusive table lock, I believe\r\n  that this issue could only affect holdable index scans that\r\n  reposition after a commit.\r\n\r\n- Some callers of BTreeScan.reposition(pos,false) have\r\n  comments/asserts stating that it is impossible that the current row\r\n  has been purged because they hold the scan lock. I think that it is\r\n  now possible that rows are purged from the page if we released the\r\n  latch, so we might need to change how they handle that situation. In\r\n  most cases (except read-uncommitted scans) the scans hold a lock on\r\n  the current row so that it is true that the row cannot have been\r\n  purged.\r\n\r\nFeedback on the patch as it is would be appreciated. I'll probably be\r\noffline for a couple of days, so I may not respond immediately to\r\nquestions/comments.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-02-26T13:51:57.014+0000","updated":"2009-02-26T13:51:57.014+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12680169","id":"12680169","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Here's an updated patch (d2991-2b.diff) which addresses the two issues I\r\nmentioned that I was aware of in the 2a patch:\r\n\r\n1) Call Page.setRepositionNeeded() in BTreePostCommit.purgeCommittedDeletes()\r\nwhen a row has been purged.\r\n\r\n2) Handle the cases where reposition() can return false (that is, second\r\nargument to reposition() is false and the row on the current position has been\r\npurged). This led to the following changes:\r\n\r\n* BTreeScan.positionAtDoneScanFromClose()\r\n* BTreeScan.reopenScan()\r\n\r\n  Removed the calls to reposition(). The only reason I could see for these\r\n  methods to call reposition() was that some implementations of\r\n  BTreeLockingPolicy.unlockScanRecordAfterRead() had asserts that checked that\r\n  the page of the current position was latched. Removing the calls (and the\r\n  asserts) made the code simpler and removed the need for special handling if\r\n  reposition() was unsuccessful.\r\n\r\n* B2IRowLockingRR.unlockScanRecordAfterRead()\r\n* B2IRowLocking2.unlockScanRecordAfterRead()\r\n\r\n  Don't assert that the current leaf is latched, as there is no need for that\r\n  latch in order to unlock the record. (See above.)\r\n\r\n* BTreeScan.delete()\r\n* BTreeScan.doesCurrentPositionQualify()\r\n* BTreeScan.fetch()\r\n* BTreeScan.isCurrentPositionDeleted()\r\n\r\n  Make sure that we don't try to release the latch on the current leaf unless\r\n  we have actually latched it, since the leaf won't be latched if reposition()\r\n  returns false. No other special handling of purged rows is needed in those\r\n  methods, I think. delete() and fetch() throw an exception\r\n  (AM_RECORD_NOT_FOUND) if the row has been purged, which sounds reasonable to\r\n  me. doesCurrentPositionQualify() and isCurrentPositionDeleted() use the\r\n  return value from reposition() to decide what they should return themselves,\r\n  which also sounds fine to me (except that I would expect that\r\n  isCurrentPositionDeleted() returned true if the row was purged, but currently\r\n  it returns false -- will file a separate bug for that).\r\n\r\n* BTreeMaxScan.fetchMaxRowFromBeginning()\r\n* BTreeForwardScan.fetchRows()\r\n\r\n  If the row on the current position of the scan has been purged while we were\r\n  waiting for a lock so that reposition(pos,false) returns false, we call\r\n  reposition() again with second argument true to reposition on the row\r\n  immediately to the left of where the purged row was supposed to be. This\r\n  effectively takes one step back in the scan, so therefore we need to jump to\r\n  the top of the loop's body to move one step forward past the purged row.\r\n\r\nI tested that reposition(pos,false) followed by reposition(pos,true) worked by\r\nsetting a breakpoint in the debugger and manually changing values in the page\r\nobject and in the position to make the scan code believe that the row had been\r\npurged. As far as I could tell, it worked just as if the scan had found a\r\ndeleted row. (There are currently no tests that exercise code paths where\r\nreposition() returns false, and I don't see any easy way to write a test for it\r\nsince it would be highly dependent on timing between user threads and service\r\nthreads.)\r\n\r\nThis patch fixes all the issues I'm aware of in the previous patch. Derbyall\r\nand suites.All ran cleanly. Reviews, comments and questions would be\r\nappreciated. Thanks.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-03-09T15:01:14.277+0000","updated":"2009-03-09T15:01:14.277+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12681374","id":"12681374","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I would feel more comfortable with committing this patch if another pair of eyes had looked at it first, but since it was suggested earlier that it would be good to get the fix into the codeline as soon as possible to get more experience with it, I plan to commit the patch on Monday before the 10.5 branch is created unless I hear anything. Please let me know if you have objections to this approach. Of course, reviews and comments are welcome even after the patch has been committed.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-03-12T16:13:53.524+0000","updated":"2009-03-12T16:13:53.524+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12682319","id":"12682319","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Committed the 2b patch with revision 754894.\r\n\r\nThere still are references to the scan locks in some comments I think. I will try to track them down and update them in a follow-up.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-03-16T14:03:47.712+0000","updated":"2009-03-16T14:03:47.712+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12682321","id":"12682321","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"IndexSplitDeadlockTest has now been enabled as part of suites.All (patch test-4.diff) since the main fix has gone in. Committed revision 754900.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-03-16T14:16:51.117+0000","updated":"2009-03-16T14:16:51.117+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12682898","id":"12682898","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=myrna","name":"myrna","emailAddress":"m dot v dot lunteren at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Myrna van Lunteren","active":true},"body":"Can this isssue be closed as fixed in 10.5 and subsequent/remaining issues be pursued in a new JIRA?","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=myrna","name":"myrna","emailAddress":"m dot v dot lunteren at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Myrna van Lunteren","active":true},"created":"2009-03-18T03:37:56.606+0000","updated":"2009-03-18T03:37:56.606+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12683061","id":"12683061","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Yes, I think we can mark this issue as resolved now and address remaining cleanup, and bugs if they turn up, in separate issues.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-03-18T16:32:00.259+0000","updated":"2009-03-18T16:32:00.259+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12719690","id":"12719690","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I recently merged changes for DERBY-3926 into 10.5.1.2 codeline (revision 784809) and I ran the junit tests on the merged code. The tests finished with one \"A lock could not be obtained within the time requested\". Kathey recommended that I post that failure here since it may be related to this jira entry. Following is the stack track from text junit runner (junit.textui.TestRunner)\r\nThere was 1 error:\r\n1) testBTreeForwardScan_fetchRows_resumeAfterWait_nonUnique_split(org.apache.derbyTesting.functionTests.tests.store.IndexSplitDeadlockTest)java.sql.SQLException: A lock could not be obtained within the time requested\r\n        at org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)\r\n        at org.apache.derby.impl.jdbc.Util.generateCsSQLException(Util.java:201)\r\n        at org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:391)\r\n        at org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:346)\r\n        at org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:2201)\r\n        at org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:81)\r\n        at org.apache.derby.impl.jdbc.EmbedResultSet.closeOnTransactionError(EmbedResultSet.java:4338)\r\n        at org.apache.derby.impl.jdbc.EmbedResultSet.movePosition(EmbedResultSet.java:467)\r\n        at org.apache.derby.impl.jdbc.EmbedResultSet.next(EmbedResultSet.java:371)\r\n        at org.apache.derbyTesting.functionTests.tests.store.IndexSplitDeadlockTest.testBTreeForwardScan_fetchRows_resumeAfterWait_nonUnique_split(IndexSplitDeadlockTest.java:489)\r\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:79)\r\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n        at org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:106)\r\n        at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)\r\n        at junit.extensions.TestSetup$1.protect(TestSetup.java:19)\r\n        at junit.extensions.TestSetup.run(TestSetup.java:23)\r\n        at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)\r\n        at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)\r\n        at junit.extensions.TestSetup$1.protect(TestSetup.java:19)\r\n        at junit.extensions.TestSetup.run(TestSetup.java:23)\r\n        at org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)\r\nCaused by: ERROR 40XL1: A lock could not be obtained within the time requested at org.apache.derby.iapi.error.StandardException.newException(StandardException.java:276)\r\n        at org.apache.derby.impl.services.locks.ConcurrentLockSet.lockObject(ConcurrentLockSet.java:602)\r\n        at org.apache.derby.impl.services.locks.ConcurrentLockSet.zeroDurationLockObject(ConcurrentLockSet.java:855)\r\n        at org.apache.derby.impl.services.locks.AbstractPool.zeroDurationlockObject(AbstractPool.java:297)\r\n        at org.apache.derby.impl.store.raw.xact.RowLocking2nohold.lockRecordForRead(RowLocking2nohold.java:89)\r\n        at org.apache.derby.impl.store.access.heap.HeapController.lockRow(HeapController.java:520)\r\n        at org.apache.derby.impl.store.access.heap.HeapController.lockRow(HeapController.java:638)\r\n        at org.apache.derby.impl.store.access.btree.index.B2IRowLocking3.lockRowOnPage(B2IRowLocking3.java:309)\r\n        at org.apache.derby.impl.store.access.btree.index.B2IRowLocking3._lockScanRow(B2IRowLocking3.java:599)\r\n        at org.apache.derby.impl.store.access.btree.index.B2IRowLockingRR.lockScanRow(B2IRowLockingRR.java:105)\r\n        at org.apache.derby.impl.store.access.btree.BTreeForwardScan.fetchRows(BTreeForwardScan.java:305)\r\n        at org.apache.derby.impl.store.access.btree.BTreeScan.fetchNextGroup(BTreeScan.java:1585)\r\n        at org.apache.derby.impl.sql.execute.BulkTableScanResultSet.reloadArray(BulkTableScanResultSet.java:327)\r\n        at org.apache.derby.impl.sql.execute.BulkTableScanResultSet.getNextRowCore(BulkTableScanResultSet.java:282)\r\n        at org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.getNextRow(BasicNoPutResultSetImpl.java:460)\r\n        at org.apache.derby.impl.jdbc.EmbedResultSet.movePosition(EmbedResultSet.java:427)\r\n        ... 34 more\r\n\r\nFAILURES!!!\r\nTests run: 9258,  Failures: 0,  Errors: 1\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-06-15T18:31:39.939+0000","updated":"2009-06-15T18:31:39.939+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12719838","id":"12719838","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Yes, that test was added here. It requires some coordination between two threads, so my first guess would be that there is a timing issue in the test. Please file a separate JIRA issue for this failure. Thanks.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2009-06-15T22:53:04.538+0000","updated":"2009-06-15T22:53:04.538+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12375269/comment/12719859","id":"12719859","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Knut, thanks for looking at the stack trace. I added jira DERBY-4273 for the test failure. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2009-06-15T23:53:02.147+0000","updated":"2009-06-15T23:53:02.147+0000"}]},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-2991/votes","votes":13,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i06rkv:"}}