{"expand":"renderedFields,names,schema,transitions,operations,editmeta,changelog","id":"12463019","self":"https://issues.apache.org/jira/rest/api/latest/issue/12463019","key":"DERBY-4631","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/10594","id":"10594","key":"DERBY","name":"Derby","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=10594&avatarId=10122","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=10594&avatarId=10122","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=10594&avatarId=10122","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=10594&avatarId=10122"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10090","id":"10090","description":"DB related projects","name":"DB"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12315434","id":"12315434","description":"Head of 10.6 branch as of 2014-01-13","name":"10.6.2.4","archived":false,"released":false},{"self":"https://issues.apache.org/jira/rest/api/2/version/12315902","id":"12315902","description":"Head of 10.7 branch as of 2010-11-29","name":"10.7.1.4","archived":false,"released":false},{"self":"https://issues.apache.org/jira/rest/api/2/version/12323456","id":"12323456","description":"Third release on the 10.8 branch","name":"10.8.3.0","archived":false,"released":true,"releaseDate":"2012-11-16"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12316344","id":"12316344","description":"First release on the 10.9 branch","name":"10.9.1.0","archived":false,"released":true,"releaseDate":"2012-06-25"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12310220":"2010-07-20 17:52:49.445","customfield_12312322":null,"customfield_12312323":null,"customfield_12310420":"24378","customfield_12310222":"1_*:*_1_*:*_67228194855_*|*_6_*:*_1_*:*_4244196319_*|*_5_*:*_2_*:*_3633887980_*|*_4_*:*_1_*:*_265974000","customfield_12312320":null,"customfield_12312321":null,"customfield_12312120":null,"customfield_12312121":null,"resolutiondate":"2012-09-14T22:20:42.368+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312326":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312324":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-4631/watchers","watchCount":2,"isWatching":false},"created":"2010-04-26T13:36:29.227+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"labels":["derby_triage10_8"],"customfield_12312333":null,"customfield_12312334":null,"customfield_12310310":"11.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12313727","id":"12313727","description":"Feature release","name":"10.6.1.0","archived":false,"released":true,"releaseDate":"2010-05-18"}],"customfield_12311120":null,"customfield_12312330":null,"issuelinks":[{"id":"12348180","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12348180","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"inwardIssue":{"id":"12542441","key":"DERBY-5613","self":"https://issues.apache.org/jira/rest/api/2/issue/12542441","fields":{"summary":"Queries with group by column not included in the column list for JOIN(INNER or OUTER) with NATURAL or USING does not fail","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/1","description":"The issue is open and ready for the assignee to start work on it.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/open.png","name":"Open","id":"1","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/2","id":2,"key":"new","colorName":"blue-gray","name":"New"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}},{"id":"12357615","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12357615","type":{"id":"12310040","name":"Required","inward":"is required by","outward":"requires","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/12310040"},"inwardIssue":{"id":"12607119","key":"DERBY-5923","self":"https://issues.apache.org/jira/rest/api/2/issue/12607119","fields":{"summary":"10.8 Backport issue (Fall 2012)","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/3","id":"3","description":"A task that needs to be done.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/task.png","name":"Task","subtask":false}}}}],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"customfield_12312337":null,"customfield_12312338":null,"updated":"2013-06-17T09:27:18.311+0000","customfield_12312335":null,"customfield_12311720":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/11408","id":"11408","name":"SQL"}],"timeoriginalestimate":null,"description":"SQL:2003 says that the join columns in a natural join or in a named\r\ncolumns join should be added to the select list by coalescing the\r\ncolumn from the left table with the column from the right table.\r\n\r\nSection 7.7, <joined table>, syntax rules:\r\n\r\n> 1) Let TR1 be the first <table reference>, and let TR2 be the <table\r\n> reference> or <table factor> that is the second operand of the\r\n> <joined table>. Let RT1 and RT2 be the row types of TR1 and TR2,\r\n> respectively. Let TA and TB be the range variables of TR1 and TR2,\r\n> respectively. (...)\r\n\r\nand\r\n\r\n> 7) If NATURAL is specified or if a <join specification> immediately\r\n> containing a <named columns join> is specified, then:\r\n(...)\r\n> d) If there is at least one corresponding join column, then let SLCC\r\n> be a <select list> of <derived column>s of the form\r\n>\r\n> COALESCE ( TA.C, TB.C ) AS C\r\n>\r\n> for every column C that is a corresponding join column, taken in\r\n> order of their ordinal positions in RT1.\r\n\r\nFor a right outer join, Derby doesn't use COALESCE(TA.C, TB.C), but\r\nrather just TB.C (the column in the right table) directly.\r\n\r\nThis is in most cases OK, because COALESCE(TA.C, TB.C) = TB.C is an\r\ninvariant in a right outer join. (Because TA.C is either NULL or equal\r\nto TB.C.)\r\n\r\nHowever, in a database with territory-based collation, equality\r\nbetween two values does not mean they are identical, especially now\r\nthat the strength of the collator can be specified (DERBY-1748).\r\n\r\nTake for instance this join:\r\n\r\nij> connect 'jdbc:derby:testdb;create=true;territory=en_US;collation=TERRITORY_BASED:SECONDARY';\r\nij> create table big(x varchar(5));\r\n0 rows inserted/updated/deleted\r\nij> insert into big values 'A','B','C';\r\n3 rows inserted/updated/deleted\r\nij> create table small(x varchar(5));\r\n0 rows inserted/updated/deleted\r\nij> insert into small values 'b','c','d';\r\n3 rows inserted/updated/deleted\r\nij> select x, t1.x, t2.x, coalesce(t1.x, t2.x) from small t1 natural right outer join big t2;\r\nX    |X    |X    |4    \r\n-----------------------\r\nA    |NULL |A    |A    \r\nB    |b    |B    |b    \r\nC    |c    |C    |c    \r\n\r\n3 rows selected\r\n\r\nI believe that the expected result from the above query is that the\r\nfirst column should have the same values as the last column. That is,\r\nthe first column should contain {'A', 'b', 'c'}, not {'A', 'B', 'C'}.","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12310200":[{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10367","value":"Deviation from standard","id":"10367"},{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10366","value":"Wrong query result","id":"10366"}],"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"aggregatetimeestimate":null,"customfield_12312022":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12310921":null,"customfield_12310920":"35424","summary":"Wrong join column returned by right outer join with NATURAL or USING and territory-based collation","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"subtasks":[],"customfield_12310090":[{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10101","value":"Release Note Needed","id":"10101"},{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10424","value":"Repro attached","id":"10424"}],"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"customfield_12310291":null,"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"environment":null,"customfield_12311020":null,"customfield_12310050":{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10052","value":"Normal","id":"10052"},"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"startAt":0,"maxResults":35,"total":35,"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/12864741","id":"12864741","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"This problem also makes us accept some statements that should not be accepted. For example:\r\n\r\nSELECT country,count(country) FROM\r\nCOUNTRIES JOIN CITIES USING (COUNTRY) group by countries.country\r\n\r\nHere, the query should be rejected because countries.country is not specified in the select list. However, it's accepted because we replace the column country with countries.country instead of coalesce(countries.country, cities.country).","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2010-05-06T11:50:07.219+0000","updated":"2010-05-06T11:50:07.219+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/12890350","id":"12890350","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"It seems like what we need is to replace the join column references(which are not tied to the join table specifically) in select column list to COALESCE functions. Additionally, in case of a named join order, the join column names in USING clause should be replaced with COALESCE function. eg of each of the cases\r\nselect x, t1.x, t2.x, coalesce(t1.x, t2.x) from small t1 natural right outer join big t2; \r\nThe first column in the select above which is x should be internally replaced with coalesce(t1.x, t2.x) \r\n\r\nSELECT country,count(country) FROM COUNTRIES JOIN CITIES USING (COUNTRY) group by countries.country \r\nThe first column in the select and the COUNTRY in USING clause should be replaced with coalesce internally.\r\n\r\nI looked at the code a bindExpressions code in impl.sql.compile.JoinNode There, we already have a code to recognize natural join\r\n        if (naturalJoin) {\r\n            usingClause = getCommonColumnsForNaturalJoin();\r\n        }\r\n\r\nI think after this code, we should go through join columns in select column list and in USING clause and replace them with corresponding COALESEC functions.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2010-07-20T17:52:49.445+0000","updated":"2010-07-20T17:52:49.445+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13164165","id":"13164165","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I debugged the code to figure out what (and where) are we doing in the code which causes us to give wrong results for join column in case of territory based database and right outer join with NATURAL or USING clause. As Knut pointed out earlier in this jira, as per the SQL spec, \"the join columns in a natural join or in a named columns join should be added to the select list by coalescing the column from the left table with the column from the right table. \" What I have found is that Derby decides to pick up join column's value from the left table when we are working with natural left outer join and it picks up the join column's value from the right table when we are working with natural right outer join. This is not a problem when we are dealing with non-territory based databases but the assumption to rely on just one table's join column is incorrect when working with territory based databases. Following is the test case I used for debugging which further explains Derby's current implementation.\r\n\r\nconnect 'jdbc:derby:db1;create=true;territory=en_US;collation=TERRITORY_BASED:SECONDARY'; \r\ncreate table big(x varchar(5)); \r\ninsert into big values 'A','B', null; \r\ncreate table small(x varchar(5)); \r\ninsert into small values 'b','c', null; \r\nselect * from small t1 natural left outer join big t2;\r\nselect * from small t1 natural right outer join big t2;\r\n\r\nFor both natural left outer join and natural right outer join, at execution time, we create a merged row which has columns merged from the left and right tables. The column(in my example, there is only one column)s in the select sql maps to a column from the merged row. The mapping is determined at the sql compile phase. \r\nIn the case of 'select * from small t1 natural left outer join big t2', there will be three merged rows with 2 columns each\r\n'b'  'B'\r\n'c'  null\r\nnull null\r\nAnd for natural left outer join, the generated code has column in the select SQL map to the first column in the merged row. This will always work fine even in a territory based database because as per the SQL standards, the column x should be equivalent to the return value of coalesce(t1.x, t2.x). Since we are working with left outer join, then if the first column in the merged row is null, then even the 2nd column(from the right table) will be null and hence it is ok to always pick up the value from the 1st column in the merged row. This mapping will always lead column x to have the same value as coalesce(t1.x, t2.x).\r\n\r\nBut for a territory based database, we can't count on a logic like that for natural right outer join. The way Derby works right now, the column x in the select always gets mapped to the 2nd column in the merged row. In the case of 'select * from small t1 natural right outer join big t2', there will be three merged rows with 2 columns each\r\nnull 'A'\r\n'b'  'B'\r\nnull null\r\nAnd for natural right outer join, the generated code has column in the select SQL map to the second column in the merged row. This will work fine in a non-territory database, because if column 1 in the merged row has a non-null value, then it will always be the same value as the column 2 in the merged row. But in our example, with territor based database(with SECONDARY strength, meaning it is case insensitive comparison), values 'B' and 'b' are considered equal. Hence the coalesce(t1.x, t2,x) will not be same as value in the 2nd column of the merged row. For natural right outer join with the data given in the example above, \r\ncoalesce(t1.x, t2,x) will return 'A', 'b' and null. But with the mapping of column x in the SELECT to the 2nd column in the merged row will return 'A', 'B' and null thus returning data which does not comply with SQL standard which says that column x's value should be the return value of coalesce(t1.x, t2.x). So it seems like may be we need some of kind projection in case of natural right outer join (rather than simple column mapping to the 2nd column which is what happens right now) so that we look at both the columns in the merged row to determine the value of column x.\r\n\r\nHope this explanation helps understand what Derby is doing internally and based on that, we can come up with some proposal to fix the issue.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2011-12-07T05:47:44.952+0000","updated":"2011-12-07T05:47:44.952+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13165798","id":"13165798","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"As mentioned earlier in this jira, the SQL spec says that the join columns in a natural join or in a named columns join should be added to the select list by coalescing the column from the left table with the column from the right table. Derby implements the SQL spec by using left table's column value when doing natural left outer join. For natural right outer join, Derby uses the right\r\ntable's join column value. This logic correctly implements the SQL spec requirements for both left and right outer joins for non-territory based database and for left outer join for territory based database but the logic for the natural right outer join doesn't work for territory based database. Taking the example from earlier in this jira\r\ncreate table big(x varchar(5)); \r\ninsert into big values 'A','B'; \r\ncreate table small(x varchar(5)); \r\ninsert into small values 'b','c'; \r\n\r\nFor this data, following shows that selecting the join column doesn't give the same results as coalesce(t1.x, t2.x)\r\nselect x, t1.x t1x, t2.x t2x, coalesce(t1.x, t2.x) cx from small t1 natural right outer join big t2;\r\nX    |T1X  |T2X  |CX   \r\n--------------------------------------------------------------------\r\nA    |NULL |A    |A    \r\nB    |b         |B    |b    \r\n\r\nFor the 1st row above, coalesce(t1.x, t2.x) will return 'A' and that is what we got for the join column in that row, so we are good for the 1st row. But for the 2nd row, coalesce(t1.x, t2.x) will return 'b' whereas the join column for that row shows 'B'. This is because as per Derby's implementation, for natural right outer join, we just pick the value from the right table row which for the 2nd row happens to be 'B'. \r\n\r\nWe can leave the logic as it is for natural left outer joins since it works fine for both territory and non-terrtory based databases. We can also leave the logic untouched for natural right outer joins for non-territory based databases. The only broken case is natural right outer join in case of territory based database. For this specific case, we can generate a project restrict resultset which will pick the join column's value based on following logic\r\n1)if the left table's column value is null then pick up the right table's column's value. \r\n2)If the left table's column value is non-null, then pick up that value\r\n\r\nI have not done much work in code generation and hence wanted to run this logic by the community to see if anyone has any feedback and if this looks like the correct approach to solve the problem. Any suggestions on alternative/better fix?\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2011-12-09T03:00:22.739+0000","updated":"2011-12-09T03:00:22.739+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13170002","id":"13170002","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"If that approach doesn't work, another possibility might be to insert a CoalesceFunctionNode in JoinNode.buildRCL() or perhaps in JoinNode.getAllResultColumns().","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2011-12-15T07:39:53.003+0000","updated":"2011-12-15T07:39:53.003+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13185724","id":"13185724","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Want to copy the commit comments from the revision r1230873. After the commit comments, I have proposal for 2 possible fixes for the problems described in the commit comments.\r\n*************************************\r\nDERBY-4631 Wrong join column returned by right outer join with NATURAL or USING and territory-based collation\r\n\r\nI am adding more tests for this jira to show the kind of joins and queries that are impacted by this defect.\r\n\r\nIn short, any join query which is either a NATURAL join or has a USING clause can run into the two problems as described in this jira.\r\n\r\nProblem 1)As per SQL spec, the join column's value should be derived by\r\n               COALESCE(leftTable.joinColumn, rightTable.joinColumn).\r\n       But Derby has it's own rule for deriving the join column's value. Derby's implementation, for a right outer join, gets the join column's value from the right table and for left outer join, it gets the value from the left table. This logic works for most cases, but it can give incorrect value for a right outer join (with NATURAL JOIN or USING clause) in case of a territory based database. Additionally, the join column in the SELECT list(with NATURAL JOIN or USING clause) gets associated with the left table's join column(for inner joins and left outer joins) or it gets associated with the right table's join column(for rihgt outer joins). Since SQL spec requires the join column to be COALESCE ( leftTable.C, rightTable.C ) AS C, the join column should not be really associated with any of the 2 join tables.\r\n\r\nProblem 2)The Derby's assocation of join column to left or right table as described in problem 1) causes it to allow incorrect queries. eg query\r\nselect i from t1_D3880 inner join t2_D3880 USING(i) group by t1_D3880.i;\r\n       The query above works because join column i got associated with left table which is t1_D3880. If the query was rewritten to do the group by on right table, it would fail.\r\nselect i from t1_D3880 inner join t2_D3880 USING(i) group by t2_D3880.i;\r\n*************************************\r\n\r\n\r\nThere are 2 solutions that we have talked about in the jira. \r\nSolution 1)Currently, at execution time, Derby creates a merged row for join column which has columns merged from the left and right tables and picks up the 1st column's value for a left outer join and picks up the 2nd column's value for right outer join. (I don't remember debugging the inner join case but from it's behavior, it probably also picks up the value from the 1st column's value just like left outer join).\r\n\tRather than this logic, we can change the code to pick the join column's value based on following logic \r\n1)if the left table's column value is null then pick up the right table's column's value. \r\n2)If the left table's column value is non-null, then pick up that value \r\n\tWe can implement this logic for all kinds of joins except the cross join(which doesn't allow NATURAL\tJOIN or USING clause and hence we will never be able to run in the problem described by this jira or we can implement the logic only for right outer joins which is the only case which will run into problem because we do not implement COALESCE.  The problem with this solution is it will not catch Problem 2) described above because join column is getting associated with left table or right table depending on what kind of join we are working with.\r\nSolution 2)This solution will take care of all the problems described earlier. With this solution, at bind time, we should replace the join column with COALESCE as described by SQL spec. This is a cleaner  solution then solution 1) because it takes care of all the problem cases but it can cause existing queries with group by using table name for association for join columns will stop working and will have to be rewritten. \r\n\r\nI lean towards solution 2) for it's cleanliness and direct implementation of SQL spec COALESCE behavior for join columns but I am interested to know what are the community's thoughts on this.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-01-13T18:13:52.468+0000","updated":"2012-01-13T18:13:52.468+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13185752","id":"13185752","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"So far you have added a number of tests, and some of the comments seem to indicate some of the tests\r\nare coded so they pass, but that they are actually exhibiting the wrong behavior.  I find this confusing, but\r\nknow you prefer this methodology.  Could you at least make it clearer in the test comments somehow which\r\nof the test cases are actually bugs.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2012-01-13T18:57:01.130+0000","updated":"2012-01-13T18:57:01.130+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13185764","id":"13185764","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"I am concerned by the performance characteristics of you proposed solution #2.  Could you go into more detail on what it involves and what\r\nset of queries it will affect.  I am most interested in what happens at execution time for a large join.  I think my most basic question is in a \r\n1 to 1 million row join will you be adding 1 million new function calls for the coalesce, or is this somehow optimized after bind?  I am assuming\r\nthat the reason the code does not currently do an explicit coalesce already is an optimization, where it was assumed the implementation \r\nbehavior would match the external behavior that the spec is describing.\r\n\r\nSolution 1 seems safer to me, and if implemented we should log the SQL syntax problems you have uncovered in a separate JIRA.  \r\n\r\nAlso can you explicitly give some queries that currently work today that will not after your change, so that the compatibility impact of your\r\nsolutions can be understood.  Do those queries return correct results?  Once you list a few of these queries maybe we can try them on other\r\nplatforms to verify that they are incorrect SQL.  ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2012-01-13T19:07:42.213+0000","updated":"2012-01-13T19:07:42.213+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13185859","id":"13185859","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Revision 1231296 has addressed Mike's concern about the tests. The commit comment was as follows\r\n******************************\r\nDERBY-4631 Wrong join column returned by right outer join with NATURAL or USING and territory-based collation\r\n\r\nAdding comments to some of the tests, stating that Derby is allowing incorrect behavior because of DERBY-4631. Once the jira is fixed, these tests should start failing and would need to be changed to show the correct behavior.\r\n******************************\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-01-13T21:14:31.837+0000","updated":"2012-01-13T21:14:31.837+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13187090","id":"13187090","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Here are answers to some of Mike's comments\r\n********************************************************\r\nMike's comment\r\nI am concerned by the performance characteristics of you proposed solution #2. Could you go into more detail on what it involves and what set of queries it will affect\r\n********************************************************\r\nAs part of solution #2, I am proposing that during the bind phase, we are going through the join query's column list, we replace the join column in the list with coalesce function and make sure that newly added coalesce node to the select list gets bound. This node will generate a call to following method in DataTypejava\r\n\tpublic DataValueDescriptor coalesce(DataValueDescriptor[] argumentsList, DataValueDescriptor returnValue)\r\n\t\t\t\t\t\tthrows StandardException\r\n\t{\r\n\t\t// arguments list should have at least 2 arguments\r\n\t\tif (SanityManager.DEBUG)\r\n\t\t{\r\n\t\t\tSanityManager.ASSERT(argumentsList != null,\r\n\t\t\t\t\"argumentsList expected to be non-null\");\r\n\t\t\tSanityManager.ASSERT(argumentsList.length > 1,\r\n\t\t\t\t\"argumentsList.length expected to be > 1\");\r\n\t\t}\r\n\r\n\t\t/* Walk the arguments list until we find a non-null value. Otherwise we will return null\r\n\t\t */\r\n\t\tint index;\r\n\t\tfor (index = 0; index < argumentsList.length; index++)\r\n\t\t{\r\n\t\t\tif (!(argumentsList[index].isNull()))\r\n\t\t\t{\r\n\t\t\t\treturnValue.setValue(argumentsList[index]);\r\n\t\t\t\treturn returnValue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturnValue.setToNull();\r\n\t\treturn returnValue;\r\n\r\n\t}\r\nIn our case, there will always be only 2 arguments to the coalesce function and the first non-null value will have us return with that value from the method and if for some reason, if both the values are null, then we will return null value. All this work will be done for joins using NATURAL JOINS or USING clause which can happen for inner joins, left outer join and right outer joins. eg of each of these kind of joins\r\nCREATE TABLE derby4631_t1(x varchar(5));\r\nINSERT INTO derby4631_t1 VALUES 'A','B';\r\nCREATE TABLE derby4631_t2(x varchar(5));\r\nINSERT INTO derby4631_t2 VALUES 'b','c';\r\n\r\nSELECT x FROM derby4631_t2 NATURAL INNER JOIN derby4631_t1;\r\nSELECT x FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1;\r\nSELECT x FROM derby4631_t2 NATURAL LEFT OUTER JOIN derby4631_t1;\r\nselect x from derby4631_t2 INNER JOIN derby4631_t1 USING(x);\r\nselect x from derby4631_t2 RIGHT OUTERJOIN derby4631_t1 USING(x);\r\nselect x from derby4631_t2 LEFT OUTERJOIN derby4631_t1 USING(x);\r\n\r\nCurrently, at execution time, Derby already does special handling to figure out if it is dealing with left outer join or right outer join and based on that, it determines whether it should pick up the value from the left column or the right column in the merged row(consisting of 2 columns, join column from left and join column from right) for each of the join columns. Instead of this, now we will let coalesce pick up \r\n1)the left column's value if it is not null. If it is null then\r\n2)pick up the right column's value if it is not null. If it is null then simply return null.\r\n\r\nSo, there is special code happening with both the existing Derby behavior and proposed Derby behavior but at this point, I am not sure how much more/same/less performance impact the new changes might cause. This is all in theory at this point. I have never worked on the code to replace a user supplied column from the select list with another kind of node at bind time, so if we do decide to go this path, I will be greatful to have community's knowledge on this kind of change. I will work on it my own too to figure out what needs to be done if we decide to go with this solution.\r\n\r\n********************************************************\r\nMike's comment\r\nI am assuming that the reason the code does not currently do an explicit coalesce already is an optimization, where it was assumed the implementation behavior would match the external behavior that the spec is describing, \r\n********************************************************\r\nYou are probably right Mike, but I am not sure if coalesce functionality was available in Derby when joins were implemented. It could very well be that we had coalesce available but we didn't use it for optimization reasons but I just wanted to raise that it might be a possibility that we never have had coalesce available.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-01-16T19:05:55.768+0000","updated":"2012-01-16T19:05:55.768+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13187453","id":"13187453","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"*********************************************************************\r\nMike's comment\r\n(With solution 2) I think my most basic question is in a 1 to 1 million row join will you be adding 1 million new function calls for the coalesce, or is this somehow optimized after bind?\r\n*********************************************************************\r\n\r\nYes, if the join column is part of the join query (say as SELECT list or GROUP BY, WHERE clause etc), then we will be calling it for every qualified row in join. At this point, I think if join column is only part of USING clause or used internally through NATURAL join to do equi join, then I do not think we will have to generate coalesce function for the join columns.\r\n\r\nI debugged through the existing code more and found that to do equijoin for USING clause or NATURAL join, we generate merged row which includes the necessary join columns values from both sides (for USING clause, the necessary join column(s) will be what was specified with the USING clause, for NATURAL joins, it will be all the join columns). If we find that the join column is getting referenced outside of the equi join, then in order to get the join column's value, we do the mapping of the join column to the merged row's column (the mapping happens to either the left table's column value in merged row(if we are dealing with inner join or left outer join) or to the right table's column value(if we are dealing with right outer join)).\r\n\r\nIf we go with Solution 1), then this mapping of join column to merge row will need to change so that we look at teft table's column value first. If it is null, then we should pick up the right table's column value. This should happen no matter if we are dealing with inner join, left outer join or right outer join with natural or uisng clause.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-01-17T05:09:13.637+0000","updated":"2012-01-17T05:09:13.637+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13187459","id":"13187459","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"********************************************************\r\nMike's comment\r\nAlso can you explicitly give some queries that currently work today that will not after your change, so that the compatibility impact of your solutions can be understood\".\r\n********************************************************\r\nFollowing queries will be fixed by both the solutions.\r\njava -Dij.exceptionTrace=true org.apache.derby.tools.ij\r\nconnect 'jdbc:derby:db1;create=true;territory=en_US;collation=TERRITORY_BASED:SECONDARY'; \r\nCREATE TABLE derby4631_t1(x varchar(5));\r\nINSERT INTO derby4631_t1 VALUES 'A','B';\r\nCREATE TABLE derby4631_t2(x varchar(5));\r\nINSERT INTO derby4631_t2 VALUES 'b','c';\r\nSELECT x, coalesce(derby4631_t2.x, derby4631_t1.x) FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1;\r\nselect x, coalesce(derby4631_t2.x, derby4631_t1.x) from derby4631_t2 RIGHT OUTER JOIN derby4631_t1 USING(x);\r\n\r\nThe 2 select queries above return following today(which is incorrect)\r\nX    |2\r\n-----------\r\nA    |A\r\nB    |b\r\n2 rows selected\r\n\r\nWith both the solutions proposed in this jira, they will return following(correct results)\r\nX    |2\r\n-----------\r\nA    |A\r\nb    |b\r\n2 rows selected\r\n\r\nAdditionally, each of the 2 proposed solutions affect few other queries, but unfortunately not the same way.\r\n\r\nHere is example query that will be affected by solution 1).\r\nSELECT x FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1 group by derby4631_t1.x;\r\nSince join column x can have different results with solution 1(compared to existing behavior), the group by query below will result in different results too. This is kind of obvious but still wanted to point out how different results for join columns can affect join queries with group by/having clause etc\r\n\r\nWith solution 2), the group by query above will fail because column derby4631_t1.x is not part of the SELECT columns list. With solution 2), join column x is not going to be assoicated with left table(in case of left outer join and inner joins) or right table(in case of right outer join). Because of that, the group by will result in compilation error but column derby4631_t1.x is not in the SELECT list.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-01-17T05:30:46.139+0000","updated":"2012-01-17T05:30:46.139+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13188739","id":"13188739","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"With solution 1), we will need to know where the current code generation happens for join columns. Solution 1) requires that we change the code generation to following logic.\r\n1)if the left table's join column value is null then pick up the right table's join column's value. \r\n2)If the left table's join column value is non-null, then pick up that value \r\n\r\nFollowing is what I found while looking for code generation logic for the join columns.\r\n\r\nIn the bind phase of a query, we start looking at result columns and assigning virutal column numbers to them (impl.sql.compile.ResultColumn:virtualColumnId). These virtual column ids are used to find mapping for those columns into runtime resultset for the query.\r\n\r\nconnect 'jdbc:derby:db1;create=true;territory=en_US;collation=TERRITORY_BASED:SECONDARY'; \r\nCREATE TABLE derby4631_t1(x varchar(5)); \r\nINSERT INTO derby4631_t1 VALUES 'A','B'; \r\nCREATE TABLE derby4631_t2(x varchar(5)); \r\nINSERT INTO derby4631_t2 VALUES 'b','c'; \r\nSELECT x FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1; \r\n\r\nFor the NATURAL JOIN query above, an equi-join is generated which will be derby4631_t2.x = derby4631_t1.x. For this equi join, the join column x from left table(derby4631_t2) will get virtual column id of 1 and join column x from right table(derby4631_t1) will get virtual column id of 2. The column x in the SELECT query in Derby today gets associated with right table in case of RIGHT OUTER JOIN and hence that column's virtual column id is also 2. At the time of code generation, we use this information to decide what column position from the run time resultset would be used to get the values. Following is the stack trace of where the code generation for join column happens.\r\n\r\nThread [main] (Suspended (breakpoint at line 1421 in ProjectRestrictNode))\t\r\n\tProjectRestrictNode.generateMinion(ExpressionClassBuilder, MethodBuilder, boolean) line: 1421\t\r\n\tProjectRestrictNode.generate(ActivationClassBuilder, MethodBuilder) line: 1334\t\r\n\tScrollInsensitiveResultSetNode.generate(ActivationClassBuilder, MethodBuilder) line: 109\t\r\n\tCursorNode.generate(ActivationClassBuilder, MethodBuilder) line: 641\t\r\n\tCursorNode(StatementNode).generate(ByteArray) line: 345\t\r\n\tGenericStatement.prepMinion(LanguageConnectionContext, boolean, Object[], SchemaDescriptor, boolean) line: 518\t\r\n\tGenericStatement.prepare(LanguageConnectionContext, boolean) line: 97\t\r\n\tGenericLanguageConnectionContext.prepareInternalStatement(SchemaDescriptor, String, boolean, boolean) line: 1103\t\r\n\tEmbedStatement40(EmbedStatement).execute(String, boolean, boolean, int, int[], String[]) line: 610\t\r\n\tEmbedStatement40(EmbedStatement).execute(String) line: 559\t\r\n\tij.executeImmediate(String) line: 367\t\r\n\tutilMain.doCatch(String) line: 527\t\r\n\tutilMain.runScriptGuts() line: 369\t\r\n\tutilMain.go(LocalizedInput[], LocalizedOutput) line: 245\t\r\n\tMain.go(LocalizedInput, LocalizedOutput) line: 229\t\r\n\tMain.mainCore(String[], Main) line: 184\t\r\n\tMain.main(String[]) line: 75\t\r\n\tij.main(String[]) line: 59\t","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-01-18T22:10:22.712+0000","updated":"2012-01-18T22:10:22.712+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13191280","id":"13191280","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"The code generation code in impl.sql.compile.ConditionalNode:generateExpression might be a good resource for us to make make the code generation changes for NATURAL JOIN's join column in the SELECT query. ConditionalNode generates \"if then else\" code which is similar to what solution 1) will require, ie if lefTablJoinColumn is null, then use rightTableJoinColumnValue else use leftTableJoinColumnValue.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-01-23T17:32:15.871+0000","updated":"2012-01-23T17:32:15.871+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13191655","id":"13191655","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I stepped through the ConditionalNode's code generation logic to see how \"if..then..else..\" code is generated. Based on that, I have following pseudo code for code generation for solution 1). The following psuedo code is for generating if(lefTablJoinColumnValue is null) then return rightTableJoinColumnValue else return lefTablJoinColumnValue. I have not done recent work in the code generation part and would appreciate feedback if the psuedo code looks incorrect. I will next work on trying to identify how to make this pseudo code kick in for ResultColumn code generation if we are dealing with join column.\r\n\r\n\t\tString\treceiverType = ClassName.DataValueDescriptor;\r\n\t\tString resultTypeName = \r\n\t\t\tgetTypeCompiler(DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BOOLEAN).getTypeId()).interfaceName();\r\n\r\n\t\t//Following will generate if(lefTablJoinColumnValue is null)\r\n\t\t//Then call generateExpression on left Table's column\r\n\t\tLeftTableColumn.generateExpression(acb, mb);\t\t\t\r\n\t\tmb.cast(receiverType); // cast the method instance\r\n\t\tmb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null,\r\n\t\t\t\"isNullOp\",resultTypeName, 0);\r\n\t\tmb.cast(ClassName.BooleanDataValue);\r\n\t\tmb.push(true);\r\n\t\tmb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, \"equals\", \"boolean\", 1);\r\n\r\n\t\t//Following will generate then part of the if condition by generating expression for rightTablJoinColumnValue\r\n\t\tmb.conditionalIf();\r\n\t\t  ((ValueNode) RightTableColumn.generateExpression(acb, mb);\r\n\t\t//Following will generate else part of the if condition by generating expression for lefTablJoinColumnValue \r\n\t\tmb.startElseCode();\r\n\t\t  ((ValueNode) LeftTableColumn.generateExpression(acb, mb);\r\n\t\tmb.completeConditional();\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-01-24T00:07:26.191+0000","updated":"2012-01-24T00:07:26.191+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13196694","id":"13196694","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I have a patch which is not ready for commit. It is a work in progress for the solution 1) proposed earlier in the jira which is as follows\r\nSolution 1) requires that we change the code generation to following logic. \r\n1)if the left table's join column value is null then pick up the right table's join column's value. \r\n2)If the left table's join column value is non-null, then pick up that value \r\nWe should have the solution 1) kickin for only RIGHT OUTER JOIN with USING clause or NATURAL JOIN. \r\nLEFT OUTER JOINs and INNER JOINs with USING clause or NATURAL JOIN will work correctly with current Derby logic which is to always pickup the left table's join column value. \r\nThis will work for LEFT OUTER JOINs and INNER JOINs with USING clause or NATURAL JOIN in both territory and non-territory based databases\r\n\r\n\r\nThe attached patch now makes the following query return the correct results\r\njava -Dij.exceptionTrace=true org.apache.derby.tools.ij \r\nconnect 'jdbc:derby:db1;create=true;territory=en_US;collation=TERRITORY_BASED:SECONDARY'; \r\nCREATE TABLE derby4631_t1(x varchar(5)); \r\nINSERT INTO derby4631_t1 VALUES 'A','B'; \r\nCREATE TABLE derby4631_t2(x varchar(5)); \r\nINSERT INTO derby4631_t2 VALUES 'b','c'; \r\nSELECT x FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1; \r\nij> X\r\n-----\r\nA\r\nb\r\n\r\nThe patch in it's current state is quite a bit of hacking because currently a ResultColumn does not need to know if it belongs to a Join ResultSet. But with solution 1), if ResultColumn is a join column part of a RIGHT OUTER JOIN with USING/NATURAL JOIN, then we want the join column's value to be determined using the solution 1) described above. For that, a ResultColumn will now need to know if it is part of a RIGHT OUTER JOIN with USING/NATURAL JOIN and it will need to know the column positions of the left table's\r\njoin column and rigt table's join colunm and it will need to know the resultset number of the resultset from which these join colunms's values will be extracted. \r\n\r\nI get these values in this patch by putting extra information related to joins in ResultColunm at bind time and using them at code generation time.\r\n\r\nThis patch may break many other queries and I will continue to work on the patch to make it more stable but I wanted to put the general approach for this solution out sooner than later to see if community has any feedback on keeping the extra information on ResultColumn needed to implement solution 1). Although, all this additional information maintenance is pretty localized and not many files are impacted by this solution. \r\n\r\nNext I plan to work on the patch more to make it stable and do more testing with it to see how it will work for the rest of the queries. \r\n\r\nAlternative to this approach would be to introduce a new kind of compilation node which will be created during the bind phase(unlike most nodes which get created during parsing) when we find that the ResultColumn belongs to Join Node(which means we will still have to do the checking I do in this patch to see if ResultColumn is part of RIGHT OUTER JOIN with USING/NATURAL JOIN but at code generation time, \r\nwe can have the new node do this special code generation which is how we handle all the other special nodes like Conditional If node, Coalesce node etc). This approach of adding new node will require us to somehow fire the binding of the new node after replacing the ResultColumn which was created during the Parse time. At this point, I am unfamiliar with how to replace a node during the bind time with some other node and make it go through the binding step. Also, replacing the ResultColumn with a new node might also impact queries like following where I think order by column from right table is associated with the join column in the select list\r\nSELECT x FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1 ORDER BY derby4631_t1.x; \r\n\r\n\r\nThe files changed by this patch are as follows\r\n$ svn stat -q\r\nM       java\\engine\\org\\apache\\derby\\impl\\sql\\compile\\ResultColumn.java\r\nM       java\\engine\\org\\apache\\derby\\impl\\sql\\compile\\ProjectRestrictNode.java\r\nM       java\\engine\\org\\apache\\derby\\impl\\sql\\compile\\JoinNode.java\r\nM       java\\engine\\org\\apache\\derby\\impl\\sql\\compile\\ResultColumnList.java\r\nM       java\\engine\\org\\apache\\derby\\impl\\sql\\compile\\HashTableNode.java\r\n\r\nFollowing explains the changes in brief for the files touched by this patch\r\nResultColumn.java has additioanl columns to keep RIGHT OUTER JOIN with USING/NATURAL JOIN information. These\r\ncolumns will get updated during bind time if ResultColumn is part of such a join. In my next patch, I think I should be able to remove virtualColumnIdLeftTable and virtualColumnIdRightTable and just get that information\r\nfrom joinResultSet. \r\n\r\nThe signature of ResultColumnList.mapSourceColumns has changed and hence the changes in \r\nProjectRestrictNode.java and HashTableNode.java.\r\n\r\nJoinNode.java - checks if it is RIGHT OUTER JOIN with USING/NATURAL JOIN and if yes, then it marks the right \r\ntable's join column's ResultColumn to recognize that.\r\n\r\nResultColumnList.java in it's code generation logic checks if the ResultColumn is a join column for RIGHT OUTER JOIN with USING/NATURAL JOIN and if yes, then it generates the following code for that column\r\n1)if the left table's join column value is null then pick up the right table's join column's value. \r\n2)If the left table's join column value is non-null, then pick up that value \r\n\r\nWill appreciate any feedback on this patch. I plan to work more on it to clean it up by looking at removing some of the redundant new informaiton in ResultColumn and also to check if there is a better place for code generation for a join column part of RIGHT OUTER JOIN with USING/NATURAL JOIN. I also anticipate existing queries failing with this current patch. I will work on identifying such queries. But I wanted to get feedback on general approach of this patch.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-01-31T04:39:10.505+0000","updated":"2012-01-31T04:39:10.505+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13198885","id":"13198885","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I cam across atleast following 2 queries that both fail with NPE and I am looking into those,\r\n\r\ncreate table t1(a int, b int, c int);\r\ncreate table t2(b int, c int, d int);\r\ncreate table t3(d int, e varchar(5), f int);\r\n\r\ninsert into t1 values (1,2,3),(2,3,4),(4,4,4);\r\ninsert into t2 values (1,2,3),(2,3,4),(5,5,5);\r\ninsert into t3 values \r\n                (2,'abc',3),(4,'def',5),(null,null,null);\r\n\r\nselect c from t1 right join t2 using (c) \r\n                           order by t1.c;\r\nselect c,a+1 from t1 right join t2 using (c);\r\n\r\nThe order by query is failing in generated code whereas the query with \"a+1\" is failing during bind time. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-02-02T15:45:45.458+0000","updated":"2012-02-02T15:45:45.458+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13202037","id":"13202037","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Attaching an updated patch which is still not ready for commit but it fixes two queries listed earlier which were failing with 1st patch, \r\n\r\nWith the query using column a+1 in the select query, I was looking for field name in ResultColumn which would be null for an expression like a+1. Instead, I need to use exposedName which will not be null for an expression. Instead, we internally generate a name for such columns.\r\n\r\nWith the query using order by, I found that in the new code for code generation, I need to let Derby do what it does today for ResultColumns with VirtualColumnNode underneath. Such a case can happen for order by query where we pull columns if needed for order by columns,\r\n\r\nNext I plan to make the code changes less of a hack and then run the derbyall and junit suite to see if we catch any failures. Another thing to do would be to add more RIGHT OUTER JOIN test variations to see if the suggested code changes work fine with it. I will appreciate any suggestion on what kind of RIGHT OUTER JOIN tests can be added to test the functionality.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-02-07T03:09:40.299+0000","updated":"2012-02-07T03:09:40.299+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13208166","id":"13208166","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"DERBY-4631 Wrong join column returned by right outer join with NATURAL or USING and territory-based collation\r\n\r\nI have a patch(DERBY_4631_patch3_diff.txt) which is ready for review and commit. To recap the issue, SQL:2003 says that the join columns in a natural join or in a named columns join should be added to the select list by coalescing the column from the left table with the column from the right table\r\n\r\nDerby has it's on logic to retrieve the join column values. It always picks up join column's value from the left table when we are working with natural left outer join and it picks up the join column's value from the right table when we are working with natural right outer join. \r\n\r\nBut this logic does not work for all cases for right outer join. The fix provided in this patch will pick the join column's value based on following logic(this logic mimics the functionality of COALESCE) \r\n1)if the left table's column value is null then pick up the right table's column's value. \r\n2)If the left table's column value is non-null, then pick up that value \r\n\r\nFollowing are the files impacted by this patch\r\n$ svn stat -q\r\nM       java\\engine\\org\\apache\\derby\\impl\\sql\\compile\\ResultColumn.java\r\nM       java\\engine\\org\\apache\\derby\\impl\\sql\\compile\\JoinNode.java\r\nM       java\\engine\\org\\apache\\derby\\impl\\sql\\compile\\ResultColumnList.java\r\nM       java\\testing\\org\\apache\\derbyTesting\\functionTests\\tests\\lang\\CollationTest.java\r\n\r\nThe changes are as follows\r\nTwo additional fields have been added to ResultColumn.java rightOuterJoinUsingClause  and joinResultSet \r\nrightOuterJoinUsingClause will be set to true for following 2 cases\r\n1)if this column represents the join column which is part of the SELECT list of a RIGHT OUTER JOIN with USING/NATURAL. eg\r\n select c from t1 right join t2 using (c)\r\nThis case is talking about column c as in \"select c\"\r\n2)if this column represents the join column from the right table for predicates generated for the USING/NATURAL of RIGHT OUTER JOIN eg\r\n  select c from t1 right join t2 using (c)\r\nFor \"using(c)\", a join predicate will be created as follows\r\n   t1.c=t2.c\r\nThis case is talking about column t2.c of the join predicate.\r\n\r\njoinResultSet will be non-null for the case 1) above. It will show the association of this result column to the join resultset created for the RIGHT OUTER JOIN with USING/NATURAL. This information along with rightOuterJoinUsingClause will be used during the code generation time.\r\nThese 2 additional fields will be used to identify ResultColumn which belong to a join column in the SELECT\r\nlist and identify ResultColumn which belong to right join column for the predicate generated for USING/NATURAL\r\ncolumns. Additionally, ResultColumn which belong to a join column in the SELECT list will also know about the\r\nJoinNode which they belong to. These 2 pieces of information will then be used at the code generation time\r\nfor join column for RIGHT OUTER JOIN with USING/NATURAL based on following logic\r\n1)if the left table's column value is null then pick up the right table's column's value.\r\n2)If the left table's column value is non-null, then pick up that value \r\n\r\nChanges in JoinNode.java just identifies the ResultColumn which represent the join column from the right table \r\nfor predicates generated for the USING/NATURAL of RIGHT OUTER JOIN eg\r\n     select c from t1 right join t2 using (c)\r\nFor \"using(c)\", a join predicate will be created, t1.c=t2.c. JoinNode changes will set \r\nResultColumn.rightOuterJoinUsingClause flag to true for t2.c\r\n\r\nThe code generation changes have gone into ResultColumnList.java\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-02-15T00:57:01.369+0000","updated":"2012-02-15T00:57:01.369+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13212276","id":"13212276","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I have been working on writing more tests for JOINs to see nothing breaks with my changes. Unfortunately, the following script with the patch DERBY_4631_patch3_diff.txt patch gives  ERROR 38000: The exception 'java.lang.ArrayIndexOutOfBoundsException: Array index out of range: -2' was thrown while evaluating an expression.\r\n\r\nconnect 'jdbc:derby:db1;create=true;territory=en_US;collation=TERRITORY_BASED:SECONDARY'; \r\nCREATE TABLE derby4631_t1(x varchar(5));\r\nINSERT INTO derby4631_t1 VALUES 'A','B';\r\nCREATE TABLE derby4631_t2(x varchar(5));\r\nINSERT INTO derby4631_t2 VALUES 'b','c';\r\nCREATE TABLE derby4631_t3(x1 varchar(5), y1 varchar(5));\r\nINSERT INTO derby4631_t3 \r\n        \t\tSELECT x, \r\n        \t\t'a'\r\n          \t\tFROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1;\r\n\r\nI am debugging the patch to see what is causing the failure.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-02-21T01:19:40.630+0000","updated":"2012-02-21T01:19:40.630+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13214345","id":"13214345","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I found the problem which was causing array index out of bound exception with the previous patch(patch 3).\r\n\r\nThe query which was throwing the exception is as follows\r\nINSERT INTO derby4631_t3\r\n                       SELECT x,\r\n                       'a'\r\n                       FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1;\r\n\r\nThe columns in derby4631_t3 are named x1 and y1. The source for column x1 in insert above is join column x. In the patch, when we look to determine if the column is a join column, I was looking at column's external name rather than it's base name. So instead of looking for column named 'x', the earlier patch was looking for column 'x1' to see if it is a join column. Because of that, it didn't identify join column x in the SELECT query. I have fixed one line of code in ResultColumnList to fix the problem. So, instead of \r\nif (joinColumn.getName().equals(rc.getName())) {\r\nit now checks\r\nif (joinColumn.getName().equals(rc.name)) {\r\n\r\nI will run the derbyall and junit suite to make sure no existing tests fail with this new patch. I will also continue writing few more tests for JOINs.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-02-23T06:01:23.466+0000","updated":"2012-02-23T06:01:23.466+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13214878","id":"13214878","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"body":"from review of latest patch.  \r\n\r\nResultColumn:\r\nIt would be good to get a review of this with someone with more expertise in this area of the code.  The placement\r\nof the code at 672 just seems strange given how simple the logic use to be.  There is a lot of checking for instances\r\nhere, is there anyway to do this work in the affected nodes like HalfOuterJoinNode.\r\n\r\nAt end of ResultColumn changes why do you check and set for one of the new fields and not the other?\r\n+       if (isRightOuterJoinUsingClause()) {\r\n+           newResultColumn.setRightOuterJoinUsingClause(true);\r\n+       }\r\n+\r\n+       newResultColumn.setJoinResultset(getJoinResultSet());\r\n+\r\n\r\nResultColumnList.java:\r\n1266: get rid of the commented out line of code that you fixed with patch 4\r\n\r\na comment in allExpressionsAreColumns explaining why returning false for isRightOuterJoinUsingClause would be useful.\r\n\r\nin mapSourceColumns() what does the -1 for right outer join columns mean?  \r\n\r\nnits:\r\ntypo - search for \"righ \"\r\nwould be nice to have comments for setJoinResultset and setRightOuterJoinUsingClause, maybe something about what is expected\r\nto call this routine and in what circumstances.\r\nwould be nice if code was 80 columns, critical bug at line 672 of ResultColumn is unreadable at 80.\r\n\r\nJoinNode change:\r\ninconsistent bracket use in if/then/else\r\n\r\nResultColumnList:\r\nmore > 80 lines\r\n\r\nindentation looks wrong for this code, maybe editor got confused by commented out if block:\r\n                        if (joinColumn.getName().equals(rc.name)) {\r\n                                if (joinColumn.isRightOuterJoinUsingClause())\r\n                                    virtualColumnIdRightTable = joinColumn.getVirtualColumnId();\r\n                                else\r\n                                    virtualColumnIdLeftTable = joinColumn.getVirtualColumnId();\r\n                        }\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mikem","name":"mikem","emailAddress":"mikem_app at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mike Matrigali","active":true},"created":"2012-02-23T17:44:48.221+0000","updated":"2012-02-23T17:44:48.221+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13218807","id":"13218807","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Hi Mike,\r\n\r\nthanks for reviewing patch 4. Here are some comments to your feedback(Attaching a new patch DERBY_4631_patch5_diff.txt which takes care of some of your comments.)\r\n\r\n1)ResultColumn:\r\n********\r\nMike's comment - There is a lot of checking for instances here, is there anyway to do this work in the affected nodes like HalfOuterJoinNode?\r\n********\r\nYes, I am concerned about the instance checking too but I had researched into putting the code in HalfOuterJoinNode and found that HalfOuterJoinNode does not ever get to see the ResultColumns for the query and hence it has no way of marking those ResultColumns as join columns.\r\n\r\n********\r\nMike's comment - At end of ResultColumn changes why do you check and set for one of the new fields and not the other?\r\n********\r\nI was trying to follow the existing code where the boolean kinds of fields are first checked and then set to true if the check returned true. rightOuterJoinUsingClause is a boolean field and hence I checked for the return value and then set the new object's value to true. But joinResultSet is a non-boolean field and hence I simply used it's value to set new object's joinResultSet value. For clarity, I will go ahead and replace following\r\n  \t\tnewResultColumn.setJoinResultset(getJoinResultSet());\r\nwith\r\n  \t\tif (getJoinResultSet() != null) {\r\n\t  \t\tnewResultColumn.setJoinResultset(getJoinResultSet());\r\n  \t\t}\r\n\r\n2)ResultColumnList.java:\r\n********\r\nMike's comment - get rid of the commented out line of code that you fixed with patch 4\r\n********\r\nRemoved it. \r\n\r\n********\r\nMike's comment - a comment in allExpressionsAreColumns explaining why returning false for isRightOuterJoinUsingClause would be useful. \r\n********\r\nAdded a comment.\r\n\r\n********\r\nMike's comment - in mapSourceColumns() what does the -1 for right outer join columns mean? \r\n********\r\nallExpressionsAreColumns() uses the -1 value set by mapSourceColumns() to decide if there are columns which require special consideration during code generation. When mapSourceColumns() assigns -1 to right outer join column, allExpressionsAreColumns() will return false. This will allow Derby to later generate code equivalent to COASLECE for right outer join columns(this code generation happens in newly added code in ResultColumnList.generateCore.)\r\n\r\n********\r\nMike's comment - typo - search for \"righ \" \r\n********\r\nFixed it.\r\n\r\n********\r\nMike's comment - would be nice to have comments for setJoinResultset and setRightOuterJoinUsingClause, maybe something about what is expected to call this routine and in what circumstances. \r\n********\r\nAdded comments around for both those methods.\r\n\r\nAdditionally, took care of some indentation problems with the code.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-02-29T01:28:46.336+0000","updated":"2012-02-29T01:28:46.336+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13221108","id":"13221108","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I have the final patch which is ready for commit. I have added couple more tests \r\n1)have left or right table empty before doing joins \r\n2)Do arithmetic operation on join columns.\r\n\r\nI will commit it in a week's time but will appreciate any feedback on the patch before that.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-03-02T18:04:14.665+0000","updated":"2012-03-02T18:04:14.665+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13230601","id":"13230601","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Attaching the release note for the issue","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-03-15T21:55:26.793+0000","updated":"2012-03-15T21:55:26.793+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13231656","id":"13231656","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I am attaching another patch (DERBY_4631_patch7_diff.txt) which is very similar to previous patch(DERBY_4631_patch6_diff.txt) except that I do not have instance of checks in ResultColumn to find JoinNodes from the FromList. Instead, I have added a new method isJoinColumnForRightOuterJoin which will allow HalfOuterJoinNode to see if the ResultColumn is a join column for a right outer join with using/natural clause. This makes the code more readable and removes the instanceof checkings. Please let me know if there are any comments to this patch. Thanks","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-03-16T21:40:51.196+0000","updated":"2012-03-16T21:40:51.196+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13280490","id":"13280490","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Committed(revision 1341204) changes for this jira with following comments\r\nDERBY-4631 Wrong join column returned by right outer join with NATURAL or USING and territory-based collation \r\n\r\nTo recap this issue, SQL:2003 says that the join columns in a natural join or in a named columns join should be added to the select list by coalescing the column from the left table with the column from the right table \r\n\r\nDerby has it's on logic to retrieve the join column values. It always picks up join column's value from the left table when we are working with natural left outer join and it picks up the join column's value from the right table when we are working with natural right outer join. \r\n\r\nBut this logic does not work for all cases for right outer join. The fix provided in this patch will pick the join column's value based on following logic(this logic mimics the functionality of COALESCE) \r\n1)if the left table's column value is null then pick up the right table's column's value. \r\n2)If the left table's column value is non-null, then pick up that value \r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-05-21T21:03:46.682+0000","updated":"2012-05-21T21:03:46.682+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13453375","id":"13453375","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Reopen for backport analysis. Temporarily assign to yourself if you backport and then reassign to Mamta before closing.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2012-09-11T20:27:48.370+0000","updated":"2012-09-11T20:27:48.370+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13455145","id":"13455145","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I will work on backporting this issue","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-09-13T19:02:12.781+0000","updated":"2012-09-13T19:02:12.781+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13455567","id":"13455567","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Backported to 10.8 with revision 1384638","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-09-14T04:30:38.385+0000","updated":"2012-09-14T04:30:38.385+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13455861","id":"13455861","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Backported to 10.7 with revision 1384814","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-09-14T15:22:44.457+0000","updated":"2012-09-14T15:22:44.457+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13456185","id":"13456185","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Backported to 10.6 with revision 1384940.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-09-14T21:55:45.450+0000","updated":"2012-09-14T21:55:45.450+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13456193","id":"13456193","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"No further backporting required because NATURAL/USING clause on join queries was added in 10.6","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-09-14T22:20:20.276+0000","updated":"2012-09-14T22:20:20.276+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13456194","id":"13456194","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Backport finished","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-09-14T22:20:42.379+0000","updated":"2012-09-14T22:20:42.379+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12463019/comment/13488934","id":"13488934","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Attaching release note","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2012-11-01T19:01:34.195+0000","updated":"2012-11-01T19:01:34.195+0000"}]},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-4631/votes","votes":1,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i06fdb:"}}