{"expand":"renderedFields,names,schema,transitions,operations,editmeta,changelog","id":"12374390","self":"https://issues.apache.org/jira/rest/api/latest/issue/12374390","key":"DERBY-2967","fields":{"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false},"timespent":null,"project":{"self":"https://issues.apache.org/jira/rest/api/2/project/10594","id":"10594","key":"DERBY","name":"Derby","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/projectavatar?pid=10594&avatarId=10122","24x24":"https://issues.apache.org/jira/secure/projectavatar?size=small&pid=10594&avatarId=10122","16x16":"https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=10594&avatarId=10122","32x32":"https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=10594&avatarId=10122"},"projectCategory":{"self":"https://issues.apache.org/jira/rest/api/2/projectCategory/10090","id":"10090","description":"DB related projects","name":"DB"}},"fixVersions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12312876","id":"12312876","description":"","name":"10.3.2.1","archived":false,"released":true,"releaseDate":"2007-12-10"},{"self":"https://issues.apache.org/jira/rest/api/2/version/12313111","id":"12313111","description":"","name":"10.4.1.3","archived":false,"released":true,"releaseDate":"2008-04-24"}],"aggregatetimespent":null,"resolution":{"self":"https://issues.apache.org/jira/rest/api/2/resolution/1","id":"1","description":"A fix for this issue is checked into the tree and tested.","name":"Fixed"},"customfield_12310220":"2007-08-07 21:25:50.938","customfield_12312322":null,"customfield_12312323":null,"customfield_12310420":"23350","customfield_12310222":"1_*:*_1_*:*_10898753989_*|*_6_*:*_1_*:*_0_*|*_5_*:*_1_*:*_17328","customfield_12312320":null,"customfield_12312321":null,"customfield_12312120":null,"customfield_12312121":null,"resolutiondate":"2007-11-26T20:21:12.285+0000","workratio":-1,"customfield_12312328":null,"customfield_12312329":null,"customfield_12312326":null,"customfield_12310300":null,"customfield_12312327":null,"customfield_12312324":null,"customfield_12312325":null,"lastViewed":null,"watches":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-2967/watchers","watchCount":0,"isWatching":false},"created":"2007-07-23T16:55:18.296+0000","priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"labels":[],"customfield_12312333":null,"customfield_12312334":null,"customfield_12310310":"16.0","customfield_12312331":null,"customfield_12312332":null,"timeestimate":null,"aggregatetimeoriginalestimate":null,"versions":[{"self":"https://issues.apache.org/jira/rest/api/2/version/12313111","id":"12313111","description":"","name":"10.4.1.3","archived":false,"released":true,"releaseDate":"2008-04-24"}],"customfield_12311120":null,"customfield_12312330":null,"issuelinks":[{"id":"12318031","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12318031","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"outwardIssue":{"id":"12381565","key":"DERBY-3166","self":"https://issues.apache.org/jira/rest/api/2/issue/12381565","fields":{"summary":"Update docs to address code improvments to LIKE (see Derby-2967)","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/1","id":"1","description":"A problem which impairs or prevents the functions of the product.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/bug.png","name":"Bug","subtask":false}}}},{"id":"12316991","self":"https://issues.apache.org/jira/rest/api/2/issueLink/12316991","type":{"id":"10030","name":"Reference","inward":"is related to","outward":"relates to","self":"https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"},"inwardIssue":{"id":"12345445","key":"DERBY-1478","self":"https://issues.apache.org/jira/rest/api/2/issue/12345445","fields":{"summary":"Add built in language based ordering and like processing to Derby","status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"priority":{"self":"https://issues.apache.org/jira/rest/api/2/priority/3","iconUrl":"https://issues.apache.org/jira/images/icons/priorities/major.png","name":"Major","id":"3"},"issuetype":{"self":"https://issues.apache.org/jira/rest/api/2/issuetype/4","id":"4","description":"An improvement or enhancement to an existing feature or task.","iconUrl":"https://issues.apache.org/jira/images/icons/issuetypes/improvement.png","name":"Improvement","subtask":false}}}}],"customfield_12312339":null,"assignee":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"customfield_12312337":null,"customfield_12312338":null,"updated":"2007-11-28T18:34:18.583+0000","customfield_12312335":null,"customfield_12311720":null,"customfield_12312336":null,"status":{"self":"https://issues.apache.org/jira/rest/api/2/status/6","description":"The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.","iconUrl":"https://issues.apache.org/jira/images/icons/statuses/closed.png","name":"Closed","id":"6","statusCategory":{"self":"https://issues.apache.org/jira/rest/api/2/statuscategory/3","id":3,"key":"done","colorName":"green","name":"Complete"}},"components":[{"self":"https://issues.apache.org/jira/rest/api/2/component/11408","id":"11408","name":"SQL"}],"timeoriginalestimate":null,"description":"With TERRITORY_BASED collation '_' does not match  the character \\uFA2D.  It is the same for english or norwegian. FOR collation UCS_BASIC it matches fine.  Could you tell me if this is a bug?\nHere is a program to reproduce.\n\n\nimport java.sql.*;\n\npublic class HighCharacter {\n\n   public static void main(String args[]) throws Exception\n   {\n   System.out.println(\"\\n Territory no_NO\");\n   Class.forName(\"org.apache.derby.jdbc.EmbeddedDriver\");\n   Connection conn = DriverManager.getConnection(\"jdbc:derby:nordb;create=true;territory=no_NO;collation=TERRITORY_BASED\");\n   testLikeWithHighestValidCharacter(conn);\n   conn.close();\n   System.out.println(\"\\n Territory en_US\");\n   conn = DriverManager.getConnection(\"jdbc:derby:endb;create=true;territory=en_US;collation=TERRITORY_BASED\");\n   testLikeWithHighestValidCharacter(conn);\n   conn.close();\n   System.out.println(\"\\n Collation USC_BASIC\");\n   conn = DriverManager.getConnection(\"jdbc:derby:basicdb;create=true\");\n   testLikeWithHighestValidCharacter(conn);\n\n   }\n\n\npublic static  void testLikeWithHighestValidCharacter(Connection conn) throws SQLException {\n   Statement stmt = conn.createStatement();\n   try {\n   stmt.executeUpdate(\"drop table t1\");\n   }catch (SQLException se)\n   {// drop failure ok.\n   }\n   stmt.executeUpdate(\"create table t1(c11 int)\");\n   stmt.executeUpdate(\"insert into t1 values 1\");\n \n   // \\uFA2D - the highest valid character according to\n   // Character.isDefined() of JDK 1.4;\n   PreparedStatement ps =\n   conn.prepareStatement(\"select 1 from t1 where '\\uFA2D' like ?\");\n     String[] match = { \"%\", \"_\", \"\\uFA2D\" };\n\n   for (int i = 0; i < match.length; i++) {\n   System.out.println(\"select 1 from t1 where '\\\\uFA2D' like \" + match[i]);\n   ps.setString(1, match[i]);\n   ResultSet rs = ps.executeQuery();\n   if( rs.next() && rs.getString(1).equals(\"1\"))\n       System.out.println(\"PASS\");\n   else          System.out.println(\"FAIL: no match\");\n\n   rs.close();\n   }\n  }\n}\n\n\n\nMamta made some comments on this issue in the following thread:\n\nhttp://www.nabble.com/Single-character-does-not-match-high-value-unicode-character-with-collation-TERRITORY_BASED.-Is-this-a-bug-tf4118767.html\n\n\n","customfield_10010":null,"timetracking":{},"customfield_12312026":null,"customfield_12310200":null,"customfield_12312023":null,"customfield_12312024":null,"customfield_12312340":null,"aggregatetimeestimate":null,"customfield_12312022":null,"customfield_12312341":null,"customfield_12312220":null,"customfield_12310921":null,"customfield_12310920":"39756","summary":"Single character does not match high value unicode character with collation TERRITORY_BASED","creator":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"subtasks":[],"customfield_12310090":[{"self":"https://issues.apache.org/jira/rest/api/2/customFieldOption/10101","value":"Release Note Needed","id":"10101"}],"reporter":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"customfield_12310291":null,"customfield_12310290":null,"aggregateprogress":{"progress":0,"total":0},"environment":null,"customfield_12311020":null,"customfield_12310050":null,"duedate":null,"customfield_12310250":null,"progress":{"progress":0,"total":0},"comment":{"startAt":0,"maxResults":56,"total":56,"comments":[{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12518204","id":"12518204","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"I am looking at the current behavior where _ matches a single collation element instead of a single character and trying to understand what the new behavior would be.    Here is an example of the current behavior:  I insert into a table two rows:\r\n\r\n agrave = \"\\u00C0\";\r\nagraveCombined =\"A\\u0300\";\r\n\r\nagrave is one character, agraveCombined is two but they match for = and like processing with a French TERRITORY_BASED database.  Here are some queries.\r\n\r\njdbc:derby:frdb (TERRITORY_BASED - current)\r\n2 rows matching SELECT COUNT(*) FROM T WHERE VC = À\r\n2 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE À\r\n2 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE A_\r\n0 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE _\r\n2 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE __\r\n\r\njdbc:derby:regdb (UCS_BASIC)\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC = À\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE À\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE A_\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE _\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE __\r\n\r\n\r\nSo if _ is really supposed to match a single character and not a single collation element,\r\nI think the results should be as follows:\r\njdbc:derby:frdb (TERRITORY_BASED)\r\n2 rows matching SELECT COUNT(*) FROM T WHERE VC = À\r\n2 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE À\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE A_  (agraveCombined)\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE _  (agrave)\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE __ (agraveCombined)\r\n\r\nDoes that sound right?  How I might implement this I have no idea but just trying to get my head around how it should behave.\r\n\r\nKathey\r\n\r\nSee attached program TestFrench.java if you want to run.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2007-08-07T17:47:58.005+0000","updated":"2007-08-07T17:47:58.005+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12518262","id":"12518262","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=djd","name":"djd","emailAddress":"djd at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daniel John Debrunner","active":true},"body":"I would say neither (existing or proposed)  is correct, though only after looking at your example.\r\n\r\nThe existing code is wrong because it is converting the '_' to a collation element then skipping that number of collation elements?\r\n\r\nThe proposed results are wrong because in the French locale agraveCombined =\"A\\u0300\" is a single character.\r\nI assume the \\u0300 is a 'Combining character'.\r\n\r\nhttp://www.unicode.org/versions/Unicode5.0.0/ch03.pdf#G30602\r\n\r\nThus I think the results should be:\r\n\r\n0 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE A_\r\n2 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE _ (agrave,agraveCombined)\r\n0 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE __\r\n\r\nAs for implementing it, I think one has to use the getOffset/setOffset method on CollationElementIterator.\r\n\r\nE.g. along the lines of this to skip a character. The real solution would be more than this but you get the idea.\r\n\r\n   if (patternChar == '_')\r\n       iterator.setOffset(iterator.getOffset() + 1);\r\n\r\n\r\n\r\n\r\n\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=djd","name":"djd","emailAddress":"djd at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daniel John Debrunner","active":true},"created":"2007-08-07T21:25:50.938+0000","updated":"2007-08-07T21:25:50.938+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12518264","id":"12518264","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Both String.length() and SQL LENGTH say agraveCombined =\"A\\u0300\" is two characters.  Is this result wrong?\r\nij> select length(VC) from t;\r\n1\r\n-----------\r\n1\r\n2\r\n\r\nDo you think SELECT COUNT(*) FROM T WHERE VC = À  should still match two rows?\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2007-08-07T21:41:38.780+0000","updated":"2007-08-07T21:41:38.780+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12518269","id":"12518269","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=djd","name":"djd","emailAddress":"djd at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daniel John Debrunner","active":true},"body":"String.length() returning two matches its definition so it seems to be correct.\r\n\r\nIs the SQL fLENGTH unction a standard function, does that say anything?\r\n\r\n> Do you think SELECT COUNT(*) FROM T WHERE VC = À should still match two rows? \r\nGiven what you said yes, I thought this issue was about LIKE and _ though.\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=djd","name":"djd","emailAddress":"djd at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daniel John Debrunner","active":true},"created":"2007-08-07T21:53:14.389+0000","updated":"2007-08-07T21:53:14.389+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12518548","id":"12518548","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Dan said:\r\n\r\n>As for implementing it, I think one has to use the getOffset/setOffset method on CollationElementIterator.\r\n>E.g. along the lines of this to skip a character. The real solution would be more than this but you get the idea.\r\n\r\n>   if (patternChar == '_')\r\n>       iterator.setOffset(iterator.getOffset() + 1);\r\n\r\nSo for the Norwegian aa, which is one collation element but two characters, I think this code would set us back to the same offset where we started, since getOffset always returns the first character of the collation element.  That would leave us I think in an unpleasant loop.  \r\n\r\nAttaching TestNorway.java showing current behavior for Norwegian aa.\r\n\r\ndefault strength:TERTIARY\r\ndefault decomposition:NO_DECOMPOSITION\r\naa.length()2\r\njdbc:derby:nordb\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC = aa\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE aa\r\n0 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE a_\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE _\r\n0 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE __\r\njdbc:derby:regdb\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC = aa\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE aa\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE a_\r\n0 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE _\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE __\r\n\r\nI think the correct results for nordb should be:\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC = aa\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE aa\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE a_\r\n0 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE _\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE __\r\n\r\nI am going to try to look at another database product to compare behavior so I can better understand what needs to be implemented, because I am still a bit fuzzy on all this.\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2007-08-08T20:58:14.149+0000","updated":"2007-08-08T20:58:14.149+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12518575","id":"12518575","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=djd","name":"djd","emailAddress":"djd at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daniel John Debrunner","active":true},"body":"How about this to skip one logical character (not tested, just guessing from the apis)\r\n\r\nint currentChar = iterator.getOffset();\r\ndo {\r\n  iterator.next();\r\n} while (iterator.getOffset() == currentChar)\r\n\r\nE.g. Norwegian  'aa' maps to a single collation element so getOffset() can only point to one of the characters in the underlying String.\r\nOnce getPosition changes it must have moved past the aa\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=djd","name":"djd","emailAddress":"djd at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daniel John Debrunner","active":true},"created":"2007-08-08T23:20:25.332+0000","updated":"2007-08-08T23:20:25.332+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12519120","id":"12519120","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Below are the results run against DB2 v8.2 with  UCA400_NO collation.  _ doesn't seem to match to a single character in DB2, but it doesn't quite seem to be collation element either.\r\n\r\nHighCharacter.java\r\n\r\n Territory no_NO\r\nselect 1 from t1 where '\\uFA2D' like %\r\nPASS\r\nselect 1 from t1 where '\\uFA2D' like _\r\nFAIL: no match\r\nselect 1 from t1 where '\\uFA2D' like ?\r\nPASS\r\n\r\n Territory en_US\r\nselect 1 from t1 where '\\uFA2D' like %\r\nPASS\r\nselect 1 from t1 where '\\uFA2D' like _\r\nFAIL: no match\r\nselect 1 from t1 where '\\uFA2D' like ?\r\nPASS\r\n\r\n\r\nTestFrench.java\r\n\r\n\r\njdbc:db2://localhost:50000/frdb\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC = À\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE À\r\n0 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE A_\r\n0 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE _\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE __\r\n\r\n\r\nTestNorway.java\r\n\r\njdbc:db2://localhost:50000/nordb\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC = aa\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE aa\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE a_\r\n0 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE _\r\n1 rows matching SELECT COUNT(*) FROM T WHERE VC LIKE __\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2007-08-10T21:08:06.754+0000","updated":"2007-08-10T21:08:06.754+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12519145","id":"12519145","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Unassigning myself from this issue for now.  It seems to me that the behavior is not all that straightforward.  I think I'd rather leave to someone more familiar with collation to fix.  I hope the test cases are helpful.\r\n\r\nKathey\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2007-08-10T22:28:18.491+0000","updated":"2007-08-10T22:28:18.491+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12522039","id":"12522039","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I spent some time on this Jira entry to explore Dan's suggestion for _ search in a string\r\n*************\r\n--Note that the iterator object is of type CollationElementIterator. \r\nint currentChar = iterator.getOffset(); \r\ndo { \r\n  iterator.next(); \r\n} while (iterator.getOffset() == currentChar) \r\n*************\r\n\r\nI believe the code suggested by Dan above will do the trick but I am not sure how to fit that logic in the current code inside the iapi.types.Like.like method (method starting at line 258) which is where the current implementation for _ resides. \r\n\r\nSome background information on the classes and methods involved in this discussion: There are 2 like methods inside WorkHorseForCollatorDatatypes(which handles collation sensitive methods for character string types with territory based collation) and they only differ in the sense that one accepts the escape DVD while the other one does not. Both these methods call the like method(starting at line 96) in iapi.types.Like. This like method ends up calling another like method in the same class (starting at line 258) which provides the actual implementation. Notice, that this like method does not work with CollationElementIterator. Instead, it expects the caller to send the int array containing the collation elements for string to be searched into, pattern to be looked and escape sequence. This is done for performance reasons. We do not want to construct the collation element arrary for the strings during every call to like. Instead, we want to construct it once and reuse it every subsequent time. And hence, the current implementation does not work with CollationElementIterator.\r\n\r\nAs a solution, I am thinking that may be I should have another int array in WorkHorseForCollatorDatatypes, which will keep track of the starting position of the collation elements for each of the characters. We already have an int array, collationElementsForString, which holds the collation elements for all the characters that this WorkHorseForCollatorDatatypes holds. If we knew where the new collation elements start in collationElementsForString, we can just advance to the next character's collation element starting position when we find a _. \r\n\r\nLet me know if anyone has any feedback on this approach or has any other suggestions on fixing the problem.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-08-23T06:21:29.896+0000","updated":"2007-08-23T06:21:29.896+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12523073","id":"12523073","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=djd","name":"djd","emailAddress":"djd at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daniel John Debrunner","active":true},"body":"Are there any numbers for the performance benefit seen by using this int arrays over CollationElementIterator?\r\n\r\nOne potential problem with the arrays is that the array is fully populated even if the value could be disqualified on the first character, that would seem to degrade performance, not improve it.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=djd","name":"djd","emailAddress":"djd at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daniel John Debrunner","active":true},"created":"2007-08-27T18:07:58.096+0000","updated":"2007-08-27T18:07:58.096+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12523324","id":"12523324","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I do not have any numbers for the performance results for int array vs CollationElementIterator. I searched Derby dev list and found few postings about how constructing an array before hand may not be not necessary for a check which would fail within say first few characters. I also found DERBY-2699 (performance of like in territory based collation databases may be improved by changing way collation elements are calculated.) which also talks about the same issue as your comment \"One potential problem with the arrays is that the array is fully populated even if the value could be disqualified on the first character, that would seem to degrade performance, not improve it. \" \r\n\r\nI will start investigating into using CollationElementIterator rather than an int array. This will fix both this Jira entry and DERBY-2699 and possibly DERBY-2698.\r\n\r\nIf anyone has any comments please let me know.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-08-28T19:41:27.843+0000","updated":"2007-08-28T19:41:27.843+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12526508","id":"12526508","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I have attached an intermediate patch. This patch rather than building the collation elements in advance, builds it as needed. The crucial parts that are left are\r\n1)Implementing code for pattern '%a', ie when % (which is match 0/more characters) is found, match remaining pattern after it.\r\n2)The other item left is understanding the behavior of CollationElementIterator.next and previous. I have started a thread \"Question about next() and previous() on CollationElementIterator\" on that issue and hope to get some feedback on it.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-09-11T16:11:46.135+0000","updated":"2007-09-11T16:11:46.135+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12527398","id":"12527398","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I talked with Dan briefly on my last patch(temp_diff.txt) and found that I was unaware of the fact that 2 or more different characters in a territory can have same collation element(s) value associated with them. \r\n***********************\\\r\n(http://www.unicode.org/reports/tr10/ Section 1.9.2 Non-Goals The Default Unicode Collation Element Table explicitly does not provide for the following features:\r\nreversibility: from a Collation Element you are not guaranteed that you can recover the original character. \r\n***********************/\r\n\r\nSo, taking a fictious territory as an eg, it is possible that metacharacter '_''s collation element could have same value as say character 'a'. Because of this, my approach to construct a CollationElementIterator on the entire pattern string will not yield expected results. I have worked on a new patch based on this fact and will post it in another couple minutes. Please disregard the earlier patch temp_diff.txt and temp_stat.txt","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-09-14T08:13:02.994+0000","updated":"2007-09-14T08:13:02.994+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12527405","id":"12527405","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Attaching a new patch (svn diff is attached as step1_iteratorbased_Sep1507_diff.txt and svn stat -q is attached as step1_iteratorbased_Sep1507_stat.txt). This patch does not build the collation elements for the value string in advance, instead it fetches the collation element from the CollationElementIterator as needed for the value string. In addition, it does not build CollationElementIterator on entire pattern string. The metacharacters in pattern are compated using their unicode values. Rest of the characters in pattern will have CollationElementIterator associated with them. In other words, for the pattern string, collation elements are used only for non-metacharacters. \r\n\r\nThe new logic for LIKE implementation is as follows(This is really the javadoc for the iapi.types.Like:like(CollationElementIterator valueIterator, String pattern, String escape, RuleBasedCollator collator)). I do have 2 questions that I would appreciate help on. The 2 questions are at the end of the nice :) javadoc below.\r\n\r\n\t/**\r\n\t * This method will be called for character string types with territory\r\n\t * based collation. The logic of the method is as follows\r\n\t * A)If pattern string or value Iterator is null, then this method will\r\n\t * return null. Because the results of LIKE can't be established in such\r\n\t * a situation.\r\n\t * B)Intialize the pointer into pattern string to 0\r\n\t * C)Start the loop\r\n\t *   a)Check if we have reached the end of value Iterator. If yes\r\n\t *     1)Check if we have reached the end of pattern string. If yes \r\n\t *     return TRUE.\r\n\t *     2)Check if we pattern string only has % left. If yes, then \r\n\t *     return TRUE.\r\n\t *     3)If a1) and a2) not true, then return FALSE.\r\n\t *   c)Start looking at pattern where the pointer is pointing and keep\r\n\t *     going until you find end of pattern or one of the metacharacters\r\n\t *     ie %, * or escape character. \r\n\t *   d)Get a CollationElementIterator for the non-metacharacters found in \r\n\t *     step c(using the Collator passed to this method. The same Collator\r\n\t *     was used to construct a CollationElementIterator for value string).\r\n\t *     and make sure that they match the collation elements found in\r\n\t *     value CollationElementIterator. A mismatch would require us to \r\n\t *     return FALSE from this method.\r\n\t *   e)Do the checks performed by step Ca).\r\n\t *   f)Check what metacharacter is the offset in pattern pointing to\r\n\t *     1)If it is escape character, then convert the next character in\r\n\t *       pattern to it's collation element(s) and compare those collation\r\n\t *       elements to elements in valueIterator. If they do not match,\r\n\t *       we need to return FALSE. \r\n\t *     2)If it is not escape character, then check if it is a _. If yes,\r\n\t *       then skip all the collation elements in valueIterator \r\n\t *       corresponding to the next character in value.\r\n\t *     3)If it is not escape character or a '_' character, then check if\r\n\t *       it is a '%'. If not, then go back to step C). If yes, then check\r\n\t *       if we have reached the end of pattern. If end of pattern, then we\r\n\t *       can simply return from this method with TRUE return value. I have\r\n\t *       a question Q1(written below). If the code in question in Q1 is not\r\n\t *       satisified and we have not reached end of pattern, then check if\r\n\t *       rest of the characters in pattern are all '%'. If yes, then we \r\n\t *       can simply return from this method wil TRUE return value. I have\r\n\t *       question Q2 at this point\r\n\t *       Q1)I copied the code from the old method implementation which at\r\n\t *          this point checks if we have reached the end of valueIterator\r\n\t *          then we should return TRUE value. I think that is incorrect\r\n\t *          because we have reached the end of valueIterator, but there\r\n\t *          might be more characters in the pattern that we have not\r\n\t *          matched yet.\r\n\t *       Q2)What would be the best way to implement the logic to handle \r\n\t *          valueIterator for a % found in the pattern.\r\n\t *   g)Go back to step C).","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-09-14T08:25:06.521+0000","updated":"2007-09-14T08:25:06.521+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12527628","id":"12527628","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"The patch submitted by me will not work on Sun's jdks (I have tested Sun jdk142 and jdk15) because of the issues found with next() and previous() calls on CollationElementIterator with Sun's jdks (more info about this can be found at http://www.nabble.com/Question-about-next%28%29-and-previous%28%29-on-CollationElementIterator.-tf4418042.html#a12601408)","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-09-14T20:44:55.658+0000","updated":"2007-09-14T20:44:55.658+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12528131","id":"12528131","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Mamta, will running with Sun JVM's cause the existing functionality to regress in some way or will it just mean that the bug you are fixing won't be fixed when running with Sun JVM's?\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2007-09-17T19:45:55.100+0000","updated":"2007-09-17T19:45:55.100+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12528994","id":"12528994","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Kathey, I am trying to see if I can rewrite my code using getOffset/setOffset rather than previous on CollationElementIterator. Assuming getOffset/setOffset work correctly with Sun JVM, we may be able to have a fix that works for Sun JVM as well. I am working on the changes right now and will post a patch if the changes seem to work fine.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-09-20T06:09:40.304+0000","updated":"2007-09-20T06:09:40.304+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12529212","id":"12529212","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"I ran lang/FullCollationTest with the existing patch. I did not do a full analysis because I know there is a new patch coming, but I did seem some null pointer exceptions and an error which look like they may be an issue with the patch. I am attaching the results for your reference.\r\n\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2007-09-20T19:06:22.309+0000","updated":"2007-09-20T19:06:22.309+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12529295","id":"12529295","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Kathey, I am pretty certain that the patch(which I am attaching to this jira entry, patch name patch2_with_setOffset_diff_Sep2007.txt)  I am working on will take of quite a few null ptr exceptions if not all. This patch is an attempt to use getOffset/setOffset rather than next/previous on CollationElementIterator because of the bug in Sun's JVM. The patch is not ready for commit and has quite a few printlns but I think that should not interfere with junit run. I am running some tests of my own right now and will fire the full collation test once those tests are done. In the mean time, if you happen have some cycles to try the full collation test on your machine with this collation patch, I will greatly appreciate that. Thanks","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-09-21T00:11:32.889+0000","updated":"2007-09-21T00:11:32.889+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12529483","id":"12529483","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Mamta, thanks for all your work on this. You are right, the NPE's are gone!  I still see an exception:\r\n\r\n1) testWildcardAsEscape(org.apache.derbyTesting.functionTests.tests.lang.DynamicLikeOptimizationTest)java.sql.SQLException: Escape character must be followed by escape character, '_', or '%'. It cannot be followed by any other character or be at the end of the pattern.\r\n\tat org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(SQLExceptionFactory.java:45)\r\n\tat org.apache.derby.impl.jdbc.Util.generateCsSQLException(Util.java:202)\r\n\tat org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(TransactionResourceImpl.java:391)\r\n\tat org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(TransactionResourceImpl.java:346)\r\n\tat org.apache.derby.impl.jdbc.EmbedConnection.handleException(EmbedConnection.java:1574)\r\n\tat org.apache.derby.impl.jdbc.ConnectionChild.handleException(ConnectionChild.java:81)\r\n\tat org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1315)\r\n\tat org.apache.derby.impl.jdbc.EmbedStatement.execute(EmbedStatement.java:618)\r\n\tat org.apache.derby.impl.jdbc.EmbedStatement.executeQuery(EmbedStatement.java:153)\r\n\tat org.apache.derbyTesting.functionTests.tests.lang.DynamicLikeOptimizationTest.testWildcardAsEscape(DynamicLikeOptimizationTest.java:181)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat org.apache.derbyTesting.junit.BaseTestCase.runBare(BaseTestCase.java:95)\r\n\tat junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)\r\n\tat junit.extensions.TestSetup$1.protect(TestSetup.java:19)\r\n\tat junit.extensions.TestSetup.run(TestSetup.java:23)\r\n\tat org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)\r\n\tat junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)\r\n\tat junit.extensions.TestSetup$1.protect(TestSetup.java:19)\r\n\tat junit.extensions.TestSetup.run(TestSetup.java:23)\r\n\tat org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)\r\n\tat junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)\r\n\tat junit.extensions.TestSetup$1.protect(TestSetup.java:19)\r\n\tat junit.extensions.TestSetup.run(TestSetup.java:23)\r\n\tat org.apache.derbyTesting.junit.BaseTestSetup.run(BaseTestSetup.java:57)\r\n\tat junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)\r\n\tat junit.extensions.TestSetup$1.protect(TestSetup.java:19)\r\n\tat junit.extensions.TestSetup.run(TestSetup.java:23)\r\nCaused by: ERROR 22025: Escape character must be followed by escape character, '_', or '%'. It cannot be followed by any other character or be at the end of the pattern.\r\n\tat org.apache.derby.iapi.error.StandardException.newException(StandardException.java:280)\r\n\tat org.apache.derby.iapi.types.Like.like(Like.java:382)\r\n\tat org.apache.derby.iapi.types.WorkHorseForCollatorDatatypes.like(WorkHorseForCollatorDatatypes.java:183)\r\n\tat org.apache.derby.iapi.types.CollatorSQLChar.like(CollatorSQLChar.java:186)\r\n\tat org.apache.derby.exe.ac9423444ax0115x2607x4835x00003dcd3cb40.e1(Unknown Source)\r\n\tat org.apache.derby.impl.services.reflect.DirectCall.invoke(ReflectGeneratedClass.java:141)\r\n\tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.openCore(ProjectRestrictResultSet.java:156)\r\n\tat org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.openCore(ProjectRestrictResultSet.java:168)\r\n\tat org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl.open(BasicNoPutResultSetImpl.java:248)\r\n\tat org.apache.derby.impl.sql.GenericPreparedStatement.execute(GenericPreparedStatement.java:370)\r\n\tat org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(EmbedStatement.java:1225)\r\n\t... 44 more\r\n\r\nI have not reviewed the code yet. I will do that after you post the new patch.\r\n\r\nKathey\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2007-09-21T16:31:28.281+0000","updated":"2007-09-21T16:31:28.281+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12529493","id":"12529493","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Kathey, I am looking at the escape character problem. ","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-09-21T16:55:59.361+0000","updated":"2007-09-21T16:55:59.361+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12531903","id":"12531903","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Attaching patch DERBY2967_offset_based_diff_Oct02_07.txt which fixes DERBY-2967 for both IBM's jdks and Sun's jdks. The fix involves using CollationElementIterator to look through collation elements of a character string as needed rather than fetching them all into an array before hand. With the later approach, we may end up getting all the collation elements for a \r\nreally large string when we will be looking at say only first few of those collation elements because we have found a mismatch between value and pattern.\r\n\r\nThe majority of the changes have gone into iapi.types.Like class. This class has two different implementation of SQL LIKE clause. One implementation is for UCS_BASIC character strings and the other one is for territory based character strings. The territory based implementation of LIKE clause has been changed in this patch. From a top level, this method does one to one comparison of collation elements for string that is being searched and the pattern that is being searched in that string. This one-to-one comparison is done for non-metacharacters in the pattern. As soon as we find a metacharacter in the pattern string, we do special processing depending on what kind of metacharacter we are dealing with.\r\n1)Taking the simplest case of escape character as the metacharacter. If the user has provided an escape character, then as soon as we encounter the escape character in the pattern string, we check if the character following it is a metacharacter or\r\nnot. If not, we throw an exception. If the character indeed is a metacharacter, we convert that metacharacter into it's collation element(s) and look for the exact match of those collation element(s) into the CollationElementIterator for the value string.\r\n2)Taking the next simplest case of _. When we find a _ in the pattern string, we advance in the CollationElementIterator for the value string by one character. This is where it gets tricky ie what is defined as one character in a particular locale. In Norwegian locale, 'b' is a single character and so are 'aa'. Both of these character strings translate into single collation element. But in Norwegian locale, evne though '\\uFA2D' is one character, it translates into 2 collation elements. This advancing by one character and eating the right number of collation elements is implemented in a new method in Like.java class and the new method's name is advnaceByOne(CollationElementIterator).\r\n3)Moving on to metacharacter %. A % can be satisfied by 0 to any number of characters in the value string. In order to determine how many characters will satisfy %, we have to start with 0 character and keep eating more and more characters until we find a match for the remaining pattern string and value string or until we reach end of value string but still non % characters left in pattern string. In the later case, we know we have ended up with a mismatch and we return a FALSE from the method.\r\n\r\nThe javadoc(from Like.java's like(CollationElementIterator, int, String, int, String, RuleBasedCollator)) describes the implementation in little more detail and I have copied that here for reference. Note that in the following method, valueIterator is the CollationElementIterator for the character string that we are doing a search into.\r\n\r\n\r\n****************beginning of javadoc*****************\r\n\t * This method will be called for character string types with territory\r\n\t * based collation to see if valueIterator matches the passed pattern\r\n\t * string. The logic of the method is described in following steps (I\r\n\t * have tried to put the step identifiers in the code below for reference).\r\n\t * A)If pattern string or value Iterator is null, then this method will\r\n\t *   return null because the results of LIKE can't be established in such\r\n\t *   a situation.\r\n\t * B)Start the loop\r\n\t *   a)Check the lengths of valueIterator and pattern string to see if it\r\n\t *     is time to return with TRUE/FALSE. The exact details of these checks \r\n\t *     can be found in the javadoc method of \r\n\t *       checkLengths(CollationElementIterator, String, int)\r\n\t *   b)Start looking at pattern where the pointer is pointing and keep\r\n\t *     going until you find end of pattern or you find one of the \r\n\t *     metacharacters ie %, * or optional escape character. \r\n\t *   c)Get a CollationElementIterator for the non-metacharacters found in \r\n\t *     step b(using the Collator passed to this method. The same Collator\r\n\t *     was used to construct valueIterator).\r\n\t *   d)Make sure that collation elements found in step c) match the \r\n\t *     collation elements in valueIterator. A mismatch would require us to \r\n\t *     return FALSE from this method.\r\n\t *   e)Check again the lengths of valueIterator and pattern string to see \r\n\t *     if it is time toreturn with TRUE/FALSE. The exact details of these  \r\n\t *     checks can be found in the javadoc method of \r\n\t *       checkLengths(CollationElementIterator, String, int)\r\n\t *   f)If we are still here and didn't return from this method as a result\r\n\t *     of step Be) then it means that we have to deal with the \r\n\t *     metacharacter found in step Bc). Check what metacharacter is the \r\n\t *     offset in pattern pointing to\r\n\t *     1)If user has provided escape character and pattern is pointing to\r\n\t *       one right now, then convert the next character in pattern to it's \r\n\t *       collation element(s) and compare those collation elements to \r\n\t *       elements in valueIterator. If they do not match, we need to return \r\n\t *       FALSE. \r\n\t *     2)If it is not escape character, then check if it is a '%'. If it is,\r\n\t *       then increment the pointer in the pattern string by 1 and then \r\n\t *       follow the involved algorithm below\r\n\t *       First check if we have reached the end of pattern. If yes, then we \r\n\t *       can simply return from this method with TRUE return value. If we \r\n\t *       have not reached end of pattern, then check if rest of the \r\n\t *       characters in pattern are all '%'. If yes, then we can simply \r\n\t *       return from this method wil TRUE return value. If not all %, then\r\n\t *       take rest of the pattern string and see if it matches rest of the \r\n\t *       valueIterator(will be implemented by recursively calling this \r\n\t *       method). If no match, then do the step Ba). If it is not time to\r\n\t *       return because of step Ba), then advance the pointer in \r\n\t *       valueIterator by one character and see if the valueIterator now \r\n\t *       matches the rest of the pattern string. Keep going until we find \r\n\t *       the match or mismatch.\r\n\t *     3)If it is not escape character or %, then check if it is a _. If \r\n\t *       yes, then skip all the collation elements in valueIterator \r\n\t *       corresponding to the next character.\r\n\t *   g)Go back to step B).\r\n****************end of javadoc*****************\r\n\r\nI have changed SQLChar and WorkHorseForCollatorDatatypes to call this new method for territory based character string types in Like rather than the old implementation (I have removed the old implementation code from Like.java)\r\n\r\nI have added a new test in CollationTest. The existing tests for LIKE in CollationTest2 have been very handy during my testing of the code changes.\r\n\r\nIn addition to the above tests, I have run full collation test under Norwegian territory. Following is the analysis of some of the test failures and fixes to subset of them.\r\n\r\n1)There are few existing tests that use character string 'aa' in their testing. These existing test were written to run in UCS_BASIC collation and hence 'aa' didn't cause a problem. But now when we run the full collation tests with say Norwegian territory based locale, the character string 'aa' exhibit different behavior(because in Norwegian, it is treated as one character) and hence give the false impression of test failures. To avoid having to scan these false failures every time one runs full\r\ncollation tests with Norwegian territory, I have changed the test data in some tests. This has bring the test failures far lower when all the tests are run with territory based locale rather than UCS_BASIC.\r\n\r\n2)Few other failures in full collation test will be the error message string mismatch when running the tests in UCS_BASIC \r\nvs territory based. For eg, LOB.out has error messages like following\r\nERROR 42818: Comparisons between 'CHAR (UCS_BASIC)' and 'CLOB (UCS_BASIC)' are not supported. Types must be comparable. String types must also have matching collation. If collation does not match, a possible solution is to cast operands to force them to the default collation (e.g. select tablename from sys.systables where CAST(tablename as VARCHAR(128)) = 'T1')\r\nThis error message will have TERRITORY BASED rather than UCS_BASIC in it's text when the test is run in territory based. So even though it might look like a test failure when LOB test in run in territory based locale, it is really not a test failure. I think there are 2 tests which will show diffs for this reason. They are LOB.sql and implicitConversoins.\r\n\r\n3)The diff in orderby.sql is also genuine because with UCS_BASIC database, \"Canada\" sorts before \"anaconda\" but with \r\nTERRITORY_BASED database, \"anaconda\" sorts before \"Canada\". \r\n\r\n4)The diffs in Nist tests dml068 and dml079 look genuine too because data is getting sorted in different order with TERRITORY_BASED database and UCS_BASIC database.\r\n\r\n5)DataSourceTest checks the format of Connection.toString and in case of a database created with terriotry based collation, the format of database string is alphabets/alphabets where as the test is looking for just alphabets for the database name.\r\n\r\n6)The diff in InListMultiProbeTest is expected because in a territory based database _ sorts before '1' whereas in a UCS_BASIC database, _ sorts after '1'. eg create and load a table using following script in both kinds of databases.\r\ncreate table dellater(c1 char(1));\r\ninsert into dellater values('1'),('_'),('2');\r\nNow, the result of following query differs in 2 kinds of databases\r\nselect * from dellater where c1 >= '_' order by c1;\r\nTERRITORY BASED db\r\nC1\r\n----\r\n_\r\n1\r\n2\r\n3 rows selected\r\n\r\nUCS_BASIC db\r\nC1\r\n----\r\n_\r\n1 row selected\r\n\r\n7)Other than the ones mentioned above, there are few tests failing with assert exception but I do not think they are related to\r\nchanges that are in this patch. Kathey, I think you have run full collation tests in the past. I wonder if you had seen then \r\nassert failures even before applying this current patch of mine.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-10-02T20:24:31.836+0000","updated":"2007-10-02T20:24:31.836+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12531956","id":"12531956","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=djd","name":"djd","emailAddress":"djd at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daniel John Debrunner","active":true},"body":"Looking carefully at the SQL Standard - section 8.5 SR 3 c) ii) 4) then currently (I think) Derby's LIKE with TERRITORY_BASED collation is not being implemented correctly.\r\n\r\nFor a pattern like 'aa' (norway) or 'ch' (spain) then the SQL standard indicates that LIKE operates a character at a time. So the pattern is not the combination of 'aa' or 'ch', but two separate characters 'a' 'a' or 'c' 'h' . The collation is only used when comparing this single (  'exactly 1 (one)' ) character.\r\n\r\nMySQL indicates this as well, stating LIKE performs matching on a per-character basis, thus it can produce different results to the = comparison operator.\r\n\r\nE.g. 'AA'  LIKE 'Å'  is FALSE, but 'AA' = 'Å' is TRUE\r\n\r\nThis would indicate that during LIKE processing a CollationElementIterator should only ever be created on a single character,\r\nthough this does go back to Kathey's question of what is a single character (see DERBY-3080). There seem to be three forms\r\nthat could be called a single character:\r\n\r\n1) A simple single Unicode codepoint such a 'Å'   U+212B\r\n\r\n2) A single Unicode codepoint followed by one or more combining marks, e.g. U+0041 U+030A\r\n\r\n3) A contraction, where two or more characters *sort as if* they were a single base character (e.g. CH in spanish)\r\n\r\nUnicode TR10 I think is saying that 1) and 2) are single characters, but 3) is not.\r\n\r\n(MySQL reference: http://dev.mysql.com/doc/refman/4.1/en/string-comparison-functions.html  )","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=djd","name":"djd","emailAddress":"djd at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daniel John Debrunner","active":true},"created":"2007-10-02T23:15:47.924+0000","updated":"2007-10-02T23:15:47.924+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12532155","id":"12532155","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=djd","name":"djd","emailAddress":"djd at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daniel John Debrunner","active":true},"body":"The SQL Standard also specifies what a single  character is: Section 4.2.8 indicates all UCS strings should be normalized as Normalization Form C (NFC) as defined by Unicode technical report 15.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=djd","name":"djd","emailAddress":"djd at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daniel John Debrunner","active":true},"created":"2007-10-03T16:32:10.439+0000","updated":"2007-10-03T16:32:10.439+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12532518","id":"12532518","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I spent some time on Unicode specification and SQL specification in regards to this Jira entry and DERBY-3080. SQL specification, Section 3.1.1.1 says this for character \"This is identical to the Unicode definition of abstract character. In ISO/IEC 9075, when the relevant character repertoire is UCS, a character can be thought of as that which is represented by one code point.\" The Unicode standard specifies a numeric value (code point) and a name for each of its characters. \r\n\r\nSo, the question is, in say Norwegian, what do we call \"AA\"? Is it a character or something else? Unicode specificaiton has a concept of text elemenets and characters (http://www.unicode.org/versions/Unicode5.0.0/ch02.pdf Unicode chapter 2 Section 2.1 subtopic \"Text Elements, Characters, and Text Processes\". Text elements are units in a text and there are several kinds of text elements, some of which are grapheme clusters(\"user-perceived characters\"), words, sentences etc. Characters are used to represent each of these different types of text elements. Grapheme clusters are what user perceives as a single character but they may or maynot be single characters underneath. For eg, \"ch\" in Slovakian is perceived by user as a single character (ie a grapheme cluster) but it is composed of 2 characters \"c\" and \"h\" as 2. Another eg would be \"AA\" in Norwegian. Unicode treats \"AA\" as a grapheme cluster which is composed of 2 characters \"A\" and \"A\". (Unicode chapter 2 Figure 2.1 and http://unicode.org/reports/tr29/ Section 1). \r\n\r\nSo, coming to our question of should \"AA\" be treated as 2 characters in like but as one character in = operation? http://www.unicode.org/versions/Unicode5.0.0/ch02.pdf chapter 2 Section 2.1 subtopic \"Text Elements, Characters, and Text Processes\" also talks about how something can be a text element for one kind of text processing but not for another kind of text processing. I think what we are discussing here is that for Norwegian, we want to treat \"AA\" as grapheme cluster when we are using an = operator eg \"AA\" = 'Å' but \"AA\" is not a grapheme cluster when it is used in a LIKE operation eg 'AA' LIKE 'Å'. In other words, we want to use a CollationElementIterator on entire character string when we are dealing with = operator. But when working with LIKE operator, we want to generate a CollationElementIterator for one character at a time rather than one a grapheme cluster. This logic goes with what SQL spec wants us to do for = and LIKE. \r\n\r\nQuoting SQL spec for = Section 8.2 <comparison predicate> General Rules 3d) \"Depending on the collation, two strings may compare as equal even if they are of different lengths or contain different sequences of characters\". \r\n\r\nQuoting SQL spec fo LIKE General Rules 3cii)\r\n1) A substring of MCV(the string in which we are trying to find a match) is a sequence of 0 (zero) or more contiguous characters of MCV and each character of MCV is part of exactly one substring.\r\n2) If the i-th substring of PCV(the pattern that we are looking for in MCV) is an arbitrary character specifier, then the i-th substring of MCV is any single character.\r\n3) If the i-th substring of PCV is an arbitrary string specifier, then the i-th substring of MCV is any sequence of 0 (zero) or more characters.\r\n4) If the i-th substring of PCV is a single character specifier, then the i-th substring of MCV contains exactly 1 (one) character that is equal to the character represented by the single character specifier according to the collation of the <like predicate>.\r\n5) The number of substrings of MCV is equal to the number of substring specifiers of PCV.\r\n\r\nBased on above, I think the like method for territory based character string types has to deal with one character at a time in pattern and in value string. If the character in pattern is not a metacharacter, then we should convert it into it's collation element(s) and compare it with the collation elements(s) of the next character in value string. If the character in pattern is _, then we should eat next element in value string. If the character in pattern is escape character, then we should look at next character in pattern and convert it into it's collation element(s) and compare it with the collation element(s) of the next character in value string. Finally, if the character in pattern is %, then we should eat 0 to n character in value string until we find a match for rest of the pattern characters or we find a mismatch following the algorithm in this paragraph.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-10-04T20:25:11.585+0000","updated":"2007-10-04T20:25:11.585+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12533261","id":"12533261","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Bernt Johnsen made following comments on the derby dev list\r\n\r\n\">>>>>>>>>>>> Mamta A. Satoor (JIRA) wrote (2007-10-04 13:25:50):\r\n\r\n>\r\n> So, the question is, in say Norwegian, what do we call \"AA\"? Is it a\r\n> character or something else? Unicode specificaiton has a concept of\r\n> text elemenets and characters\r\n> (http://www.unicode.org/versions/Unicode5.0.0/ch02.pdf Unicode\r\n> chapter 2 Section 2.1 subtopic \"Text Elements, Characters, and Text\r\n> Processes\". Text elements are units in a text and there are several\r\n> kinds of text elements, some of which are grapheme\r\n> clusters(\"user-perceived characters\"), words, sentences\r\n> etc. Characters are used to represent each of these different types\r\n> of text elements. Grapheme clusters are what user perceives as a\r\n> single character but they may or maynot be single characters\r\n> underneath. For eg, \"ch\" in Slovakian is perceived by user as a\r\n> single character (ie a grapheme cluster) but it is composed of 2\r\n> characters \"c\" and \"h\" as 2. Another eg would be \"AA\" in\r\n> Norwegian. Unicode treats \"AA\" as a grapheme cluster which is\r\n> composed of 2 characters \"A\" and \"A\". (Unicode chapter 2 Figure 2.1\r\n> and http://unicode.org/reports/tr29/ Section 1).\r\n\r\n\r\nThe way I understand the Unicode standard, graphems and graphem\r\nclusters are solely there for rendering while characters and combining\r\ncharacters are there for text processing. Thus, we should not consider\r\ngraphemes when we are discussing SQL.\r\n\r\nIn Norwegian, there are no combining character which make up \"aa\" and\r\nthus \"aa\" is TWO characters. However, for sorting purposes, \"aa\" is\r\none text element. For all other purposes it is two text elements.\r\n\r\nMy conclusion here is that \"aa\" = \"å\" is false and \"aa\" LIKE \"å\" is\r\nfalse too, and that CHARACTER_LENGTH(\"aa\") always gives 2.\r\n\r\n(REMARK: A person with the name \"Håkon\" may not write his name\r\n\"Haakon\" and vice versa. The strings are not equal, and it is not the\r\nsame name. They are, however, of the same origin (old Norse \"Hákonn\" I\r\nthink), pronounced the same way and they are sorted together).\r\n\r\n(REMARK 2 (and not relevant for this discussion): \"AA\" is not used in\r\nmodern Norwegian language. You will only find it in names of persons,\r\ncompanies and organizations).\r\n\r\n\r\nBernt\r\n\"\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-10-09T04:37:21.342+0000","updated":"2007-10-09T04:37:21.342+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12533263","id":"12533263","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Bernt, I tend to disagree with 'aa'='å' is false statement based on my understanding of SQL spec Section 8.2 <comparison predicate> General Rules 3c) and 3d). \r\n3c) The result of the comparison of X and Y is given by the collation CS.\r\n3d) Depending on the collation, two strings may compare as equal even if they are of different lengths or contain different sequences of characters.\r\n\r\nBased on these 2 rules, if the collation CS for Norwegian compares 'aa' and 'å' as true, then the result of 'aa'='å' will be true. In other words, if the collation elements for 'aa' matches 'å', then it means that collation CS compares them equal.\r\n\r\nI can see how a person with name \"Håkon\" may not write his name \"Haakon\" or vice versa but I think if my interpretation of SQL spec is right, then SQL is going to treat \"Håkon\"=\"Haakon\" depending on the collation CS. Do let me know if my understanding of SQL spec in this area is incorrect.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-10-09T04:48:20.691+0000","updated":"2007-10-09T04:48:20.691+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12533306","id":"12533306","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bernt","name":"bernt","emailAddress":"bernt at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bernt M. Johnsen","active":true},"body":"Mamta, you are right. SQL spec Section 4.2.2 also defines the relation between collation and comparision very clear. The downside is that most applications using collation must be very careful in the use of collation to get the correct semantics. Since \"Håkon\" and \"Haakon\" as alternate ways of spelling the same name will be considered equal while \"Christian\" and \"Kristian\" which also is alternate spellings of another name will not. But, that is beside the point. The SQL standard is very clear.\r\n\r\nThen, to use the lingo from Unicode. \"aa\" will be one *text element* (not a grapheme cluser) with regards to both sorting and comparision.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bernt","name":"bernt","emailAddress":"bernt at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bernt M. Johnsen","active":true},"created":"2007-10-09T09:03:54.298+0000","updated":"2007-10-09T09:03:54.298+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12533310","id":"12533310","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bernt","name":"bernt","emailAddress":"bernt at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bernt M. Johnsen","active":true},"body":"I also agree that even if 'aa'='å' should be true with Norwegian collation, 'aa' LIKE 'å' should give false according to secion 8.5 which says that LIKE is done on a character by character comparision. 'aa' is two characters while 'å' is one.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=bernt","name":"bernt","emailAddress":"bernt at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Bernt M. Johnsen","active":true},"created":"2007-10-09T09:12:38.836+0000","updated":"2007-10-09T09:12:38.836+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12533401","id":"12533401","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=djd","name":"djd","emailAddress":"djd at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daniel John Debrunner","active":true},"body":"Actually I think the correct terminology for this is Contractions, from Unicode TR10 which is the specification for collation. The example given there (which avoids the 'aa' not in use issue), is 'ch' for Spanish.\r\n\r\nhttp://unicode.org/reports/tr10/#Contractions","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=djd","name":"djd","emailAddress":"djd at apache dot org","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Daniel John Debrunner","active":true},"created":"2007-10-09T16:08:55.984+0000","updated":"2007-10-09T16:08:55.984+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12534114","id":"12534114","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I am attaching a new patch (DERBY2967_Oct11_07_diff.txt) which is much simpler than earlier patches because the implementation of LIKE for UCS_BASIC and territory based character string types do not differ much(based on SQL standard as explained in earlier few comments to this Jira entry). I have been able to change the existing code for LIKE (in Like.java) for UCS_BASIC character strings to support territory based character strings. The existing method in Like.java now gets a new parameter and it is RuleBasedCollator. For UCS_BASIC strings, this will be passed as NULL. We check if the RuleBasedCollator is NULL and if so then we do simple one character equality check for non-metacharacters in pattern and correspnding characters in value string. But if RuleBasedCollator is not NULL, then we use it to get collation element(s) for one character at a time for non-metacharacters in patterns and corresponding characters in value string and do the collation element(s) comparison to establish equality. \r\n\r\nIn addition to the above mentioned change in Like.java, I have changed the callers of the method in Like.java to pass correct value for the RuleBasedCollator. \r\n\r\nAdditionally, I have added a test to CollationTest.java for the code changes. Existing like tests in CollationTest2.java were very useful in the testing of my changes. And lastly, I changed few of the existing tests to use different character string values so that when we run the full collation tests, we do not see some of the test failures which are genuine because of the nature of their data. \r\n\r\nWould appreciate if someone has time to review the patch for me. I will plan on committing this early next week if there are no issues.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-10-11T18:20:50.625+0000","updated":"2007-10-11T18:20:50.625+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12535339","id":"12535339","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Committed(revision 585261) DERBY2967_Oct11_07_diff.txt into main codeline with following commit comments\r\n\r\nCommiting the patch (DERBY2967_Oct11_07_diff.txt) attached to DERBY-2967. The implementation of LIKE for UCS_BASIC and territory based character string types do not differ much(based on SQL standard as explained in comments to this Jira entry). I have been able to change the existing code for LIKE (in Like.java) for UCS_BASIC character strings to support territory based character strings. The existing method in Like.java now gets a new parameter and it is RuleBasedCollator. For UCS_BASIC strings, this will be passed as NULL. We check if the RuleBasedCollator is NULL and if so then we do simple one character equality check for non-metacharacters in pattern and correspnding characters in value string. But if RuleBasedCollator is not NULL, then we use it to get collation element(s) for one character at a time for non-metacharacters in patterns and corresponding characters in value string and do the collation element(s) comparison to establish equality. \r\n\r\nIn addition to the above mentioned change in Like.java, I have changed the callers of the method in Like.java to pass correct value for the RuleBasedCollator. \r\n\r\nAdditionally, I have added a test to CollationTest.java for the code changes. Existing like tests in CollationTest2.java were very useful in the testing of my changes. And lastly, I changed few of the existing tests to use different character string values so that when we run the full collation tests, we do not see some of the test failures which are genuine because of the nature of their data. \r\n\r\nFile committed are as follows\r\nM    java/engine/org/apache/derby/iapi/types/Like.java\r\nM    java/engine/org/apache/derby/iapi/types/SQLChar.java\r\nM    java/engine/org/apache/derby/iapi/types/WorkHorseForCollatorDatatypes.java\r\nM    java/testing/org/apache/derbyTesting/unitTests/lang/T_Like.java\r\nM    java/testing/org/apache/derbyTesting/functionTests/tests/lang/CollationTest.java\r\nM    java/testing/org/apache/derbyTesting/functionTests/tests/lang/CollationTest2.java\r\nM    java/testing/org/apache/derbyTesting/functionTests/tests/lang/DynamicLikeOptimizationTest.java\r\nM    java/testing/org/apache/derbyTesting/functionTests/tests/lang/StreamsTest.java\r\nM    java/testing/org/apache/derbyTesting/functionTests/tests/nist/dml068.sql\r\nM    java/testing/org/apache/derbyTesting/functionTests/tests/nist/xts729.sql\r\nM    java/testing/org/apache/derbyTesting/functionTests/master/dml068.out\r\nM    java/testing/org/apache/derbyTesting/functionTests/master/xts729.out\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-10-16T20:48:24.583+0000","updated":"2007-10-16T20:48:24.583+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12535479","id":"12535479","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I read the Oct 11 patch in the commit log and I have a question about checkEquality(). Sorry that I didn't comment before.\r\n\r\nIt looks like checkEquality() will create two String objects and two CollationElementIterator objects per character we want to check. This sounds overly expensive to me. Do you think there is a cheaper way to achieve the same?\r\n\r\nI have a couple of ideas which may or may not work:\r\n\r\na) We could use the compare() method instead of iterators. It caches and reuses the iterators across calls and therefore it might be more efficient. It would also simplify the code, since the else clause in checkEquality() could be rewritten to:\r\n\r\n} else {//dealing with territory based character string\r\n    return collator.compare(new String(pat, pLoc, 1), new String(val, vLoc, 1)) == 0:\r\n}\r\n\r\nb) To eliminate *both* the String allocations and the CollationElementIterator allocations, I think we could allocate one CollationElementIterator for each string (as opposed to each character) and use setOffset()/getOffset() to ensure that we work on one character at a time.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2007-10-17T08:54:02.263+0000","updated":"2007-10-17T08:54:02.263+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12535953","id":"12535953","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Migrated changes from trunk(revision 585261) into 10.3(revision 586019) codeline with following commit comments\r\n\r\nMigrating changes (revision 585261) from trunk into 10.3 codeline. I had to make some manual changes after merging because CollationTest had few changes in main which were not part of 10.3 codeline. The commit comments for the trunk codeline checkin were as follows\r\n\r\nCommiting the patch (DERBY2967_Oct11_07_diff.txt) attached to DERBY-2967. The implementation of LIKE for UCS_BASIC and territory based character string types do not differ much(based on SQL standard as explained in comments to this Jira entry). I have been able to change the existing code for LIKE (in Like.java) for UCS_BASIC character strings to support territory based character strings. The existing method in Like.java now gets a new parameter and it is RuleBasedCollator. For UCS_BASIC strings, this will be passed as NULL. We check if the RuleBasedCollator is NULL and if so then we do simple one character equality check for non-metacharacters in pattern and correspnding characters in value string. But if RuleBasedCollator is not NULL, then we use it to get collation element(s) for one character at a time for non-metacharacters in patterns and corresponding characters in value string and do the collation element(s) comparison to establish equality. \r\n\r\nIn addition to the above mentioned change in Like.java, I have changed the callers of the method in Like.java to pass correct value for the RuleBasedCollator. \r\n\r\nAdditionally, I have added a test to CollationTest.java for the code changes. Existing like tests in CollationTest2.java were very useful in the testing of my changes. And lastly, I changed few of the existing tests to use different character string values so that when we run the full collation tests, we do not see some of the test failures which are genuine because of the nature of their data. \r\n\r\nM    java/engine/org/apache/derby/iapi/types/Like.java\r\nM    java/engine/org/apache/derby/iapi/types/SQLChar.java\r\nM    java/engine/org/apache/derby/iapi/types/WorkHorseForCollatorDatatypes.java\r\nM    java/testing/org/apache/derbyTesting/unitTests/lang/T_Like.java\r\nM    java/testing/org/apache/derbyTesting/functionTests/tests/lang/CollationTest.java\r\nM    java/testing/org/apache/derbyTesting/functionTests/tests/lang/CollationTest2.java\r\nM    java/testing/org/apache/derbyTesting/functionTests/tests/lang/DynamicLikeOptimizationTest.java\r\nM    java/testing/org/apache/derbyTesting/functionTests/tests/lang/StreamsTest.java\r\nM    java/testing/org/apache/derbyTesting/functionTests/tests/nist/dml068.sql\r\nM    java/testing/org/apache/derbyTesting/functionTests/tests/nist/xts729.sql\r\nM    java/testing/org/apache/derbyTesting/functionTests/master/dml068.out\r\nM    java/testing/org/apache/derbyTesting/functionTests/master/xts729.out\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-10-18T15:57:58.206+0000","updated":"2007-10-18T15:57:58.206+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12535958","id":"12535958","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Thanks, Knut,  for checking my commit. I was hesitant too about all the objects creations.\r\n\r\nI think we can definitely make the first change suggested by you. I will go ahead and give it a try\r\n*************part of the change suggested by Knut****************\r\na) We could use the compare() method instead of iterators. It caches and reuses the iterators across calls and therefore it might be more efficient. It would also simplify the code, since the else clause in checkEquality() could be rewritten to: \r\n\r\n} else {//dealing with territory based character string \r\n    return collator.compare(new String(pat, pLoc, 1), new String(val, vLoc, 1)) == 0: \r\n} \r\n*************end of part of the change suggested by Knut*********\r\n\r\nBut as for the second alternative, we can't create a CollationElementIerator for the entire string ahead of time for LIKE operation. Let me use an example to illustrate why. In Norway, the collation element(s) returned for string 'aa' is not same as collation element(s) return for one 'a' at a time. So, when the user has a WHERE clause  'caad' LIKE '%a%', SQL spec requires us to return a TRUE for this WHERE clause. We will not implement that behavior if we generated collation elements for entire string 'caad' at one shot. We need to break 'caad' into four characters and have collation element for each one of those 4 characters. In Norway, if we generated collation elements for string 'caad', it will find only 3 characters in that string and those 3 characters will be 'c', 'aa' and 'd'.  Because of this, we have to generate collation element(s) one character at a time.\r\n\r\nWould love to hear if there are any other ideas to cut down on object creation.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-10-18T16:09:46.177+0000","updated":"2007-10-18T16:09:46.177+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12535972","id":"12535972","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"According to the javadoc for CollationElementIterator, setOffset() and getOffset() work on characters, not on collation elements, so I think you can use those methods to detect the aa case. If you have this code in locale no_NO:\r\n\r\n  CollationElementIterator it = collator.getCollationElementIterator(\"aa\");\r\n  int coll = it.next();\r\n\r\nI think it.getOffset() will return 0 before the call to next() and 2 after the call. So you'll notice that there are more than one character, and, if required, use a heavier test for that character.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2007-10-18T17:00:08.424+0000","updated":"2007-10-18T17:00:08.424+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12535974","id":"12535974","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Another simple way to cut down the string allocations... I think you could express checkEquality() like this:\r\n\r\n    if (val[vLoc] == pat[pLoc]) {\r\n        // same character, so two strings consisting of this\r\n        // single character must be equal regardless of territory\r\n        return true;\r\n    } else if (collator == null) {\r\n        // not same character, must be unequal in UCS_BASIC\r\n        return false;\r\n    }\r\n\r\n    String s1 = new String(val, vLoc, 1);\r\n    String s1 = new String(pat, pLoc, 1);\r\n\r\n    return collator.compare(s1, s2) == 0;\r\n\r\nThis would only allocate new objects if the characters are not equal.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2007-10-18T17:08:59.767+0000","updated":"2007-10-18T17:08:59.767+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12535975","id":"12535975","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Knut, I really like the last suggestion because it will keep the code easy to understand. I think the earlier suggestion about using getOffset and setOffset will complicate the code and make it hard to understand and maintain.\r\n\r\nI will work on your last suggestion.\r\n\r\n******great suggestion by Knut to cut down on unnecessary objection creations****\r\nAnother simple way to cut down the string allocations... I think you could express checkEquality() like this: \r\n\r\n    if (val[vLoc] == pat[pLoc]) { \r\n        // same character, so two strings consisting of this \r\n        // single character must be equal regardless of territory \r\n        return true; \r\n    } else if (collator == null) { \r\n        // not same character, must be unequal in UCS_BASIC \r\n        return false; \r\n    } \r\n\r\n    String s1 = new String(val, vLoc, 1); \r\n    String s1 = new String(pat, pLoc, 1); \r\n\r\n    return collator.compare(s1, s2) == 0; \r\n\r\nThis would only allocate new objects if the characters are not equal. \r\n******************************************************************************************\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-10-18T17:14:29.638+0000","updated":"2007-10-18T17:14:29.638+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12535987","id":"12535987","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"One more question: In the discussion above, I see that the special case where two strings of different length map to the same sequence of collation elements, has been discussed. What about two characters, c1 and c2, which have different Unicode codepoints, but map to the same sequence of collation elements. Should both c1 = c2 and c1 LIKE c2 be true? That's how it's implemented, but I'm not sure whether c1 LIKE c2 should be true or false. I haven't checked what the standard says (and I'm not sure I want to... ;) ), but it feels a bit strange that two different characters should be LIKE because they have the same collation elements, when 'aa' is not LIKE 'å' because they are not the same single character. I understand how we can split the character sequence 'aa' into the single characters 'a' and 'a'. I don't understand how we can take a single collation element 'aa' and split it into two separate collation elements 'a' and 'a'. I'm sure the standard says it's correctly implemented, and I guess its wording will make it quite clear, perhaps even logical, that it has to be that way. I just wanted to double check that we had verified it...","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2007-10-18T17:36:14.195+0000","updated":"2007-10-18T17:36:14.195+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12535993","id":"12535993","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"I just realized how confusing my comment must have been... :)\r\n\r\nI'm not questioning whether it's correct that 'aa' LIKE 'å' is false. What I'm questioning is whether we can split a string into its separate characters, possibly splitting a single collation element into multiple different elements, and then do a comparison of the collation elements on each single character. To me it feels like we should forget about the collation elements once we have split the string into characters, since the information about collation elements got lost in the process of splitting, and just do a simple codepoint comparison on the character level. Again, I'm sure the standard says I'm wrong...","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2007-10-18T17:53:59.945+0000","updated":"2007-10-18T17:53:59.945+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12536004","id":"12536004","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Knut, we can not ignore the collation and just compare the codepoint for territory based characters involved in LIKE operaiton. This is based of SQL spec for LIKE(Section 8.5) General Rules 3cii4) \r\n4) If the i-th substring of PCV is a single character specifier, then the i-th substring of MCV contains exactly 1 (one) character that is equal to the character represented by the single character specifier according to the collation of the <like predicate>. \r\n\r\nHere it says that we need to establish the equality according to the collation of the <like predicate>.\r\n\r\nAs always, let me know if I interpretation of SQL is incorrect.\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-10-18T18:36:12.973+0000","updated":"2007-10-18T18:36:12.973+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12536105","id":"12536105","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I have entered jira entry DERBY-3136 to improve on object creations.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-10-19T04:54:57.159+0000","updated":"2007-10-19T04:54:57.159+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12536170","id":"12536170","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Thanks for pointing me to the right part of the standard, Mamta. I interpret general rule 3cii the same way as you do.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2007-10-19T10:12:57.690+0000","updated":"2007-10-19T10:12:57.690+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12536570","id":"12536570","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"The coding for this jira entry is over(I have created a new jira entry DERBY-3136 to improve on object creations). \r\n\r\nI am wondering though if we should include something in our documentation to show the difference between = and LIKE in a territory based database. For eg, even though 'aa' = 'å' in Norwegian territory, 'aa' LIKE 'å'  will not return true in Norwegian territory. That is, we probably should document somewhere that LIKE is entirely collation comparison of one character at a time in a territory based database.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-10-22T05:39:01.955+0000","updated":"2007-10-22T05:39:01.955+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12536705","id":"12536705","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"When you said \"even though 'aa' = 'å' in Norwegian territory\", do you mean the SQL = operator? That doesn't seem to work on trunk. Is there a JIRA issue I have missed?\r\n\r\nij> connect 'jdbc:derby:nodb;create=true;territory=no_NO;collation=TERRITORY_BASED';\r\nij> select * from sysibm.sysdummy1 where 'å' = 'aa';\r\nIBM&\r\n----\r\n\r\n0 rows selected","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2007-10-22T15:21:22.142+0000","updated":"2007-10-22T15:21:22.142+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12536768","id":"12536768","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Knut, yes, I did mean the SQL = operation. Also, thanks for your testing.\r\n\r\nFrom various discussions in the past on Derby list about aa and å in Norwegian, I made the assumption that the JVM's collation table for Norwegian must have same collation element for aa and å. But that is not the case as shwon by your test case inside ij. I also wrote a very simple test case outside of Derby(copied below) which shows the collation elements for aa and å are different in Norwegian and that is why the SQL operation 'aa'='å' is returning false.\r\n\r\nRuleBasedCollator myCollator = (RuleBasedCollator)Collator.getInstance(new Locale(\"da\",\"DK\"));\r\n\r\nSystem.out.println(\"what happens if iterator is on aa string\");\r\nCollationElementIterator aIterator = myCollator.getCollationElementIterator(\"aa\");\r\nSystem.out.println(\"next is \" + aIterator.next());\r\nSystem.out.println(\"offset is \" + aIterator.getOffset());\r\nSystem.out.println(\"next is \" + aIterator.next());\r\nSystem.out.println(\"offset is \" + aIterator.getOffset());\r\n\r\nSystem.out.println(\"what happens if iterator is on å string\");\r\naIterator = myCollator.getCollationElementIterator(\"å\");\r\nSystem.out.println(\"next is \" + aIterator.next());\r\nSystem.out.println(\"offset is \" + aIterator.getOffset());\r\nSystem.out.println(\"next is \" + aIterator.next());\r\nSystem.out.println(\"offset is \" + aIterator.getOffset());\r\n\r\nOutput of the code above\r\nwhat happens if iterator is on aa string\r\nnext is 7405570\r\noffset is 2\r\nnext is -1\r\noffset is 2\r\nwhat happens if iterator is on σ string\r\nnext is 7405568\r\noffset is 1\r\nnext is -1\r\noffset is 1\r\n\r\nSo, my example to show different behavior of SQL LIKE and SQL = is not correct. \r\n\r\nI am wondering if anyone knows of any characters in a language where the characters are different but they have the same collation elements in that language. The test case is going to require different *number* of characters in each side of =. Having different *number* of characters(but same collation element(s)) is crucial to show the difference between = and LIKE.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-10-22T17:59:43.768+0000","updated":"2007-10-22T17:59:43.768+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12536792","id":"12536792","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"body":"Thanks Mamta, that makes sense.\r\n\r\n> I am wondering if anyone knows of any characters in a language where\r\n> the characters are different but they have the same collation\r\n> elements in that language.\r\n\r\nFWIW, I grepped for '=' in the CollationData classes (they contain the\r\nrules used by the locale-specific RuleBasedCollators) in OpenJDK but I\r\ndidn't find any multi-character sequences that had the same collation\r\nelements as another character or sequence of characters.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=knutanders","name":"knutanders","emailAddress":"knut dot hatlen at oracle dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Knut Anders Hatlen","active":true},"created":"2007-10-22T18:59:37.302+0000","updated":"2007-10-22T18:59:37.302+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12539108","id":"12539108","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=scotsmatrix","name":"scotsmatrix","emailAddress":"scotsmatrix at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Laura Stewart","active":true},"body":"I have opened Derby-3166 as a doc issue for this dev issue.  My impression is that LIKE only compares single characters and contractions (aa or ch) are not compared. Is there anything else that needs to be documented?  Please add any comments that you have about what needs to be updated in the docs to the new doc issue Derby-3166.  Thanks!","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=scotsmatrix","name":"scotsmatrix","emailAddress":"scotsmatrix at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Laura Stewart","active":true},"created":"2007-10-31T15:52:27.509+0000","updated":"2007-10-31T15:52:27.509+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12540281","id":"12540281","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Attached, please find the release notes for this Jira entry. I tend to be verbose with my notes, so please feel free to condense them or offer any other suggestions.\r\n\r\nAlso, when I tried using \r\njava org.apache.derbyBuild.ReleaseNoteReader releaseNotes.html\r\nI kept getting following error\r\nException in thread \"main\" java.io.UTFDataFormatException: Invalid byte 1 of 1-byte UTF-8 sequence.\r\n        at org.apache.xerces.impl.io.UTF8Reader.invalidByte(Unknown Source)\r\n        at org.apache.xerces.impl.io.UTF8Reader.read(Unknown Source)\r\n        at org.apache.xerces.impl.XMLEntityScanner.load(Unknown Source)\r\n        at org.apache.xerces.impl.XMLEntityScanner.scanContent(Unknown Source)\r\n        at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanContent(Unknown Source)\r\n        at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(Unknown Source)\r\n        at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source)\r\n        at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source)\r\n        at org.apache.xerces.parsers.DTDConfiguration.parse(Unknown Source)\r\n        at org.apache.xerces.parsers.XMLParser.parse(Unknown Source)\r\n        at org.apache.xerces.parsers.DOMParser.parse(Unknown Source)\r\n        at org.apache.xerces.jaxp.DocumentBuilderImpl.parse(Unknown Source)\r\n        at javax.xml.parsers.DocumentBuilder.parse(DocumentBuilder.java:98)\r\n        at org.apache.derbyBuild.ReleaseNoteReader.getReleaseNote(ReleaseNoteReader.java:130)\r\n        at org.apache.derbyBuild.ReleaseNoteReader.main(ReleaseNoteReader.java:107)","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-11-05T21:27:44.939+0000","updated":"2007-11-05T21:27:44.939+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12540291","id":"12540291","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Attaching the release notes with proper name.  Kathey mentioned that \"I think the name should be releaseNote.html to get picked up by the release notes tool. Kathey\"","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-11-05T22:45:05.805+0000","updated":"2007-11-05T22:45:05.805+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12542846","id":"12542846","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Can this issue be resolved?\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2007-11-15T18:54:40.298+0000","updated":"2007-11-15T18:54:40.298+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12545588","id":"12545588","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"I have created a new jira entry DERBY-3228 for the only remaining item for this jira entry which is adding a specific test case. (DERBY-3228's description reads as \"Add a test case for collation where in some territory, more than one character sequence(say n characters and say that character sequence is seq1) has same collation elements as some other character sequence(with >n or <n characters and say that character sequence is seq2) so we can demonstrate that for that territory the predicate seq1=seq2 will return TRUE but predicate seq1 LIKE seq2 will return FALSE. The engine code changes for this test case went in as part of DERBY-2967. More info if needed can be found there).\"\r\n\r\nWill go ahead and close this jira entry so that the release notes attached to it can be included as part of 10.3.2 release.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-11-26T20:21:12.112+0000","updated":"2007-11-26T20:21:12.112+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12545603","id":"12545603","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"reattaching release note. There was some sort of problem with the original release note. It gave:\r\n[generateReleaseNotes]\r\n[generateReleaseNotes] Unable to read or parse release note for DERBY-2967: org.xml.sax.SAXParseException: Invalid byte\r\n1 of 1-byte UTF-8 sequence.\r\n[generateReleaseNotes] org.xml.sax.SAXParseException: Invalid byte 1 of 1-byte UTF-8 sequence.\r\n\r\nContent has not changed\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2007-11-26T21:03:27.453+0000","updated":"2007-11-26T21:03:27.453+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12545630","id":"12545630","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Kathey, thanks for trying to resolve the problem with release notes for DERBY-2967. \r\n \r\nI had not intended to use any unprintable characters in the release notes. I noticed that you mail to derby-dev about release notes has ? characters(I guess those are the unprintable characters) in the \"Symptoms Seen by Applications Affected by Change\" section for DERBY-2967. Those ? characters should really be just '. I see that there are other places in \"Symptoms Seen by Applications Affected by Change\" where ' didn't get changed to unprintable characters. I am not sure why some of ' are getting treated as unprintable character. So, in short, wherever we see ? in the \"Symptoms Seen by Applications Affected by Change\" section for DERBY-2967, we should really have ' there. \r\n \r\nHope this is clear,\r\nMamta\r\n","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-11-26T22:26:40.114+0000","updated":"2007-11-26T22:26:40.114+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12546315","id":"12546315","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"body":"Attach release note with ' instead of ? to try to get release note generator working.","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=kmarsden","name":"kmarsden","emailAddress":"kmarsdenderby at sbcglobal dot net","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Kathey Marsden","active":true},"created":"2007-11-28T17:48:43.957+0000","updated":"2007-11-28T17:48:43.957+0000"},{"self":"https://issues.apache.org/jira/rest/api/2/issue/12374390/comment/12546341","id":"12546341","author":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"body":"Kathey, I did a quick review of the release note and it looks good. Hope the release note generator works with it. Thanks","updateAuthor":{"self":"https://issues.apache.org/jira/rest/api/2/user?username=mamtas","name":"mamtas","emailAddress":"msatoor at gmail dot com","avatarUrls":{"48x48":"https://issues.apache.org/jira/secure/useravatar?avatarId=10452","24x24":"https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452","16x16":"https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452","32x32":"https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"},"displayName":"Mamta A. Satoor","active":true},"created":"2007-11-28T18:34:18.448+0000","updated":"2007-11-28T18:34:18.448+0000"}]},"votes":{"self":"https://issues.apache.org/jira/rest/api/2/issue/DERBY-2967/votes","votes":0,"hasVoted":false},"worklog":{"startAt":0,"maxResults":20,"total":0,"worklogs":[]},"customfield_12311820":"0|i0763z:"}}